(* Xm/XmAllP.def  Nov 27  0:47:5  1996 *)
(* Copyright (c) 1996,1997 XDS Ltd, Russia. All rights reserved. *)

(* Converted from Xm/XmAllP.h using H2D v1.18.6a *)

(* $RCSfile: XmAllP.def,v $ $Revision: 5 $ $Date: 28.07.98 23:15 $ *)

<*+ M2ADDTYPES *>
<*+ M2EXTENSIONS *>
<*+ NOHEADER *>
<* IF NOT DEFINED(GENTYPEDEF) THEN *> <* NEW GENTYPEDEF+ *> <* END *>
<*+ CSTDLIB *>
<*+ WOFF354 *>

(* Merged headers: Xm/Xm.h, Xm/Xm.h, Xm/XmStrDefs.h, Xm/VendorS.h,
Xm/VendorSP.h, Xm/DesktopP.h, Xm/ExtObjectP.h, Xm/ManagerP.h, Xm/PrimitiveP.h,
Xm/GadgetP.h, Xm/BaseClassP.h, Xm/ArrowBP.h, Xm/ArrowB.h, Xm/ArrowBGP.h,
Xm/ArrowBG.h, Xm/AtomMgr.h, Xm/BulletinBP.h, Xm/BulletinB.h, Xm/CascadeBP.h,
Xm/CascadeB.h, Xm/LabelP.h, Xm/Label.h, Xm/CascadeBGP.h, Xm/CascadeBG.h,
Xm/LabelGP.h, Xm/LabelG.h, Xm/CacheP.h, Xm/CommandP.h, Xm/SelectioBP.h,
Xm/SelectioB.h, Xm/Command.h, Xm/DialogSP.h, Xm/DialogS.h, Xm/DialogSEP.h,
Xm/VendorSEP.h, Xm/ShellEP.h, Xm/MwmUtil.h, Xm/DisplayP.h, Xm/DragDropP.h,
Xm/DragCP.h, Xm/DragC.h, Xm/DragIconP.h, Xm/DragIcon.h, Xm/DragOverSP.h,
Xm/DragOverS.h, Xm/DropSMgrP.h, Xm/DropSMgr.h, Xm/DropTransP.h, Xm/DropTrans.h,
Xm/Display.h, Xm/ScreenP.h, Xm/Screen.h, Xm/VirtKeysP.h, Xm/VirtKeys.h,
Xm/DrawP.h, Xm/DrawingAP.h, Xm/DrawingA.h, Xm/DrawnBP.h, Xm/DrawnB.h,
Xm/FileSBP.h, Xm/FileSB.h, Xm/FormP.h, Xm/Form.h, Xm/FrameP.h, Xm/Frame.h,
Xm/ListP.h, Xm/List.h, Xm/ScrollBarP.h, Xm/ScrollBar.h, Xm/ScrolledWP.h,
Xm/ScrolledW.h, Xm/SeparatoGP.h, Xm/SeparatoG.h, Xm/MainWP.h, Xm/MainW.h,
Xm/MenuShellP.h, Xm/MenuShell.h, Xm/MenuUtilP.h, Xm/RowColumnP.h,
Xm/RowColumn.h, Xm/MessageBP.h, Xm/MessageB.h, Xm/PanedWP.h, Xm/PanedW.h,
Xm/ProtocolsP.h, Xm/Protocols.h, Xm/PushBP.h, Xm/PushB.h, Xm/PushBGP.h,
Xm/PushBG.h, Xm/RepType.h, Xm/RCUtilsP.h, Xm/SashP.h, Xm/ScaleP.h,
Xm/Scale.h, Xm/SeparatorP.h, Xm/Separator.h, Xm/TextP.h, Xm/TextOutP.h,
Xm/Text.h, Xm/TextInP.h, Xm/TextStrSoP.h, Xm/TextSelP.h, Xm/TextFP.h,
Xm/TextF.h, Xm/TextFSelP.h, Xm/TearOffP.h, Xm/TearOffBP.h, Xm/ToggleBP.h,
Xm/ToggleB.h, Xm/ToggleBGP.h, Xm/ToggleBG.h, Xm/TransltnsP.h, Xm/VaSimpleP.h,
Xm/WorldP.h *)

DEFINITION MODULE ["C"] XmAllP;

IMPORT SYSTEM, X, Xlib, Xt:=IntrinsicP, Xutil, Xrm:=Xresource, ShellP, stdio;
(* H2D:  Required IMPORT clause:
IMPORT XmAllP, X, Xlib, IntrinsicP, Xutil, Xresource, ShellP, stdio;
*)

FROM X IMPORT SET8;

(* ------------------------------------------------------ *)
(*                     Xm/XmStrDefs.h                     *)
(* ------------------------------------------------------ *)

(*
 * (c) Copyright 1989, 1990, 1991, 1992, 1993, 1994 OPEN SOFTWARE FOUNDATION, INC.
 * ALL RIGHTS RESERVED
 *)

(*
 * Motif Release 1.2.4
 *)

CONST
  XmS = '';
  XmSTRING_DEFAULT_CHARSET = XmS;
  XmCAccelerator = 'Accelerator';
  XmCAcceleratorText = 'AcceleratorText';
  XmCAdjustLast = 'AdjustLast';
  XmCAdjustMargin = 'AdjustMargin';
  XmCAlignment = 'Alignment';
  XmCAllowOverlap = 'AllowOverlap';
  XmCAnimationMask = 'AnimationMask';
  XmCAnimationPixmap = 'AnimationPixmap';
  XmCAnimationPixmapDepth = 'AnimationPixmapDepth';
  XmCAnimationStyle = 'AnimationStyle';
  XmCApplyLabelString = 'ApplyLabelString';
  XmCArmCallback = 'ArmCallback';
  XmCArmColor = 'ArmColor';
  XmCArmPixmap = 'ArmPixmap';
  XmCArrowDirection = 'ArrowDirection';
  XmCAttachment = 'Attachment';
  XmCAudibleWarning = 'AudibleWarning';
  XmCAutoShowCursorPosition = 'AutoShowCursorPosition';
  XmCAutoUnmanage = 'AutoUnmanage';
  XmCAutomaticSelection = 'AutomaticSelection';
  XmCAvailability = 'Availability';
  XmCBackgroundPixmap = 'BackgroundPixmap';
  XmCBlendModel = 'BlendModel';
  XmCBlinkRate = 'BlinkRate';
  XmCBottomShadowColor = 'BottomShadowColor';
  XmCBottomShadowPixmap = 'BottomShadowPixmap';
  XmCButtonAcceleratorText = 'ButtonAcceleratorText';
  XmCButtonAccelerators = 'ButtonAccelerators';
  XmCButtonCount = 'ButtonCount';
  XmCButtonFontList = 'ButtonFontList';
  XmCButtonMnemonicCharSets = 'ButtonMnemonicCharSets';
  XmCButtonMnemonics = 'ButtonMnemonics';
  XmCButtonSet = 'ButtonSet';
  XmCButtonType = 'ButtonType';
  XmCButtons = 'Buttons';
  XmCCancelLabelString = 'CancelLabelString';
  XmCChildHorizontalAlignment = 'ChildHorizontalAlignment';
  XmCChildHorizontalSpacing = 'ChildHorizontalSpacing';
  XmCChildPlacement = 'ChildPlacement';
  XmCChildType = 'ChildType';
  XmCChildVerticalAlignment = 'ChildVerticalAlignment';
  XmCChildren = 'Children';
  XmCClientData = 'ClientData';
  XmCClipWindow = 'ClipWindow';
  XmCColumns = 'Columns';
  XmCCommandWindow = 'CommandWindow';
  XmCCommandWindowLocation = 'CommandWindowLocation';
  XmCConvertProc = 'ConvertProc';
  XmCCursorBackground = 'CursorBackground';
  XmCCursorForeground = 'CursorForeground';
  XmCCursorPosition = 'CursorPosition';
  XmCCursorPositionVisible = 'CursorPositionVisible';
  XmCDarkThreshold = 'DarkThreshold';
  XmCDecimalPoints = 'DecimalPoints';
  XmCDefaultButtonShadowThickness = 'DefaultButtonShadowThickness';
  XmCDefaultButtonType = 'DefaultButtonType';
  XmCDefaultCopyCursorIcon = 'DefaultCopyCursorIcon';
  XmCDefaultFontList = 'DefaultFontList';
  XmCDefaultInvalidCursorIcon = 'DefaultInvalidCursorIcon';
  XmCDefaultLinkCursorIcon = 'DefaultLinkCursorIcon';
  XmCDefaultMoveCursorIcon = 'DefaultMoveCursorIcon';
  XmCDefaultNoneCursorIcon = 'DefaultNoneCursorIcon';
  XmCDefaultPosition = 'DefaultPosition';
  XmCDefaultSourceCursorIcon = 'DefaultSourceCursorIcon';
  XmCDefaultValidCursorIcon = 'DefaultValidCursorIcon';
  XmCDeleteResponse = 'DeleteResponse';
  XmCDesktopParent = 'DesktopParent';
  XmCDialogStyle = 'DialogStyle';
  XmCDialogTitle = 'DialogTitle';
  XmCDialogType = 'DialogType';
  XmCDirListItemCount = 'DirListItemCount';
  XmCDirListItems = 'DirListItems';
  XmCDirListLabelString = 'DirListLabelString';
  XmCDirMask = 'DirMask';
  XmCDirSearchProc = 'DirSearchProc';
  XmCDirSpec = 'DirSpec';
  XmCDirectory = 'Directory';
  XmCDirectoryValid = 'DirectoryValid';
  XmCDisarmCallback = 'DisarmCallback';
  XmCDoubleClickInterval = 'DoubleClickInterval';
  XmCDragContextClass = 'DragContextClass';
  XmCDragDropFinishCallback = 'DragDropFinishCallback';
  XmCDragIconClass = 'DragIconClass';
  XmCDragInitiatorProtocolStyle = 'DragInitiatorProtocolStyle';
  XmCDragMotionCallback = 'DragMotionCallback';
  XmCDragOperations = 'DragOperations';
  XmCDragOverMode = 'DragOverMode';
  XmCDragProc = 'DragProc';
  XmCDragReceiverProtocolStyle = 'DragReceiverProtocolStyle';
  XmCDropProc = 'DropProc';
  XmCDropRectangles = 'DropRectangles';
  XmCDropSiteActivity = 'DropSiteActivity';
  XmCDropSiteEnterCallback = 'DropSiteEnterCallback';
  XmCDropSiteLeaveCallback = 'DropSiteLeaveCallback';
  XmCDropSiteManagerClass = 'DropSiteManagerClass';
  XmCDropSiteOperations = 'DropSiteOperations';
  XmCDropSiteType = 'DropSiteType';
  XmCDropStartCallback = 'DropStartCallback';
  XmCDropTransferClass = 'DropTransferClass';
  XmCDropTransfers = 'DropTransfers';
  XmCEditable = 'Editable';
  XmCEntryBorder = 'EntryBorder';
  XmCEntryClass = 'EntryClass';
  XmCExportTargets = 'ExportTargets';
  XmCExposeCallback = 'ExposeCallback';
  XmCExtensionType = 'ExtensionType';
  XmCFileListItemCount = 'FileListItemCount';
  XmCFileListItems = 'FileListItems';
  XmCFileListLabelString = 'FileListLabelString';
  XmCFileSearchProc = 'FileSearchProc';
  XmCFileTypeMask = 'FileTypeMask';
  XmCFillOnArm = 'FillOnArm';
  XmCFillOnSelect = 'FillOnSelect';
  XmCFilterLabelString = 'FilterLabelString';
  XmCFontList = 'FontList';
  XmCForegroundThreshold = 'ForegroundThreshold';
  XmCHelpLabelString = 'HelpLabelString';
  XmCHighlightColor = 'HighlightColor';
  XmCHighlightOnEnter = 'HighlightOnEnter';
  XmCHighlightPixmap = 'HighlightPixmap';
  XmCHighlightThickness = 'HighlightThickness';
  XmCHorizontalFontUnit = 'HorizontalFontUnit';
  XmCHorizontalScrollBar = 'HorizontalScrollBar';
  XmCHot = 'Hot';
  XmCICCHandle = 'ICCHandle';
  XmCImportTargets = 'ImportTargets';
  XmCIncrement = 'Increment';
  XmCIncremental = 'Incremental';
  XmCIndicatorOn = 'IndicatorOn';
  XmCIndicatorSize = 'IndicatorSize';
  XmCIndicatorType = 'IndicatorType';
  XmCInitialDelay = 'InitialDelay';
  XmCInitialFocus = 'InitialFocus';
  XmCInputCreate = 'InputCreate';
  XmCInputMethod = 'InputMethod';
  XmCInvalidCursorForeground = 'InvalidCursorForeground';
  XmCIsAligned = 'IsAligned';
  XmCIsHomogeneous = 'IsHomogeneous';
  XmCItemCount = 'ItemCount';
  XmCItems = 'Items';
  XmCKeyboardFocusPolicy = 'KeyboardFocusPolicy';
  XtCKeyboardFocusPolicy = XmCKeyboardFocusPolicy;
  XmCLabelFontList = 'LabelFontList';
  XmCLabelInsensitivePixmap = 'LabelInsensitivePixmap';
  XmCLabelPixmap = 'LabelPixmap';
  XmCLabelString = 'LabelString';
  XmCLabelType = 'LabelType';
  XmCLightThreshold = 'LightThreshold';
  XmCListLabelString = 'ListLabelString';
  XmCListMarginHeight = 'ListMarginHeight';
  XmCListMarginWidth = 'ListMarginWidth';
  XmCListSizePolicy = 'ListSizePolicy';
  XmCListSpacing = 'ListSpacing';
  XmCListUpdated = 'ListUpdated';
  XmCLogicalParent = 'LogicalParent';
  XmCMainWindowMarginHeight = 'MainWindowMarginHeight';
  XmCMainWindowMarginWidth = 'MainWindowMarginWidth';
  XmCMappingDelay = 'MappingDelay';
  XmCMarginBottom = 'MarginBottom';
  XmCMarginHeight = 'MarginHeight';
  XmCMarginLeft = 'MarginLeft';
  XmCMarginRight = 'MarginRight';
  XmCMarginTop = 'MarginTop';
  XmCMarginWidth = 'MarginWidth';
  XmCMask = 'Mask';
  XmCMaxItems = 'MaxItems';
  XmCMaxLength = 'MaxLength';
  XmCMaxValue = 'MaxValue';
  XmCMaximum = 'Maximum';
  XmCMenuBar = 'MenuBar';
  XmCMenuPost = 'MenuPost';
  XmCMenuWidget = 'MenuWidget';
  XmCMessageProc = 'MessageProc';
  XmCMessageWindow = 'MessageWindow';
  XmCMinimizeButtons = 'MinimizeButtons';
  XmCMinimum = 'Minimum';
  XmCMnemonic = 'Mnemonic';
  XmCMnemonicCharSet = 'MnemonicCharSet';
  XmCMoveOpaque = 'MoveOpaque';
  XmCMultiClick = 'MultiClick';
  XmCMustMatch = 'MustMatch';
  XmCMwmDecorations = 'MwmDecorations';
  XmCMwmFunctions = 'MwmFunctions';
  XmCMwmInputMode = 'MwmInputMode';
  XmCMwmMenu = 'MwmMenu';
  XmCMwmMessages = 'MwmMessages';
  XmCNavigationType = 'NavigationType';
  XmCNeedsMotion = 'NeedsMotion';
  XmCNoMatchString = 'NoMatchString';
  XmCNoResize = 'NoResize';
  XmCNoneCursorForeground = 'NoneCursorForeground';
  XmCNotifyProc = 'NotifyProc';
  XmCNumChildren = 'NumChildren';
  XmCNumColumns = 'NumColumns';
  XmCNumDropRectangles = 'NumDropRectangles';
  XmCNumDropTransfers = 'NumDropTransfers';
  XmCNumExportTargets = 'NumExportTargets';
  XmCNumImportTargets = 'NumImportTargets';
  XmCOffset = 'Offset';
  XmCOkLabelString = 'OkLabelString';
  XmCOperationChangedCallback = 'OperationChangedCallback';
  XmCOperationCursorIcon = 'OperationCursorIcon';
  XmCOptionLabel = 'OptionLabel';
  XmCOptionMnemonic = 'OptionMnemonic';
  XmCOutputCreate = 'OutputCreate';
  XmCPacking = 'Packing';
  XmCPageIncrement = 'PageIncrement';
  XmCPaneMaximum = 'PaneMaximum';
  XmCPaneMinimum = 'PaneMinimum';
  XmCPattern = 'Pattern';
  XmCPendingDelete = 'PendingDelete';
  XmCPopupEnabled = 'PopupEnabled';
  XmCPositionIndex = 'PositionIndex';
  XmCPostFromButton = 'PostFromButton';
  XmCPostFromCount = 'PostFromCount';
  XmCPostFromList = 'PostFromList';
  XmCPreeditType = 'PreeditType';
  XmCProcessingDirection = 'ProcessingDirection';
  XmCPromptString = 'PromptString';
  XmCProtocolCallback = 'ProtocolCallback';
  XmCPushButtonEnabled = 'PushButtonEnabled';
  XmCQualifySearchDataProc = 'QualifySearchDataProc';
  XmCRadioAlwaysOne = 'RadioAlwaysOne';
  XmCRadioBehavior = 'RadioBehavior';
  XmCRecomputeSize = 'RecomputeSize';
  XmCRectangles = 'Rectangles';
  XmCRepeatDelay = 'RepeatDelay';
  XmCResizeCallback = 'ResizeCallback';
  XmCResizeHeight = 'ResizeHeight';
  XmCResizePolicy = 'ResizePolicy';
  XmCResizeWidth = 'ResizeWidth';
  XmCRowColumnType = 'RowColumnType';
  XmCRows = 'Rows';
  XmCRubberPositioning = 'RubberPositioning';
  XmCSashHeight = 'SashHeight';
  XmCSashIndent = 'SashIndent';
  XmCSashWidth = 'SashWidth';
  XmCScaleHeight = 'ScaleHeight';
  XmCScaleMultiple = 'ScaleMultiple';
  XmCScaleWidth = 'ScaleWidth';
  XmCScroll = 'Scroll';
  XmCScrollBarDisplayPolicy = 'ScrollBarDisplayPolicy';
  XmCScrollBarPlacement = 'ScrollBarPlacement';
  XmCScrollSide = 'ScrollSide';
  XmCScrolledWindowMarginHeight = 'ScrolledWindowMarginHeight';
  XmCScrolledWindowMarginWidth = 'ScrolledWindowMarginWidth';
  XmCScrollingPolicy = 'ScrollingPolicy';
  XmCSelectColor = 'SelectColor';
  XmCSelectInsensitivePixmap = 'SelectInsensitivePixmap';
  XmCSelectPixmap = 'SelectPixmap';
  XmCSelectThreshold = 'SelectThreshold';
  XmCSelectedItemCount = 'SelectedItemCount';
  XmCSelectedItems = 'SelectedItems';
  XmCSelectionArrayCount = 'SelectionArrayCount';
  XmCSelectionLabelString = 'SelectionLabelString';
  XmCSelectionPolicy = 'SelectionPolicy';
  XmCSeparatorOn = 'SeparatorOn';
  XmCSeparatorType = 'SeparatorType';
  XmCSet = 'Set';
  XmCShadowThickness = 'ShadowThickness';
  XmCShadowType = 'ShadowType';
  XmCShellUnitType = 'ShellUnitType';
  XtCShellUnitType = XmCShellUnitType;
  XmCShowArrows = 'ShowArrows';
  XmCShowAsDefault = 'ShowAsDefault';
  XmCShowSeparator = 'ShowSeparator';
  XmCShowValue = 'ShowValue';
  XmCSimpleCheckBox = 'SimpleCheckBox';
  XmCSimpleMenuBar = 'SimpleMenuBar';
  XmCSimpleOptionMenu = 'SimpleOptionMenu';
  XmCSimplePopupMenu = 'SimplePopupMenu';
  XmCSimplePulldownMenu = 'SimplePulldownMenu';
  XmCSimpleRadioBox = 'SimpleRadioBox';
  XmCSizePolicy = 'SizePolicy';
  XmCSliderSize = 'SliderSize';
  XmCSource = 'Source';
  XmCSourceCursorIcon = 'SourceCursorIcon';
  XmCSourceIsExternal = 'SourceIsExternal';
  XmCSourcePixmapIcon = 'SourcePixmapIcon';
  XmCSourceWidget = 'SourceWidget';
  XmCSourceWindow = 'SourceWindow';
  XmCSpacing = 'Spacing';
  XmCStartTime = 'StartTime';
  XmCStateCursorIcon = 'StateCursorIcon';
  XmCStringDirection = 'StringDirection';
  XmCTearOffModel = 'TearOffModel';
  XmCTextFontList = 'TextFontList';
  XmCTextString = 'TextString';
  XmCTextValue = 'TextValue';
  XmCTitleString = 'TitleString';
  XmCTopCharacter = 'TopCharacter';
  XmCTopItemPosition = 'TopItemPosition';
  XmCTopLevelEnterCallback = 'TopLevelEnterCallback';
  XmCTopLevelLeaveCallback = 'TopLevelLeaveCallback';
  XmCTopShadowColor = 'TopShadowColor';
  XmCTopShadowPixmap = 'TopShadowPixmap';
  XmCTransferProc = 'TransferProc';
  XmCTransferStatus = 'TransferStatus';
  XmCTraversalOn = 'TraversalOn';
  XmCTraversalType = 'TraversalType';
  XmCTreeUpdateProc = 'TreeUpdateProc';
  XmCTroughColor = 'TroughColor';
  XmCUnitType = 'UnitType';
  XmCUnpostBehavior = 'UnpostBehavior';
  XmCUnselectPixmap = 'UnselectPixmap';
  XmCUpdateSliderSize = 'UpdateSliderSize';
  XmCUseAsyncGeometry = 'UseAsyncGeometry';
  XmCUserData = 'UserData';
  XmCValidCursorForeground = 'ValidCursorForeground';
  XmCValueChangedCallback = 'ValueChangedCallback';
  XmCValueWcs = 'ValueWcs';
  XmCVerifyBell = 'VerifyBell';
  XmCVerticalAlignment = 'VerticalAlignment';
  XmCVerticalFontUnit = 'VerticalFontUnit';
  XmCVerticalScrollBar = 'VerticalScrollBar';
  XmCVisibleItemCount = 'VisibleItemCount';
  XmCVisibleWhenOff = 'VisibleWhenOff';
  XmCVisualPolicy = 'VisualPolicy';
  XmCWhichButton = 'WhichButton';
  XmCWordWrap = 'WordWrap';
  XmCWorkWindow = 'WorkWindow';
  XmCXmString = 'XmString';
  XmNaccelerator = 'accelerator';
  XmNacceleratorText = 'acceleratorText';
  XmNactivateCallback = 'activateCallback';
  XmNadjustLast = 'adjustLast';
  XmNadjustMargin = 'adjustMargin';
  XmNalignment = 'alignment';
  XmNallowOverlap = 'allowOverlap';
  XmNallowResize = 'allowResize';
  XmNanimationMask = 'animationMask';
  XmNanimationPixmap = 'animationPixmap';
  XmNanimationPixmapDepth = 'animationPixmapDepth';
  XmNanimationStyle = 'animationStyle';
  XmNapplyCallback = 'applyCallback';
  XmNapplyLabelString = 'applyLabelString';
  XmNarmCallback = 'armCallback';
  XmNarmColor = 'armColor';
  XmNarmPixmap = 'armPixmap';
  XmNarrowDirection = 'arrowDirection';
  XmNattachment = 'attachment';
  XmNaudibleWarning = 'audibleWarning';
  XmNautoShowCursorPosition = 'autoShowCursorPosition';
  XmNautoUnmanage = 'autoUnmanage';
  XmNautomaticSelection = 'automaticSelection';
  XmNavailability = 'availability';
  XmNblendModel = 'blendModel';
  XmNblinkRate = 'blinkRate';
  XmNbottomAttachment = 'bottomAttachment';
  XmNbottomOffset = 'bottomOffset';
  XmNbottomPosition = 'bottomPosition';
  XmNbottomShadowColor = 'bottomShadowColor';
  XmNbottomShadowPixmap = 'bottomShadowPixmap';
  XmNbottomWidget = 'bottomWidget';
  XmNbrowseSelectionCallback = 'browseSelectionCallback';
  XmNbuttonAcceleratorText = 'buttonAcceleratorText';
  XmNbuttonAccelerators = 'buttonAccelerators';
  XmNbuttonCount = 'buttonCount';
  XmNbuttonFontList = 'buttonFontList';
  XmNbuttonMnemonicCharSets = 'buttonMnemonicCharSets';
  XmNbuttonMnemonics = 'buttonMnemonics';
  XmNbuttonSet = 'buttonSet';
  XmNbuttonType = 'buttonType';
  XmNbuttons = 'buttons';
  XmNcancelButton = 'cancelButton';
  XmNcancelCallback = 'cancelCallback';
  XmNcancelLabelString = 'cancelLabelString';
  XmNcascadePixmap = 'cascadePixmap';
  XmNcascadingCallback = 'cascadingCallback';
  XmNchildHorizontalAlignment = 'childHorizontalAlignment';
  XmNchildHorizontalSpacing = 'childHorizontalSpacing';
  XmNchildPlacement = 'childPlacement';
  XmNchildPosition = 'childPosition';
  XmNchildType = 'childType';
  XmNchildVerticalAlignment = 'childVerticalAlignment';
  XmNclientData = 'clientData';
  XmNclipWindow = 'clipWindow';
  XmNcolumns = 'columns';
  XmNcommand = 'command';
  XmNcommandChangedCallback = 'commandChangedCallback';
  XmNcommandEnteredCallback = 'commandEnteredCallback';
  XmNcommandWindow = 'commandWindow';
  XmNcommandWindowLocation = 'commandWindowLocation';
  XmNconvertProc = 'convertProc';
  XmNcursorBackground = 'cursorBackground';
  XmNcursorForeground = 'cursorForeground';
  XmNcursorPosition = 'cursorPosition';
  XmNcursorPositionVisible = 'cursorPositionVisible';
  XmNdarkThreshold = 'darkThreshold';
  XmNdecimalPoints = 'decimalPoints';
  XmNdecrementCallback = 'decrementCallback';
  XmNdefaultActionCallback = 'defaultActionCallback';
  XmNdefaultButton = 'defaultButton';
  XmNdefaultButtonShadowThickness = 'defaultButtonShadowThickness';
  XmNdefaultButtonType = 'defaultButtonType';
  XmNdefaultCopyCursorIcon = 'defaultCopyCursorIcon';
  XmNdefaultFontList = 'defaultFontList';
  XmNdefaultInvalidCursorIcon = 'defaultInvalidCursorIcon';
  XmNdefaultLinkCursorIcon = 'defaultLinkCursorIcon';
  XmNdefaultMoveCursorIcon = 'defaultMoveCursorIcon';
  XmNdefaultNoneCursorIcon = 'defaultNoneCursorIcon';
  XmNdefaultPosition = 'defaultPosition';
  XmNdefaultSourceCursorIcon = 'defaultSourceCursorIcon';
  XmNdefaultValidCursorIcon = 'defaultValidCursorIcon';
  XmNdeleteResponse = 'deleteResponse';
  XmNdesktopParent = 'desktopParent';
  XmNdialogStyle = 'dialogStyle';
  XmNdialogTitle = 'dialogTitle';
  XmNdialogType = 'dialogType';
  XmNdirListItemCount = 'dirListItemCount';
  XmNdirListItems = 'dirListItems';
  XmNdirListLabelString = 'dirListLabelString';
  XmNdirMask = 'dirMask';
  XmNdirSearchProc = 'dirSearchProc';
  XmNdirSpec = 'dirSpec';
  XmNdirectory = 'directory';
  XmNdirectoryValid = 'directoryValid';
  XmNdisarmCallback = 'disarmCallback';
  XmNdoubleClickInterval = 'doubleClickInterval';
  XmNdragCallback = 'dragCallback';
  XmNdragContextClass = 'dragContextClass';
  XmNdragDropFinishCallback = 'dragDropFinishCallback';
  XmNdragIconClass = 'dragIconClass';
  XmNdragInitiatorProtocolStyle = 'dragInitiatorProtocolStyle';
  XmNdragMotionCallback = 'dragMotionCallback';
  XmNdragOperations = 'dragOperations';
  XmNdragOverMode = 'dragOverMode';
  XmNdragProc = 'dragProc';
  XmNdragReceiverProtocolStyle = 'dragReceiverProtocolStyle';
  XmNdropFinishCallback = 'dropFinishCallback';
  XmNdropProc = 'dropProc';
  XmNdropRectangles = 'dropRectangles';
  XmNdropSiteActivity = 'dropSiteActivity';
  XmNdropSiteEnterCallback = 'dropSiteEnterCallback';
  XmNdropSiteLeaveCallback = 'dropSiteLeaveCallback';
  XmNdropSiteManagerClass = 'dropSiteManagerClass';
  XmNdropSiteOperations = 'dropSiteOperations';
  XmNdropSiteType = 'dropSiteType';
  XmNdropStartCallback = 'dropStartCallback';
  XmNdropTransferClass = 'dropTransferClass';
  XmNdropTransfers = 'dropTransfers';
  XmNeditMode = 'editMode';
  XmNeditable = 'editable';
  XmNentryAlignment = 'entryAlignment';
  XmNentryBorder = 'entryBorder';
  XmNentryCallback = 'entryCallback';
  XmNentryClass = 'entryClass';
  XmNentryVerticalAlignment = 'entryVerticalAlignment';
  XmNexportTargets = 'exportTargets';
  XmNexposeCallback = 'exposeCallback';
  XmNextendedSelectionCallback = 'extendedSelectionCallback';
  XmNextensionType = 'extensionType';
  XmNfileListItemCount = 'fileListItemCount';
  XmNfileListItems = 'fileListItems';
  XmNfileListLabelString = 'fileListLabelString';
  XmNfileSearchProc = 'fileSearchProc';
  XmNfileTypeMask = 'fileTypeMask';
  XmNfillOnArm = 'fillOnArm';
  XmNfillOnSelect = 'fillOnSelect';
  XmNfilterLabelString = 'filterLabelString';
  XmNfocusCallback = 'focusCallback';
  XmNfocusMovedCallback = 'focusMovedCallback';
  XmNfocusPolicyChanged = 'focusPolicyChanged';
  XmNfontList = 'fontList';
  XmNforegroundThreshold = 'foregroundThreshold';
  XmNfractionBase = 'fractionBase';
  XmNgainPrimaryCallback = 'gainPrimaryCallback';
  XmNhelpCallback = 'helpCallback';
  XmNhelpLabelString = 'helpLabelString';
  XmNhighlightColor = 'highlightColor';
  XmNhighlightOnEnter = 'highlightOnEnter';
  XmNhighlightPixmap = 'highlightPixmap';
  XmNhighlightThickness = 'highlightThickness';
  XmNhistoryItemCount = 'historyItemCount';
  XmNhistoryItems = 'historyItems';
  XmNhistoryMaxItems = 'historyMaxItems';
  XmNhistoryVisibleItemCount = 'historyVisibleItemCount';
  XmNhorizontalFontUnit = 'horizontalFontUnit';
  XmNhorizontalScrollBar = 'horizontalScrollBar';
  XmNhorizontalSpacing = 'horizontalSpacing';
  XmNhotX = 'hotX';
  XmNhotY = 'hotY';
  XmNiccHandle = 'iccHandle';
  XmNimportTargets = 'importTargets';
  XmNincrement = 'increment';
  XmNincrementCallback = 'incrementCallback';
  XmNincremental = 'incremental';
  XmNindicatorOn = 'indicatorOn';
  XmNindicatorSize = 'indicatorSize';
  XmNindicatorType = 'indicatorType';
  XmNinitialDelay = 'initialDelay';
  XmNinitialFocus = 'initialFocus';
  XmNinputCallback = 'inputCallback';
  XmNinputCreate = 'inputCreate';
  XmNinputMethod = 'inputMethod';
  XmNinvalidCursorForeground = 'invalidCursorForeground';
  XmNisAligned = 'isAligned';
  XmNisHomogeneous = 'isHomogeneous';
  XmNitemCount = 'itemCount';
  XmNitems = 'items';
  XmNkeyboardFocusPolicy = 'keyboardFocusPolicy';
  XtNkeyboardFocusPolicy = XmNkeyboardFocusPolicy;
  XmNlabelFontList = 'labelFontList';
  XmNlabelInsensitivePixmap = 'labelInsensitivePixmap';
  XmNlabelPixmap = 'labelPixmap';
  XmNlabelString = 'labelString';
  XmNlabelType = 'labelType';
  XmNleftAttachment = 'leftAttachment';
  XmNleftOffset = 'leftOffset';
  XmNleftPosition = 'leftPosition';
  XmNleftWidget = 'leftWidget';
  XmNlightThreshold = 'lightThreshold';
  XmNlineSpace = 'lineSpace';
  XmNlistItemCount = 'listItemCount';
  XmNlistItems = 'listItems';
  XmNlistLabelString = 'listLabelString';
  XmNlistMarginHeight = 'listMarginHeight';
  XmNlistMarginWidth = 'listMarginWidth';
  XmNlistSizePolicy = 'listSizePolicy';
  XmNlistSpacing = 'listSpacing';
  XmNlistUpdated = 'listUpdated';
  XmNlistVisibleItemCount = 'listVisibleItemCount';
  XmNlogicalParent = 'logicalParent';
  XmNlosePrimaryCallback = 'losePrimaryCallback';
  XmNlosingFocusCallback = 'losingFocusCallback';
  XmNmainWindowMarginHeight = 'mainWindowMarginHeight';
  XmNmainWindowMarginWidth = 'mainWindowMarginWidth';
  XmNmapCallback = 'mapCallback';
  XmNmappingDelay = 'mappingDelay';
  XmNmargin = 'margin';
  XmNmarginBottom = 'marginBottom';
  XmNmarginHeight = 'marginHeight';
  XmNmarginLeft = 'marginLeft';
  XmNmarginRight = 'marginRight';
  XmNmarginTop = 'marginTop';
  XmNmarginWidth = 'marginWidth';
  XmNmask = 'mask';
  XmNmaxLength = 'maxLength';
  XmNmaximum = 'maximum';
  XmNmenuAccelerator = 'menuAccelerator';
  XmNmenuBar = 'menuBar';
  XmNmenuCursor = 'menuCursor';
  XmNmenuHelpWidget = 'menuHelpWidget';
  XmNmenuHistory = 'menuHistory';
  XmNmenuPost = 'menuPost';
  XmNmessageAlignment = 'messageAlignment';
  XmNmessageProc = 'messageProc';
  XmNmessageString = 'messageString';
  XmNmessageWindow = 'messageWindow';
  XmNminimizeButtons = 'minimizeButtons';
  XmNminimum = 'minimum';
  XmNmnemonic = 'mnemonic';
  XmNmnemonicCharSet = 'mnemonicCharSet';
  XmNmodifyVerifyCallback = 'modifyVerifyCallback';
  XmNmodifyVerifyCallbackWcs = 'modifyVerifyCallbackWcs';
  XmNmotionVerifyCallback = 'motionVerifyCallback';
  XmNmoveOpaque = 'moveOpaque';
  XmNmultiClick = 'multiClick';
  XmNmultipleSelectionCallback = 'multipleSelectionCallback';
  XmNmustMatch = 'mustMatch';
  XmNmwmDecorations = 'mwmDecorations';
  XmNmwmFunctions = 'mwmFunctions';
  XmNmwmInputMode = 'mwmInputMode';
  XmNmwmMenu = 'mwmMenu';
  XmNmwmMessages = 'mwmMessages';
  XmNnavigationType = 'navigationType';
  XmNneedsMotion = 'needsMotion';
  XmNnoMatchCallback = 'noMatchCallback';
  XmNnoMatchString = 'noMatchString';
  XmNnoResize = 'noResize';
  XmNnoneCursorForeground = 'noneCursorForeground';
  XmNnotifyProc = 'notifyProc';
  XmNnumColumns = 'numColumns';
  XmNnumDropRectangles = 'numDropRectangles';
  XmNnumDropTransfers = 'numDropTransfers';
  XmNnumExportTargets = 'numExportTargets';
  XmNnumImportTargets = 'numImportTargets';
  XmNnumRectangles = 'numRectangles';
  XmNoffsetX = 'offsetX';
  XmNoffsetY = 'offsetY';
  XmNokCallback = 'okCallback';
  XmNokLabelString = 'okLabelString';
  XmNoperationChangedCallback = 'operationChangedCallback';
  XmNoperationCursorIcon = 'operationCursorIcon';
  XmNoptionLabel = 'optionLabel';
  XmNoptionMnemonic = 'optionMnemonic';
  XmNoutputCreate = 'outputCreate';
  XmNpacking = 'packing';
  XmNpageDecrementCallback = 'pageDecrementCallback';
  XmNpageIncrement = 'pageIncrement';
  XmNpageIncrementCallback = 'pageIncrementCallback';
  XmNpaneMaximum = 'paneMaximum';
  XmNpaneMinimum = 'paneMinimum';
  XmNpattern = 'pattern';
  XmNpendingDelete = 'pendingDelete';
  XmNpopupEnabled = 'popupEnabled';
  XmNpositionIndex = 'positionIndex';
  XmNpostFromButton = 'postFromButton';
  XmNpostFromCount = 'postFromCount';
  XmNpostFromList = 'postFromList';
  XmNpreeditType = 'preeditType';
  XmNprocessingDirection = 'processingDirection';
  XmNpromptString = 'promptString';
  XmNprotocolCallback = 'protocolCallback';
  XmNpushButtonEnabled = 'pushButtonEnabled';
  XmNqualifySearchDataProc = 'qualifySearchDataProc';
  XmNradioAlwaysOne = 'radioAlwaysOne';
  XmNradioBehavior = 'radioBehavior';
  XmNrealizeCallback = 'realizeCallback';
  XmNrecomputeSize = 'recomputeSize';
  XmNrectangles = 'rectangles';
  XmNrefigureMode = 'refigureMode';
  XmNrepeatDelay = 'repeatDelay';
  XmNresizable = 'resizable';
  XmNresizeCallback = 'resizeCallback';
  XmNresizeHeight = 'resizeHeight';
  XmNresizePolicy = 'resizePolicy';
  XmNresizeWidth = 'resizeWidth';
  XmNrightAttachment = 'rightAttachment';
  XmNrightOffset = 'rightOffset';
  XmNrightPosition = 'rightPosition';
  XmNrightWidget = 'rightWidget';
  XmNrowColumnType = 'rowColumnType';
  XmNrows = 'rows';
  XmNrubberPositioning = 'rubberPositioning';
  XmNsashHeight = 'sashHeight';
  XmNsashIndent = 'sashIndent';
  XmNsashShadowThickness = 'sashShadowThickness';
  XmNsashWidth = 'sashWidth';
  XmNscaleHeight = 'scaleHeight';
  XmNscaleMultiple = 'scaleMultiple';
  XmNscaleWidth = 'scaleWidth';
  XmNscrollBarDisplayPolicy = 'scrollBarDisplayPolicy';
  XmNscrollBarPlacement = 'scrollBarPlacement';
  XmNscrollHorizontal = 'scrollHorizontal';
  XmNscrollLeftSide = 'scrollLeftSide';
  XmNscrollTopSide = 'scrollTopSide';
  XmNscrollVertical = 'scrollVertical';
  XmNscrolledWindowMarginHeight = 'scrolledWindowMarginHeight';
  XmNscrolledWindowMarginWidth = 'scrolledWindowMarginWidth';
  XmNscrollingPolicy = 'scrollingPolicy';
  XmNselectColor = 'selectColor';
  XmNselectInsensitivePixmap = 'selectInsensitivePixmap';
  XmNselectPixmap = 'selectPixmap';
  XmNselectThreshold = 'selectThreshold';
  XmNselectedItemCount = 'selectedItemCount';
  XmNselectedItems = 'selectedItems';
  XmNselectionArrayCount = 'selectionArrayCount';
  XmNselectionLabelString = 'selectionLabelString';
  XmNselectionPolicy = 'selectionPolicy';
  XmNseparatorOn = 'separatorOn';
  XmNseparatorType = 'separatorType';
  XmNset = 'set';
  XmNshadow = 'shadow';
  XmNshadowThickness = 'shadowThickness';
  XmNshadowType = 'shadowType';
  XmNshellUnitType = 'shellUnitType';
  XtNshellUnitType = XmNshellUnitType;
  XmNshowArrows = 'showArrows';
  XmNshowAsDefault = 'showAsDefault';
  XmNshowSeparator = 'showSeparator';
  XmNshowValue = 'showValue';
  XmNsimpleCallback = 'simpleCallback';
  XmNsingleSelectionCallback = 'singleSelectionCallback';
  XmNsizePolicy = 'sizePolicy';
  XmNskipAdjust = 'skipAdjust';
  XmNsliderSize = 'sliderSize';
  XmNsource = 'source';
  XmNsourceCursorIcon = 'sourceCursorIcon';
  XmNsourceIsExternal = 'sourceIsExternal';
  XmNsourcePixmapIcon = 'sourcePixmapIcon';
  XmNsourceWidget = 'sourceWidget';
  XmNsourceWindow = 'sourceWindow';
  XmNspacing = 'spacing';
  XmNspotLocation = 'spotLocation';
  XmNstartTime = 'startTime';
  XmNstateCursorIcon = 'stateCursorIcon';
  XmNstringDirection = 'stringDirection';
  XmNsubMenuId = 'subMenuId';
  XmNsymbolPixmap = 'symbolPixmap';
  XmNtearOffMenuActivateCallback = 'tearOffMenuActivateCallback';
  XmNtearOffMenuDeactivateCallback = 'tearOffMenuDeactivateCallback';
  XmNtearOffModel = 'tearOffModel';
  XmNtextAccelerators = 'textAccelerators';
  XmNtextColumns = 'textColumns';
  XmNtextFontList = 'textFontList';
  XmNtextString = 'textString';
  XmNtextTranslations = 'textTranslations';
  XmNtextValue = 'textValue';
  XmNtitleString = 'titleString';
  XmNtoBottomCallback = 'toBottomCallback';
  XmNtoPositionCallback = 'toPositionCallback';
  XmNtoTopCallback = 'toTopCallback';
  XmNtopAttachment = 'topAttachment';
  XmNtopCharacter = 'topCharacter';
  XmNtopItemPosition = 'topItemPosition';
  XmNtopLevelEnterCallback = 'topLevelEnterCallback';
  XmNtopLevelLeaveCallback = 'topLevelLeaveCallback';
  XmNtopOffset = 'topOffset';
  XmNtopPosition = 'topPosition';
  XmNtopShadowColor = 'topShadowColor';
  XmNtopShadowPixmap = 'topShadowPixmap';
  XmNtopWidget = 'topWidget';
  XmNtransferProc = 'transferProc';
  XmNtransferStatus = 'transferStatus';
  XmNtraversalCallback = 'traversalCallback';
  XmNtraversalOn = 'traversalOn';
  XmNtraversalType = 'traversalType';
  XmNtraverseObscuredCallback = 'traverseObscuredCallback';
  XmNtreeUpdateProc = 'treeUpdateProc';
  XmNtroughColor = 'troughColor';
  XmNunitType = 'unitType';
  XmNunmapCallback = 'unmapCallback';
  XmNunpostBehavior = 'unpostBehavior';
  XmNunselectPixmap = 'unselectPixmap';
  XmNupdateSliderSize = 'updateSliderSize';
  XmNuseAsyncGeometry = 'useAsyncGeometry';
  XmNuserData = 'userData';
  XmNvalidCursorForeground = 'validCursorForeground';
  XmNvalueChangedCallback = 'valueChangedCallback';
  XmNvalueWcs = 'valueWcs';
  XmNverifyBell = 'verifyBell';
  XmNverticalFontUnit = 'verticalFontUnit';
  XmNverticalScrollBar = 'verticalScrollBar';
  XmNverticalSpacing = 'verticalSpacing';
  XmNvisibleItemCount = 'visibleItemCount';
  XmNvisibleWhenOff = 'visibleWhenOff';
  XmNvisualPolicy = 'visualPolicy';
  XmNwhichButton = 'whichButton';
  XmNwordWrap = 'wordWrap';
  XmNworkWindow = 'workWindow';
  XmRAlignment = 'Alignment';
  XmRAnimationMask = 'AnimationMask';
  XmRAnimationPixmap = 'AnimationPixmap';
  XmRAnimationStyle = 'AnimationStyle';
  XmRArrowDirection = 'ArrowDirection';
  XmRAtomList = 'AtomList';
  XmRAttachment = 'Attachment';
  XmRAudibleWarning = 'AudibleWarning';
  XmRAvailability = 'Availability';
  XmRBackgroundPixmap = 'BackgroundPixmap';
  XmRBlendModel = 'BlendModel';
  XmRBooleanDimension = 'BooleanDimension';
  XmRBottomShadowPixmap = 'BottomShadowPixmap';
  XmRPrimBottomShadowPixmap = XmRBottomShadowPixmap;
  XmRButtonType = 'ButtonType';
  XmRCallbackProc = 'CallbackProc';
  XmRChar = 'Char';
  XmRCharSetTable = 'CharSetTable';
  XmRChildHorizontalAlignment = 'ChildHorizontalAlignment';
  XmRChildPlacement = 'ChildPlacement';
  XmRChildType = 'ChildType';
  XmRChildVerticalAlignment = 'ChildVerticalAlignment';
  XmRCommandWindowLocation = 'CommandWindowLocation';
  XmRCompoundText = 'CompoundText';
  XmRDefaultButtonType = 'DefaultButtonType';
  XmRDeleteResponse = 'DeleteResponse';
  XmRDialogStyle = 'DialogStyle';
  XmRDialogType = 'DialogType';
  XmRDoubleClickInterval = 'DoubleClickInterval';
  XmRDragInitiatorProtocolStyle = 'DragInitiatorProtocolStyle';
  XmRDragReceiverProtocolStyle = 'DragReceiverProtocolStyle';
  XmRDropSiteActivity = 'DropSiteActivity';
  XmRDropSiteOperations = 'DropSiteOperations';
  XmRDropSiteType = 'DropSiteType';
  XmRDropTransfers = 'DropTransfers';
  XmRExtensionType = 'ExtensionType';
  XmRFileTypeMask = 'FileTypeMask';
  XmRFontList = 'FontList';
  XmRGadgetPixmap = 'GadgetPixmap';
  XmRHighlightPixmap = 'HighlightPixmap';
  XmRPrimHighlightPixmap = XmRHighlightPixmap;
  XmRHorizontalDimension = 'HorizontalDimension';
  XmRHorizontalInt = 'HorizontalInt';
  XmRHorizontalPosition = 'HorizontalPosition';
  XmRIconAttachment = 'IconAttachment';
  XmRImportTargets = 'ImportTargets';
  XmRIndicatorType = 'IndicatorType';
  XmRItemCount = 'ItemCount';
  XmRItems = 'Items';
  XmRKeySym = 'KeySym';
  XmRKeySymTable = 'KeySymTable';
  XmRKeyboardFocusPolicy = 'KeyboardFocusPolicy';
  XtRKeyboardFocusPolicy = XmRKeyboardFocusPolicy;
  XmRLabelType = 'LabelType';
  XmRListMarginHeight = 'ListMarginHeight';
  XmRListMarginWidth = 'ListMarginWidth';
  XmRListSizePolicy = 'ListSizePolicy';
  XmRListSpacing = 'ListSpacing';
  XmRManBottomShadowPixmap = 'ManBottomShadowPixmap';
  XmRManForegroundPixmap = 'ManForegroundPixmap';
  XmRManHighlightPixmap = 'ManHighlightPixmap';
  XmRManTopShadowPixmap = 'ManTopShadowPixmap';
  XmRMenuWidget = 'MenuWidget';
  XmRMnemonic = 'Mnemonic';
  XmRMultiClick = 'MultiClick';
  XmRNavigationType = 'NavigationType';
  XmRPacking = 'Packing';
  XmRPrimForegroundPixmap = 'PrimForegroundPixmap';
  XmRProc = 'Proc';
  XmRProcessingDirection = 'ProcessingDirection';
  XmRRectangleList = 'RectangleList';
  XmRResizePolicy = 'ResizePolicy';
  XmRRowColumnType = 'RowColumnType';
  XmRScrollBarDisplayPolicy = 'ScrollBarDisplayPolicy';
  XmRScrollBarPlacement = 'ScrollBarPlacement';
  XmRScrollingPolicy = 'ScrollingPolicy';
  XmRSelectedItemCount = 'SelectedItemCount';
  XmRSelectedItems = 'SelectedItems';
  XmRSelectionPolicy = 'SelectionPolicy';
  XmRSelectionType = 'SelectionType';
  XmRSeparatorType = 'SeparatorType';
  XmRShadowType = 'ShadowType';
  XmRShellHorizDim = 'ShellHorizDim';
  XmRShellHorizPos = 'ShellHorizPos';
  XmRShellUnitType = 'ShellUnitType';
  XmRShellVertDim = 'ShellVertDim';
  XmRShellVertPos = 'ShellVertPos';
  XmRSizePolicy = 'SizePolicy';
  XmRStringDirection = 'StringDirection';
  XmRTearOffModel = 'TearOffModel';
  XmRTopItemPosition = 'TopItemPosition';
  XmRTopShadowPixmap = 'TopShadowPixmap';
  XmRPrimTopShadowPixmap = XmRTopShadowPixmap;
  XmRTransferStatus = 'TransferStatus';
  XmRTraversalType = 'TraversalType';
  XmRUnitType = 'UnitType';
  XmRUnpostBehavior = 'UnpostBehavior';
  XmRValueWcs = 'ValueWcs';
  XmRVerticalAlignment = 'VerticalAlignment';
  XmRVerticalDimension = 'VerticalDimension';
  XmRVerticalInt = 'VerticalInt';
  XmRVerticalPosition = 'VerticalPosition';
  XmRVirtualBinding = 'VirtualBinding';
  XmRVisibleItemCount = 'VisibleItemCount';
  XmRVisualPolicy = 'VisualPolicy';
  XmRWhichButton = 'WhichButton';
  XmRXmBackgroundPixmap = 'XmBackgroundPixmap';
  XmRXmString = 'XmString';
  XmRXmStringCharSet = 'XmStringCharSet';
  XmRXmStringTable = 'XmStringTable';
  XmVosfActivate = 'osfActivate';
  XmVosfAddMode = 'osfAddMode';
  XmVosfBackSpace = 'osfBackSpace';
  XmVosfBeginLine = 'osfBeginLine';
  XmVosfCancel = 'osfCancel';
  XmVosfClear = 'osfClear';
  XmVosfCopy = 'osfCopy';
  XmVosfCut = 'osfCut';
  XmVosfDelete = 'osfDelete';
  XmVosfDown = 'osfDown';
  XmVosfEndLine = 'osfEndLine';
  XmVosfHelp = 'osfHelp';
  XmVosfInsert = 'osfInsert';
  XmVosfLeft = 'osfLeft';
  XmVosfMenu = 'osfMenu';
  XmVosfMenuBar = 'osfMenuBar';
  XmVosfPageDown = 'osfPageDown';
  XmVosfPageLeft = 'osfPageLeft';
  XmVosfPageRight = 'osfPageRight';
  XmVosfPageUp = 'osfPageUp';
  XmVosfPaste = 'osfPaste';
  XmVosfPrimaryPaste = 'osfPrimaryPaste';
  XmVosfQuickPaste = 'osfQuickPaste';
  XmVosfRight = 'osfRight';
  XmVosfSelect = 'osfSelect';
  XmVosfUndo = 'osfUndo';
  XmVosfUp = 'osfUp';
  XmSFONTLIST_DEFAULT_TAG_STRING = 'FONTLIST_DEFAULT_TAG_STRING';
  XmFONTLIST_DEFAULT_TAG = XmSFONTLIST_DEFAULT_TAG_STRING;
  XmSXmFONTLIST_DEFAULT_TAG_STRING = 'XmFONTLIST_DEFAULT_TAG_STRING';
  XmFONTLIST_DEFAULT_TAG_STRING = XmSXmFONTLIST_DEFAULT_TAG_STRING;
  XmSTRING_ISO8859_1 = 'ISO8859-1';
  XmSTRING_OS_CHARSET = XmSTRING_ISO8859_1;
  XmFALLBACK_CHARSET = XmSTRING_ISO8859_1;
  XmVaCASCADEBUTTON = 'cascadeButton';
  XmVaCHECKBUTTON = 'checkButton';
  XmVaDOUBLE_SEPARATOR = 'doubleSeparator';
  XmVaPUSHBUTTON = 'pushButton';
  XmVaRADIOBUTTON = 'radioButton';
  XmVaSEPARATOR = 'separator';
  XmVaSINGLE_SEPARATOR = 'singleSeparator';
  XmVaTOGGLEBUTTON = 'checkButton';

(* ------------------------------------------------ *)
(*                     Xm/Xm.h                      *)
(* ------------------------------------------------ *)

(*
 * Motif Release 1.2.4
 *)

(************************************<+>*************************************
 ****************************************************************************
 **
 **   File:        Xm.h
 **
 **   Description: This include file contains the class and instance record
 **                definitions for all meta classes.  It also contains externs
 **                for internally shared functions and defines for internally
 **                shared values.
 **
 ****************************************************************************
 ************************************<+>*************************************)


  XmVERSION = 1;
  XmREVISION = 2;
  XmUPDATE_LEVEL = 4;
  XmVersion = (XmVERSION*1000)+XmREVISION;
  XmVERSION_STRING = '@(#)OSF/Motif Version 1.2.4';

VAR
  xmUseVersion: SYSTEM.int;

(*  define used to denote an unspecified pixmap   *)

CONST
  XmUNSPECIFIED_PIXMAP = 2;

(*******************
 *
 * Defines for resources to be defaulted by vendors.
 * String are initialized in Xmos.c
 *
 *******************)

  XmDEFAULT_DARK_THRESHOLD = 15;
  XmDEFAULT_LIGHT_THRESHOLD = 77;
  XmDEFAULT_FOREGROUND_THRESHOLD = 35;

VAR
  _XmSDEFAULT_FONT: Xt.String;         (*  In Xmos.c  *)
  _XmSDEFAULT_BACKGROUND: Xt.String;   (*  In Xmos.c  *)

(****************
 *
 * XmString structure defines. These must be here (at the start of the file)
 * becaused they are used later on.
 *
 ****************)

CONST
  XmFONT_IS_FONT = 0;
  XmFONT_IS_FONTSET = 1;

TYPE
  XmFontType = SYSTEM.int;

CONST
  XmSTRING_DIRECTION_L_TO_R = 0;
  XmSTRING_DIRECTION_R_TO_L = 1;
  XmSTRING_DIRECTION_DEFAULT = 255;

TYPE
  _XmStringDirection = SYSTEM.int;

  XmStringDirection = SHORTCARD;

  XmStringDirectionTable = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF SHORTCARD;

  XmString = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF SHORTCARD;     (* opaque to outside *)

  XmStringTable = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF XmString; (* opaque to outside *)

  XmStringCharSet = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF CHAR;   (*  Null term string *)

  XmStringCharSetTable = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF XmStringCharSet;

  XmStringComponentType = SHORTCARD;   (*  component tags  *)

  _XmFontListRec = RECORD
    (* Declaration without definition *)
  END;

  XmFontListEntry = POINTER TO _XmFontListRec;   (*  opaque to outside  *)

  XmFontList = POINTER TO _XmFontListRec;   (*  opaque to outside  *)

  __XmStringContextRec = RECORD
    (* Declaration without definition *)
  END;

  _XmStringContext = POINTER TO __XmStringContextRec;   (*  opaque to outside  *)

  __XmStringRec = RECORD
    (* Declaration without definition *)
  END;

  _XmString = POINTER TO __XmStringRec;(*  opaque to outside  *)

  _XmtStringContextRec = RECORD
    (* Declaration without definition *)
  END;

  XmStringContext = POINTER TO _XmtStringContextRec;   (*  opaque to outside  *)

  _XmFontListContextRec = RECORD
    (* Declaration without definition *)
  END;

  XmFontContext = POINTER TO _XmFontListContextRec;   (*  opaque to outside  *)

CONST
  XmSTRING_COMPONENT_UNKNOWN = 0;
  XmSTRING_COMPONENT_CHARSET = 1;
  XmSTRING_COMPONENT_TEXT = 2;
  XmSTRING_COMPONENT_DIRECTION = 3;
  XmSTRING_COMPONENT_SEPARATOR = 4;
  XmSTRING_COMPONENT_LOCALE_TEXT = 5;
  (*  6-125 reserved  *)
  XmSTRING_COMPONENT_END = 126;
  XmSTRING_COMPONENT_USER_BEGIN = 128;
  (*  128-255 are user tags  *)
  XmSTRING_COMPONENT_USER_END = 255;

TYPE
  _XmStringComponent = SYSTEM.int;

(************************************************************************
 *
 *  Base widget class and record definitions.
 *	Included are the definitions for XmPrimitive, XmManager,
 *      and XmGadget.
 *
 ************************************************************************)

(*   Primitive widget class and record definitions   *)

VAR
  xmPrimitiveWidgetClass: Xt.WidgetClass;

TYPE
  XmPrimitiveWidgetClass = POINTER TO _XmPrimitiveClassRec;

  XmPrimitiveWidget = POINTER TO _XmPrimitiveRec;

(*   Gadget widget class and record definitions   *)

VAR
  xmGadgetClass: Xt.WidgetClass;

TYPE
  XmGadgetClass = POINTER TO _XmGadgetClassRec;

  XmGadget = POINTER TO _XmGadgetRec;

(*   Manager widger class and record definitions   *)

VAR
  xmManagerWidgetClass: Xt.WidgetClass;

TYPE
  XmManagerWidgetClass = POINTER TO _XmManagerClassRec;

  XmManagerWidget = POINTER TO _XmManagerRec;

(************************************************************************
 *  Primitive Resources and define values
 ************************************************************************)

(*  size policy values   *)

CONST
  XmCHANGE_ALL = 0;
  XmCHANGE_NONE = 1;
  XmCHANGE_WIDTH = 2;
  XmCHANGE_HEIGHT = 3;

TYPE
  _XmSizePolicy = SYSTEM.int;

(*   unit type values   *)

CONST
  XmPIXELS = 0;
  Xm100TH_MILLIMETERS = 1;
  Xm1000TH_INCHES = 2;
  Xm100TH_POINTS = 3;
  Xm100TH_FONT_UNITS = 4;

TYPE
  _XmUnitType = SYSTEM.int;

(*  DeleteResponse values  *)

CONST
  XmDESTROY = 0;
  XmUNMAP = 1;
  XmDO_NOTHING = 2;

TYPE
  _XmDeleteResponse = SYSTEM.int;

CONST
  XmEXPLICIT = 0;
  XmPOINTER = 1;

TYPE
  _XmExplicitOrPointer = SYSTEM.int;

(************************************************************************
 *  Navigation defines
 ************************************************************************)

CONST
  XmNONE = 0;
  XmTAB_GROUP = 1;
  XmSTICKY_TAB_GROUP = 2;
  XmEXCLUSIVE_TAB_GROUP = 3;

TYPE
  _XmNavigationDefines = SYSTEM.int;

CONST
  XmDYNAMIC_DEFAULT_TAB_GROUP = 255;

(************************************************************************
 * Audible warning
 ************************************************************************)

(* XmNONE = 0 *)
  XmBELL = 1;

TYPE
  _XmAudibleWarning = SYSTEM.int;

(************************************************************************
 *  Menu defines
 ************************************************************************)

CONST
  XmNO_ORIENTATION = 0;
  XmVERTICAL = 1;
  XmHORIZONTAL = 2;

TYPE
  _XmMenuDefines = SYSTEM.int;

CONST
  XmWORK_AREA = 0;
  XmMENU_BAR = 1;
  XmMENU_PULLDOWN = 2;
  XmMENU_POPUP = 3;
  XmMENU_OPTION = 4;

TYPE
  _XmMenuGeomtry = SYSTEM.int;

CONST
  XmNO_PACKING = 0;
  XmPACK_TIGHT = 1;
  XmPACK_COLUMN = 2;
  XmPACK_NONE = 3;

TYPE
  _XmMenuPacking = SYSTEM.int;

CONST
(* XmALIGNMENT_BASELINE_TOP = 0 *)
(* XmALIGNMENT_CENTER = 1 *)
(* XmALIGNMENT_BASELINE_BOTTOM = 2 *)
  XmALIGNMENT_CONTENTS_TOP = 3;
  XmALIGNMENT_CONTENTS_BOTTOM = 4;

TYPE
  _XmMenuAlignment = SYSTEM.int;

CONST
  XmTEAR_OFF_ENABLED = 0;
  XmTEAR_OFF_DISABLED = 1;

TYPE
  _XmMenuTearOffPolicy = SYSTEM.int;

CONST
  XmUNPOST = 0;
  XmUNPOST_AND_REPLAY = 1;

TYPE
  _XmMenuPostPolicy = SYSTEM.int;

CONST
  XmLAST_POSITION = -1;
  XmFIRST_POSITION = 0;

TYPE
  _XmMenuPosition = SYSTEM.int;

(************************************************************************
 *  Label/Frame defines
 ************************************************************************)

CONST
  XmALIGNMENT_BEGINNING = 0;
  XmALIGNMENT_CENTER = 1;
  XmALIGNMENT_END = 2;

TYPE
  _XmLabelAlignment = SYSTEM.int;

CONST
  XmALIGNMENT_BASELINE_TOP = 0;
(*  XmALIGNMENT_CENTER = 1;  *)
  XmALIGNMENT_BASELINE_BOTTOM = 2;
  XmALIGNMENT_WIDGET_TOP = 3;
  XmALIGNMENT_WIDGET_BOTTOM = 4;

TYPE
  _XmFrameAlignment = SYSTEM.int;

(************************************************************************
 *  Frame defines
 ************************************************************************)

CONST
  XmFRAME_GENERIC_CHILD = 0;
  XmFRAME_WORKAREA_CHILD = 1;
  XmFRAME_TITLE_CHILD = 2;

TYPE
  _XmFrameDefs = SYSTEM.int;

(************************************************************************
 *  ToggleButton  defines
 ************************************************************************)

CONST
  XmN_OF_MANY = 1;
  XmONE_OF_MANY = 2;

TYPE
  _XmTButtonDefs = SYSTEM.int;

(************************************************************************
 *  Form defines
 ************************************************************************)

CONST
  XmATTACH_NONE = 0;
  XmATTACH_FORM = 1;
  XmATTACH_OPPOSITE_FORM = 2;
  XmATTACH_WIDGET = 3;
  XmATTACH_OPPOSITE_WIDGET = 4;
  XmATTACH_POSITION = 5;
  XmATTACH_SELF = 6;

TYPE
  _XmFormAttachment = SYSTEM.int;

CONST
  XmRESIZE_NONE = 0;
  XmRESIZE_GROW = 1;
  XmRESIZE_ANY = 2;

TYPE
  _XmFormResizing = SYSTEM.int;

(****************************************************************************
 *  Callback reasons
 ****************************************************************************)

CONST
  XmCR_NONE = 0;
  XmCR_HELP = 1;
  XmCR_VALUE_CHANGED = 2;
  XmCR_INCREMENT = 3;
  XmCR_DECREMENT = 4;
  XmCR_PAGE_INCREMENT = 5;
  XmCR_PAGE_DECREMENT = 6;
  XmCR_TO_TOP = 7;
  XmCR_TO_BOTTOM = 8;
  XmCR_DRAG = 9;
  XmCR_ACTIVATE = 10;
  XmCR_ARM = 11;
  XmCR_DISARM = 12;
  XmCR_MAP = 16;
  XmCR_UNMAP = 17;
  XmCR_FOCUS = 18;
  XmCR_LOSING_FOCUS = 19;
  XmCR_MODIFYING_TEXT_VALUE = 20;
  XmCR_MOVING_INSERT_CURSOR = 21;
  XmCR_EXECUTE = 22;
  XmCR_SINGLE_SELECT = 23;
  XmCR_MULTIPLE_SELECT = 24;
  XmCR_EXTENDED_SELECT = 25;
  XmCR_BROWSE_SELECT = 26;
  XmCR_DEFAULT_ACTION = 27;
  XmCR_CLIPBOARD_DATA_REQUEST = 28;
  XmCR_CLIPBOARD_DATA_DELETE = 29;
  XmCR_CASCADING = 30;
  XmCR_OK = 31;
  XmCR_CANCEL = 32;
  XmCR_APPLY = 34;
  XmCR_NO_MATCH = 35;
  XmCR_COMMAND_ENTERED = 36;
  XmCR_COMMAND_CHANGED = 37;
  XmCR_EXPOSE = 38;
  XmCR_RESIZE = 39;
  XmCR_INPUT = 40;
  XmCR_GAIN_PRIMARY = 41;
  XmCR_LOSE_PRIMARY = 42;
  XmCR_CREATE = 43;
  XmCR_TEAR_OFF_ACTIVATE = 44;
  XmCR_TEAR_OFF_DEACTIVATE = 45;
  XmCR_OBSCURED_TRAVERSAL = 46;
  XmCR_PROTOCOLS = 47;
(*  XmCR_FOCUS_MOVED = 48  *)

TYPE
  _XmCallbackReasons = SYSTEM.int;

(************************************************************************
 *  Callback structures
 ************************************************************************)

  XmAnyCallbackStruct = RECORD
    reason: SYSTEM.int;
    event : Xlib.PtrXEvent;
  END;

  XmArrowButtonCallbackStruct = RECORD
    reason     : SYSTEM.int;
    event      : Xlib.PtrXEvent;
    click_count: SYSTEM.int;
  END;

  XmDrawingAreaCallbackStruct = RECORD
    reason: SYSTEM.int;
    event : Xlib.PtrXEvent;
    window: X.Window;
  END;

  XmDrawnButtonCallbackStruct = RECORD
    reason     : SYSTEM.int;
    event      : Xlib.PtrXEvent;
    window     : X.Window;
    click_count: SYSTEM.int;
  END;

  XmPushButtonCallbackStruct = RECORD
    reason     : SYSTEM.int;
    event      : Xlib.PtrXEvent;
    click_count: SYSTEM.int;
  END;

  XmRowColumnCallbackStruct = RECORD
    reason        : SYSTEM.int;
    event         : Xlib.PtrXEvent;
    widget        : Xt.Widget;
    data          : Xt.XtPointer;
    callbackstruct: Xt.XtPointer;
  END;

  XmScrollBarCallbackStruct = RECORD
    reason: SYSTEM.int;
    event : Xlib.PtrXEvent;
    value : SYSTEM.int;
    pixel : SYSTEM.int;
  END;

  XmToggleButtonCallbackStruct = RECORD
    reason: SYSTEM.int;
    event : Xlib.PtrXEvent;
    set   : SYSTEM.int;
  END;

  XmListCallbackStruct = RECORD
    reason                 : SYSTEM.int;
    event                  : Xlib.PtrXEvent;
    item                   : XmString;
    item_length            : SYSTEM.int;
    item_position          : SYSTEM.int;
    selected_items         : XmStringTable;
    selected_item_count    : SYSTEM.int;
    selected_item_positions: Xlib.PASInt;
    selection_type         : CHAR;
  END;

  XmSelectionBoxCallbackStruct = RECORD
    reason: SYSTEM.int;
    event : Xlib.PtrXEvent;
    value : XmString;
    length: SYSTEM.int;
  END;

  XmCommandCallbackStruct = RECORD
    reason: SYSTEM.int;
    event : Xlib.PtrXEvent;
    value : XmString;
    length: SYSTEM.int;
  END;

  XmFileSelectionBoxCallbackStruct = RECORD
    reason        : SYSTEM.int;
    event         : Xlib.PtrXEvent;
    value         : XmString;
    length        : SYSTEM.int;
    mask          : XmString;
    mask_length   : SYSTEM.int;
    dir           : XmString;
    dir_length    : SYSTEM.int;
    pattern       : XmString;
    pattern_length: SYSTEM.int;
  END;

  XmScaleCallbackStruct = RECORD
    reason: SYSTEM.int;
    event : Xlib.PtrXEvent;
    value : SYSTEM.int;
  END;

(************************************************************************
 *  PushButton defines
 ************************************************************************)

CONST
  XmMULTICLICK_DISCARD = 0;
  XmMULTICLICK_KEEP = 1;

TYPE
  _XmPButtonDefs = SYSTEM.int;

(************************************************************************
 *  DrawnButton defines
 ************************************************************************)

CONST
  XmSHADOW_IN = 7;
  XmSHADOW_OUT = 8;

TYPE
  _XmDButtonDefs = SYSTEM.int;

(************************************************************************
 *  Arrow defines
 ************************************************************************)

CONST
  XmARROW_UP = 0;
  XmARROW_DOWN = 1;
  XmARROW_LEFT = 2;
  XmARROW_RIGHT = 3;

TYPE
  _XmArrowDefs = SYSTEM.int;

(************************************************************************
 *  Separator defines
 *  Note: XmINVALID_SEPARATOR_TYPE marks the last+1 separator type
 ************************************************************************)

CONST
  XmNO_LINE = 0;
  XmSINGLE_LINE = 1;
  XmDOUBLE_LINE = 2;
  XmSINGLE_DASHED_LINE = 3;
  XmDOUBLE_DASHED_LINE = 4;
  XmSHADOW_ETCHED_IN = 5;
  XmSHADOW_ETCHED_OUT = 6;
  XmSHADOW_ETCHED_IN_DASH = 7;
  XmSHADOW_ETCHED_OUT_DASH = 8;
  XmINVALID_SEPARATOR_TYPE = 9;

TYPE
  _XmSeparatorDefs = SYSTEM.int;

CONST
  XmPIXMAP = 1;
  XmSTRING = 2;

TYPE
  _XmSeparatorType = SYSTEM.int;

(************************************************************************
 *  Drag and Drop #defines
 ************************************************************************)

CONST
  XmWINDOW = 0;
(*  XmPIXMAP = 1;  *)
  XmCURSOR = 2;

TYPE
  _XmDnDDefs = SYSTEM.int;

(************************************************************************
 *  ScrollBar #defines
 ************************************************************************)

CONST
  XmMAX_ON_TOP = 0;
  XmMAX_ON_BOTTOM = 1;
  XmMAX_ON_LEFT = 2;
  XmMAX_ON_RIGHT = 3;

TYPE
  _XmScrollBarDefs = SYSTEM.int;

(************************************************************************
 *									*
 * List Widget defines							*
 *									*
 ************************************************************************)

CONST
  XmSINGLE_SELECT = 0;
  XmMULTIPLE_SELECT = 1;
  XmEXTENDED_SELECT = 2;
  XmBROWSE_SELECT = 3;

TYPE
  _XmListSelectionPolicy = SYSTEM.int;

CONST
  XmSTATIC = 0;
  XmDYNAMIC = 1;

TYPE
  _XmListType = SYSTEM.int;

(************************************************************************
 *									*
 * Scrolled Window defines.						*
 *									*
 ************************************************************************)

CONST
  XmVARIABLE = 0;
  XmCONSTANT = 1;
  XmRESIZE_IF_POSSIBLE = 2;

TYPE
  _XmSWindowDefs = SYSTEM.int;

CONST
  XmAUTOMATIC = 0;
  XmAPPLICATION_DEFINED = 1;

TYPE
  _XmSWindowSize = SYSTEM.int;

CONST
(*  XmSTATIC = 0; *)
  XmAS_NEEDED = 1;

TYPE
  _XmSWindowType = SYSTEM.int;

CONST
  SW_TOP = 1;
  SW_BOTTOM = 0;
  SW_LEFT = 2;
  SW_RIGHT = 0;
  XmTOP_LEFT = 3;
  XmBOTTOM_LEFT = 2;
  XmTOP_RIGHT = 1;
  XmBOTTOM_RIGHT = 0;

(************************************************************************
 *									*
 * MainWindow Resources                                                 *
 *									*
 ************************************************************************)

  XmCOMMAND_ABOVE_WORKSPACE = 0;
  XmCOMMAND_BELOW_WORKSPACE = 1;

TYPE
  _XmMWindowDefs = SYSTEM.int;

(************************************************************************
 *									*
 * Text Widget defines							*
 *									*
 ************************************************************************)

CONST
  XmMULTI_LINE_EDIT = 0;
  XmSINGLE_LINE_EDIT = 1;

TYPE
  _XmTextLineNumber = SYSTEM.int;

CONST
  XmTEXT_FORWARD = 0;
  XmTEXT_BACKWARD = 1;

TYPE
  XmTextDirection = SYSTEM.int;

  XmTextPosition = LONGINT;

  XmTextFormat = LONGCARD;

CONST
  XmFMT_8_BIT = 31;                    (*  8-bit text.  *)
  FMT8BIT = XmFMT_8_BIT;               (*  For backwards compatibility only. *)
  XmFMT_16_BIT = 2;                    (*  16-bit text.  *)
  FMT16BIT = XmFMT_16_BIT;             (*  For backwards compatibility only. *)

  XmSELECT_POSITION = 0;
  XmSELECT_WHITESPACE = 1;
  XmSELECT_WORD = 2;
  XmSELECT_LINE = 3;
  XmSELECT_ALL = 4;
  XmSELECT_PARAGRAPH = 5;

TYPE
  XmTextScanType = SYSTEM.int;

  XmTextScanTypeList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF XmTextScanType;

CONST
  XmHIGHLIGHT_NORMAL = 0;
  XmHIGHLIGHT_SELECTED = 1;
  XmHIGHLIGHT_SECONDARY_SELECTED = 2;

TYPE
  XmHighlightMode = SYSTEM.int;

(*  XmTextBlock's are used to pass text around.  *)

  XmTextBlockRec = RECORD
    ptr   : Xt.XtPointer;      (*  Pointer to data.  *)
    length: SYSTEM.int;        (*  Number of bytes of data.  *)
    format: XmTextFormat;      (*  Representations format  *)
  END;

  XmTextBlock = POINTER TO XmTextBlockRec;

  XmTextVerifyCallbackStruct = RECORD
    reason    : SYSTEM.int;
    event     : Xlib.PtrXEvent;
    doit      : Xt.Boolean;
    currInsert: LONGINT;
    newInsert : LONGINT;
    startPos  : LONGINT;
    endPos    : LONGINT;
    text      : XmTextBlock;
  END;

  XmTextVerifyPtr = POINTER TO XmTextVerifyCallbackStruct;

(* XmTextBlockWcs's are used in 1.2 modifyVerifyWcs callbacks for Text[Field]
 * widgets.
 *)

  XmTextBlockRecWcs = RECORD
    wcsptr: Xlib.Ptrwchar_t;  (*  Pointer to data.  *)
    length: SYSTEM.int;       (*  Number of characters (not bytes) of data.  *)
  END;

  XmTextBlockWcs = POINTER TO XmTextBlockRecWcs;

  XmTextVerifyCallbackStructWcs = RECORD
    reason    : SYSTEM.int;
    event     : Xlib.PtrXEvent;
    doit      : Xt.Boolean;
    currInsert: LONGINT;
    newInsert : LONGINT;
    startPos  : LONGINT;
    endPos    : LONGINT;
    text      : XmTextBlockWcs;
  END;

  XmTextVerifyPtrWcs = POINTER TO XmTextVerifyCallbackStructWcs;

(*  functions renamed after 1.0 release due to resource name overlap  *)

CONST
  XmCOPY_FAILED = 0;
  XmCOPY_SUCCEEDED = 1;
  XmCOPY_TRUNCATED = 2;

(*************************************************************************
 *									 *
 *  DIALOG defines..  BulletinBoard and things common to its subclasses  *
 *          CommandBox    MessageBox    Selection    FileSelection       *
 *									 *
 *************************************************************************)

(*  child type defines for Xm...GetChild()  *)
  XmDIALOG_NONE = 0;
  XmDIALOG_APPLY_BUTTON = 1;
  XmDIALOG_CANCEL_BUTTON = 2;
  XmDIALOG_DEFAULT_BUTTON = 3;
  XmDIALOG_OK_BUTTON = 4;
  XmDIALOG_FILTER_LABEL = 5;
  XmDIALOG_FILTER_TEXT = 6;
  XmDIALOG_HELP_BUTTON = 7;
  XmDIALOG_LIST = 8;
  XmDIALOG_LIST_LABEL = 9;
  XmDIALOG_MESSAGE_LABEL = 10;
  XmDIALOG_SELECTION_LABEL = 11;
  XmDIALOG_SYMBOL_LABEL = 12;
  XmDIALOG_TEXT = 13;
  XmDIALOG_SEPARATOR = 14;
  XmDIALOG_DIR_LIST = 15;
  XmDIALOG_DIR_LIST_LABEL = 16;

TYPE
  _XmDialogType = SYSTEM.int;

CONST
  XmDIALOG_VALUE_TEXT = XmDIALOG_TEXT;
  XmDIALOG_PROMPT_LABEL = XmDIALOG_SELECTION_LABEL;
  XmDIALOG_HISTORY_LIST = XmDIALOG_LIST;
  XmDIALOG_FILE_LIST_LABEL = XmDIALOG_LIST_LABEL;
  XmDIALOG_FILE_LIST = XmDIALOG_LIST;
  XmDIALOG_COMMAND_TEXT = XmDIALOG_TEXT;
  (*   dialog style defines   *)
  XmDIALOG_MODELESS = 0;
  XmDIALOG_PRIMARY_APPLICATION_MODAL = 1;
  XmDIALOG_FULL_APPLICATION_MODAL = 2;
  XmDIALOG_SYSTEM_MODAL = 3;

TYPE
  _XmDialogStyle = SYSTEM.int;

CONST
  XmDIALOG_APPLICATION_MODAL = XmDIALOG_PRIMARY_APPLICATION_MODAL;

(*  The following is for compatibility only. Its use is deprecated.  *)

(************************************************************************
 * XmSelectionBox, XmFileSelectionBox and XmCommand - misc. stuff       *
 ************************************************************************)

(*  Defines for Selection child placement  *)
  XmPLACE_TOP = 0;
  XmPLACE_ABOVE_SELECTION = 1;
  XmPLACE_BELOW_SELECTION = 2;

TYPE
  _XmSelectionChildPlacement = SYSTEM.int;

(*  Defines for file type mask:  *)

CONST
  XmFILE_DIRECTORY = 1;
  XmFILE_REGULAR = 2;
  XmFILE_ANY_TYPE = 3;

(*  Defines for selection dialog type:  *)
  XmDIALOG_WORK_AREA = 0;
  XmDIALOG_PROMPT = 1;
  XmDIALOG_SELECTION = 2;
  XmDIALOG_COMMAND = 3;
  XmDIALOG_FILE_SELECTION = 4;

TYPE
  _XmMainDialogTypes = SYSTEM.int;

(************************************************************************
 *  XmMessageBox           stuff not common to other dialogs            *
 ************************************************************************)

(*  defines for dialog type  *)

CONST
  XmDIALOG_TEMPLATE = 0;
  XmDIALOG_ERROR = 1;
  XmDIALOG_INFORMATION = 2;
  XmDIALOG_MESSAGE = 3;
  XmDIALOG_QUESTION = 4;
  XmDIALOG_WARNING = 5;
  XmDIALOG_WORKING = 6;

TYPE
  _XmMBoxType = SYSTEM.int;

(*   Traversal types   *)

CONST
  XmVISIBILITY_UNOBSCURED = 0;
  XmVISIBILITY_PARTIALLY_OBSCURED = 1;
  XmVISIBILITY_FULLY_OBSCURED = 2;

TYPE
  XmVisibility = SYSTEM.int;

CONST
  XmTRAVERSE_CURRENT = 0;
  XmTRAVERSE_NEXT = 1;
  XmTRAVERSE_PREV = 2;
  XmTRAVERSE_HOME = 3;
  XmTRAVERSE_NEXT_TAB_GROUP = 4;
  XmTRAVERSE_PREV_TAB_GROUP = 5;
  XmTRAVERSE_UP = 6;
  XmTRAVERSE_DOWN = 7;
  XmTRAVERSE_LEFT = 8;
  XmTRAVERSE_RIGHT = 9;

TYPE
  XmTraversalDirection = SYSTEM.int;

  _XmTraverseObscuredCallbackStruct = RECORD
    reason               : SYSTEM.int;
    event                : Xlib.PtrXEvent;
    traversal_destination: Xt.Widget;
    direction            : XmTraversalDirection;
  END;

  XmTraverseObscuredCallbackStruct = _XmTraverseObscuredCallbackStruct;

  XmNavigationType = SHORTCARD;

(***********************************************************************
 *
 * SimpleMenu declarations and definitions.
 *
 ***********************************************************************)

  XmButtonType = SHORTCARD;

  XmButtonTypeTable = POINTER TO XmButtonType;

  XmKeySymTable = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF X.KeySym;

CONST
  XmPUSHBUTTON = 1;
  XmTOGGLEBUTTON = 2;
  XmRADIOBUTTON = 3;
  XmCASCADEBUTTON = 4;
  XmSEPARATOR = 5;
  XmDOUBLE_SEPARATOR = 6;
  XmTITLE = 7;

TYPE
  _XmSMenuType = SYSTEM.int;

CONST
  XmCHECKBUTTON = XmTOGGLEBUTTON;

(********    BaseClass.c    ********)

TYPE
  XmResourceBaseProc = PROCEDURE ( Xt.Widget, Xt.XtPointer ):
                                   Xt.XtPointer;

  _XmSecondaryResourceDataRec = RECORD
    base_proc    : XmResourceBaseProc;
    client_data  : Xt.XtPointer;
    name         : Xt.String;
    res_class    : Xt.String;
    resources    : Xt.XtResourceList;
    num_resources: Xt.Cardinal;
  END;

  XmSecondaryResourceDataRec = _XmSecondaryResourceDataRec;

  XmSecondaryResourceData = POINTER TO _XmSecondaryResourceDataRec;

(********    Public Function Declarations for BaseClass.c    ********)

  XmSecondaryResourceDataPtr = POINTER TO XmSecondaryResourceData;

PROCEDURE XmGetSecondaryResourceData ( w_class: Xt.WidgetClass;
                                       VAR secondaryDataRtn: XmSecondaryResourceDataPtr ): Xt.Cardinal;

(********    End Public Function Declarations    ********)
(********    Public Function Declarations for ImageCache.c    ********)

PROCEDURE XmInstallImage ( image: Xlib.PtrXImage;
                           image_name: ARRAY OF CHAR ): Xt.Boolean;

PROCEDURE XmUninstallImage ( image: Xlib.PtrXImage ): Xt.Boolean;

PROCEDURE XmGetPixmap ( screen: Xlib.PtrScreen;
      	      	      	image_name: ARRAY OF CHAR;
                        foreground: Xt.Pixel;
                        background: Xt.Pixel ): X.Pixmap;

PROCEDURE XmGetPixmapByDepth ( screen: Xlib.PtrScreen;
			       image_name: ARRAY OF CHAR;
                               foreground: Xt.Pixel;
                               background: Xt.Pixel;
                               depth: SYSTEM.int ): X.Pixmap;

PROCEDURE XmDestroyPixmap ( screen: Xlib.PtrScreen;
                            pixmap: X.Pixmap ): Xt.Boolean;

(********    End Public Function Declarations    ********)
(********    Public Function Declarations for Manager.c    ********)

PROCEDURE XmUpdateDisplay ( w: Xt.Widget );

(********    End Public Function Declarations    ********)
(********    Primitive.c    ********)

TYPE
  XmOffset = LONGINT;

  XmOffsetPtr = POINTER TO XmOffset;

(********    Public Function Declarations for Primitive.c    ********)

PROCEDURE XmResolvePartOffsets ( w_class: Xt.WidgetClass;
                                 VAR offset: XmOffsetPtr );

PROCEDURE XmResolveAllPartOffsets ( w_class: Xt.WidgetClass;
                                    VAR offset: XmOffsetPtr;
                                    VAR constraint_offset: XmOffsetPtr );

PROCEDURE XmWidgetGetBaselines ( wid: Xt.Widget;
                                 baselines: Xt.DimensionList;
                                 VAR line_count: SYSTEM.int ): Xt.Boolean;

PROCEDURE XmWidgetGetDisplayRect ( wid: Xt.Widget;
                                   VAR displayrect: Xlib.XRectangle ): Xt.Boolean;

(********    End Public Function Declarations    ********)
(********    Public Function Declarations for ResConvert.c    ********)

PROCEDURE XmRegisterConverters (  );

PROCEDURE XmCvtStringToUnitType ( args: Xrm.PAXrmValue;
                                  VAR num_args: Xt.Cardinal;
                                  VAR from_val: Xrm.XrmValue;
                                  VAR to_val: Xrm.XrmValue );

PROCEDURE XmRegisterSegmentEncoding ( fontlist_tag: ARRAY OF CHAR;
                                      ct_encoding: ARRAY OF CHAR ): Xt.String;

PROCEDURE XmMapSegmentEncoding ( fontlist_tag: ARRAY OF CHAR ): Xt.String;

PROCEDURE XmCvtCTToXmString ( text: ARRAY OF CHAR ): XmString;

PROCEDURE XmCvtTextToXmString ( display: Xlib.PtrDisplay;
                                args: Xrm.PAXrmValue;
                                VAR num_args: Xt.Cardinal;
      	      	      	      	VAR from_val: Xrm.XrmValue;
                                VAR to_val: Xrm.XrmValue;
                                VAR converter_data: Xt.XtPointer ): Xt.Boolean;

PROCEDURE XmCvtXmStringToCT ( string: XmString ): Xt.String;

PROCEDURE XmCvtXmStringToText ( display: Xlib.PtrDisplay;
                                args: Xrm.PAXrmValue;
                                VAR num_args: Xt.Cardinal;
      	      	      	      	VAR from_val: Xrm.XrmValue;
                                VAR to_val: Xrm.XrmValue;
                                VAR converter_data: Xt.XtPointer ): Xt.Boolean;

(********    End Public Function Declarations    ********)
(********    Public Function Declarations for ResInd.c    ********)

PROCEDURE XmConvertUnits ( widget: Xt.Widget;
                           dimension: SYSTEM.int;
                           from_type: SYSTEM.int;
      	      	      	   from_val: SYSTEM.int;
                           to_type: SYSTEM.int ): SYSTEM.int;

PROCEDURE XmCvtToHorizontalPixels ( screen: Xlib.PtrScreen;
				    from_val: SYSTEM.int;
                                    from_type: SYSTEM.int ): SYSTEM.int;

PROCEDURE XmCvtToVerticalPixels ( screen: Xlib.PtrScreen;
				  from_val: SYSTEM.int;
                                  from_type: SYSTEM.int ): SYSTEM.int;

PROCEDURE XmCvtFromHorizontalPixels ( screen: Xlib.PtrScreen;
				      from_val: SYSTEM.int;
                                      to_type: SYSTEM.int ): SYSTEM.int;

PROCEDURE XmCvtFromVerticalPixels ( screen: Xlib.PtrScreen;
				    from_val: SYSTEM.int;
                                    to_type: SYSTEM.int ): SYSTEM.int;

PROCEDURE XmSetFontUnits ( display: Xlib.PtrDisplay;
			   h_value: SYSTEM.int;
                           v_value: SYSTEM.int );

PROCEDURE XmSetFontUnit ( display: Xlib.PtrDisplay;
                          value: SYSTEM.int );

(********    End Public Function Declarations    ********)
(********    Public Function Declarations for MenuUtil.c    ********)

PROCEDURE XmSetMenuCursor ( display: Xlib.PtrDisplay;
                            cursorId: X.Cursor );

PROCEDURE XmGetMenuCursor ( display: Xlib.PtrDisplay ): X.Cursor;

(********    End Public Function Declarations    ********)
(********    Public Function Declarations for Simple.c    ********)

PROCEDURE XmCreateSimpleMenuBar ( parent: Xt.Widget;
                                  name: ARRAY OF CHAR;
                                  args: Xt.ArgList;
                                  arg_count: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateSimplePopupMenu ( parent: Xt.Widget;
                                    name: ARRAY OF CHAR;
                                    args: Xt.ArgList;
                                    arg_count: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateSimplePulldownMenu ( parent: Xt.Widget;
                                       name: ARRAY OF CHAR;
                                       args: Xt.ArgList;
                                       arg_count: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateSimpleOptionMenu ( parent: Xt.Widget;
                                     name: ARRAY OF CHAR;
                                     args: Xt.ArgList;
                                     arg_count: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateSimpleRadioBox ( parent: Xt.Widget;
                                   name: ARRAY OF CHAR;
                                   args: Xt.ArgList;
                                   arg_count: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateSimpleCheckBox ( parent: Xt.Widget;
                                   name: ARRAY OF CHAR;
                                   args: Xt.ArgList;
                                   arg_count: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)
(********    Public Function Declarations for VaSimple.c   ********)

PROCEDURE XmVaCreateSimpleMenuBar ( parent: Xt.Widget;
                                    name: ARRAY OF CHAR;
                                    SEQ args: SYSTEM.BYTE ): Xt.Widget;

PROCEDURE XmVaCreateSimplePopupMenu ( parent: Xt.Widget;
                                      name: ARRAY OF CHAR;
                                      callback: Xt.XtCallbackProc;
                                      SEQ args: SYSTEM.BYTE ): Xt.Widget;

PROCEDURE XmVaCreateSimplePulldownMenu ( parent: Xt.Widget;
                                         name: ARRAY OF CHAR;
                                         post_from_button: SYSTEM.int;
                                         callback: Xt.XtCallbackProc;
                                         SEQ args: SYSTEM.BYTE ): Xt.Widget;

PROCEDURE XmVaCreateSimpleOptionMenu ( parent: Xt.Widget;
                                       name: ARRAY OF CHAR;
                                       option_label: XmString;
                                       option_mnemonic: X.KeySym;
                                       button_set: SYSTEM.int;
                                       callback: Xt.XtCallbackProc;
                                       SEQ args: SYSTEM.BYTE ): Xt.Widget;

PROCEDURE XmVaCreateSimpleRadioBox ( parent: Xt.Widget;
                                     name: ARRAY OF CHAR;
                                     button_set: SYSTEM.int;
                                     callback: Xt.XtCallbackProc;
                                     SEQ args: SYSTEM.BYTE ): Xt.Widget;

PROCEDURE XmVaCreateSimpleCheckBox ( parent: Xt.Widget;
                                     name: ARRAY OF CHAR;
                                     callback: Xt.XtCallbackProc;
                                     SEQ args: SYSTEM.BYTE ): Xt.Widget;

(********    End Public Function Declarations    ********)
(********    Public Function Declarations for TrackLoc.c    ********)

PROCEDURE XmTrackingEvent ( widget: Xt.Widget;
                            cursor: X.Cursor;
                            confineTo: Xt.Boolean;
                            VAR pev: Xlib.XEvent ): Xt.Widget;

PROCEDURE XmTrackingLocate ( widget: Xt.Widget;
                             cursor: X.Cursor;
                             confineTo: Xt.Boolean ): Xt.Widget;

(********    End Public Function Declarations    ********)
(********    Visual.c    ********)

TYPE
  XmColorProc = PROCEDURE ( (* bg_color *) VAR Xlib.XColor,
			    (* fg_color *) VAR Xlib.XColor,
			    (* sel_color *) VAR Xlib.XColor,
			    (* ts_color *) VAR Xlib.XColor,
			    (* bs_color *) VAR Xlib.XColor );

(********    Public Function Declarations for Visual.c    ********)

PROCEDURE XmSetColorCalculation ( proc: XmColorProc ): XmColorProc;

PROCEDURE XmGetColorCalculation (  ): XmColorProc;

PROCEDURE XmGetColors ( screen: Xlib.PtrScreen;
		        color_map: X.Colormap;
                        background: Xt.Pixel;
		        VAR foreground_ret: Xt.Pixel;
			VAR top_shadow_ret: Xt.Pixel;
		        VAR bottom_shadow_ret: Xt.Pixel;
			VAR select_ret: Xt.Pixel );

PROCEDURE XmChangeColor ( widget: Xt.Widget;
                          background: Xt.Pixel );

(********    End Public Function Declarations    ********)
(********    Public Function Declarations for XmString.c    ********)

PROCEDURE XmStringCreate ( text: ARRAY OF CHAR;
                           charset: ARRAY OF CHAR ): XmString;

PROCEDURE XmStringCreateSimple ( text: ARRAY OF CHAR ): XmString;

PROCEDURE XmStringCreateLocalized ( text: ARRAY OF CHAR ): XmString;

PROCEDURE XmStringDirectionCreate ( direction: XmStringDirection ): XmString;

PROCEDURE XmStringSeparatorCreate ( ): XmString;

PROCEDURE XmStringSegmentCreate ( text: ARRAY OF CHAR;
                                  charset: ARRAY OF CHAR;
                                  direction: XmStringDirection;
                                  separator: Xt.Boolean ): XmString;

PROCEDURE XmStringLtoRCreate ( text: ARRAY OF CHAR;
			       charset: ARRAY OF CHAR ): XmString;

PROCEDURE XmStringCreateLtoR ( text: ARRAY OF CHAR;
                               charset: ARRAY OF CHAR ): XmString;

PROCEDURE XmStringInitContext ( VAR context: XmStringContext;
                                string: XmString ): Xt.Boolean;

PROCEDURE XmStringFreeContext ( context: XmStringContext );

PROCEDURE XmStringGetNextComponent ( context: XmStringContext;
                                     VAR text: ARRAY OF CHAR;
                                     VAR charset: ARRAY OF CHAR;
                                     VAR direction: XmStringDirection;
                                     VAR unknown_tag: XmStringDirection;
                                     VAR unknown_length: Xt.Dimension;
                                     VAR unknown_value: XmString ): XmStringComponentType;

PROCEDURE XmStringPeekNextComponent ( context : XmStringContext ): XmStringComponentType;

PROCEDURE XmStringGetNextSegment ( context: XmStringContext;
                                   VAR text: ARRAY OF CHAR;
                                   VAR charset: ARRAY OF CHAR;
                                   VAR direction: XmStringDirection;
                                   VAR separator: CHAR ): Xt.Boolean;

PROCEDURE XmStringGetLtoR ( string: XmString;
                            charset: ARRAY OF CHAR;
                            VAR text: ARRAY OF CHAR ): Xt.Boolean;

PROCEDURE XmFontListEntryCreate ( tag: ARRAY OF CHAR;
			          type: XmFontType;
                                  font: Xt.XtPointer ): XmFontListEntry;

PROCEDURE XmFontListEntryFree ( VAR entry: XmStringContext );

PROCEDURE XmFontListEntryGetFont ( entry: XmFontListEntry;
				   VAR typeReturn: XmFontType ): Xt.XtPointer;

PROCEDURE XmFontListEntryGetTag ( entry: XmFontListEntry ): Xt.String;

PROCEDURE XmFontListAppendEntry ( old: XmFontList;
                                  entry: XmFontListEntry ): XmFontList;

PROCEDURE XmFontListNextEntry ( context: XmFontContext ): XmFontListEntry;

PROCEDURE XmFontListRemoveEntry ( old: XmFontList;
                                  entry: XmFontListEntry ): XmFontList;

PROCEDURE XmFontListEntryLoad ( display: Xlib.PtrDisplay;
			        fontName: ARRAY OF CHAR;
                                type: XmFontType;
                                tag: ARRAY OF CHAR ): XmFontListEntry;

PROCEDURE XmFontListCreate ( font: Xlib.PtrXFontStruct;
                             charset: ARRAY OF CHAR ): XmFontList;

PROCEDURE XmStringCreateFontList ( font: Xlib.PtrXFontStruct;
                                   charset: ARRAY OF CHAR ): XmFontList;

PROCEDURE XmFontListFree ( fontlist: XmFontList );

PROCEDURE XmFontListAdd ( old: XmFontList;
                          font: Xlib.PtrXFontStruct;
                          charset: ARRAY OF CHAR ): XmFontList;

PROCEDURE XmFontListCopy ( fontlist : XmFontList ): XmFontList;

PROCEDURE XmFontListInitFontContext ( VAR context: XmStringContext;
                                      fontlist: XmFontList ): Xt.Boolean;

PROCEDURE XmFontListGetNextFont ( context : XmFontContext;
				  VAR charset: ARRAY OF CHAR;
                                  VAR font: Xlib.PtrXFontStruct ): Xt.Boolean;

PROCEDURE XmFontListFreeFontContext ( context: XmFontContext );

PROCEDURE XmStringConcat ( a: XmString;
                           b: XmString ): XmString;

PROCEDURE XmStringNConcat ( first: XmString;
			    second: XmString;
			    n: SYSTEM.int ): XmString;

PROCEDURE XmStringCopy ( string: XmString ): XmString;

PROCEDURE XmStringNCopy ( str: XmString;
                          n: SYSTEM.int ): XmString;

PROCEDURE XmStringByteCompare ( a1: XmString;
                                b1: XmString ): Xt.Boolean;

PROCEDURE XmStringCompare ( a: XmString;
                            b: XmString ): Xt.Boolean;

PROCEDURE XmStringLength ( string: XmString ): SYSTEM.int;

PROCEDURE XmStringEmpty ( string: XmString ): Xt.Boolean;

PROCEDURE XmStringHasSubstring ( string: XmString;
                                 substring: XmString ): Xt.Boolean;

PROCEDURE XmStringFree ( string : XmString );

PROCEDURE XmStringBaseline ( fontlist: XmFontList;
			     string: XmString ): Xt.Dimension;

PROCEDURE XmStringWidth ( fontlist: XmFontList;
			  string: XmString ): Xt.Dimension;

PROCEDURE XmStringHeight ( fontlist: XmFontList;
			   string: XmString ): Xt.Dimension;

PROCEDURE XmStringExtent ( fontlist: XmFontList;
			   string: XmString;
                           VAR width: Xt.Dimension;
                           VAR height: Xt.Dimension );

PROCEDURE XmStringLineCount ( string: XmString ): SYSTEM.int;

PROCEDURE XmStringDraw ( d: Xlib.PtrDisplay;
			 w: X.Window;
			 fontlist: XmFontList;
			 string: XmString;
			 gc: Xlib.GC;
			 x: Xt.Position;
			 y: Xt.Position;
			 width: Xt.Dimension;
			 align: SHORTCARD;
			 lay_dir: SHORTCARD;
			 VAR clip: Xlib.XRectangle );

PROCEDURE XmStringDrawImage ( d: Xlib.PtrDisplay;
			      w: X.Window;
			      fontlist: XmFontList;
			      string: XmString;
			      gc: Xlib.GC;
			      x: Xt.Position;
			      y: Xt.Position;
			      width: Xt.Dimension;
			      align: SHORTCARD;
			      lay_dir: SHORTCARD;
			      VAR clip: Xlib.XRectangle );

PROCEDURE XmStringDrawUnderline ( d: Xlib.PtrDisplay;
				  w: X.Window;
				  fntlst: XmFontList;
				  str: XmString;
				  gc: Xlib.GC;
				  x: Xt.Position;
				  y: Xt.Position;
				  width: Xt.Dimension;
				  align: SHORTCARD;
				  lay_dir: SHORTCARD;
				  VAR clip: Xlib.XRectangle;
				  under: XmString );

(********    End Public Function Declarations    ********)
(********    Public Function Declarations for Dest.c    ********)

PROCEDURE XmGetDestination (display : Xlib.PtrDisplay ): Xt.Widget;

(********    End Public Function Declarations    ********)
(********    Public Function Declarations for Traversal.c    ********)

PROCEDURE XmIsTraversable (wid : Xt.Widget ): Xt.Boolean;

PROCEDURE XmGetVisibility (wid : Xt.Widget ): XmVisibility;

PROCEDURE XmGetTabGroup (wid : Xt.Widget ): Xt.Widget;

PROCEDURE XmGetFocusWidget (wid: Xt.Widget ): Xt.Widget;

PROCEDURE XmProcessTraversal (w: Xt.Widget;
			      dir: XmTraversalDirection ): Xt.Boolean;

PROCEDURE XmAddTabGroup ( tabGroup: Xt.Widget );

PROCEDURE XmRemoveTabGroup ( w: Xt.Widget );

(********    End Public Function Declarations    ********)
(********    Public Function Declarations for XmIm.c    ********)

PROCEDURE XmImRegister ( w: Xt.Widget;
			 reserved: CARDINAL );

PROCEDURE XmImUnregister ( w: Xt.Widget );

PROCEDURE XmImSetFocusValues ( w: Xt.Widget;
                               args: Xt.ArgList;
                               num_args: Xt.Cardinal );

PROCEDURE XmImSetValues ( w: Xt.Widget;
			  args: Xt.ArgList;
			  num_args: Xt.Cardinal );

PROCEDURE XmImUnsetFocus ( w: Xt.Widget );

PROCEDURE XmImGetXIM ( w: Xt.Widget ): Xlib.XIM;

PROCEDURE XmImMbLookupString ( w: Xt.Widget;
			       VAR event: Xlib.XKeyPressedEvent;
			       buf: ARRAY OF CHAR;
			       nbytes: SYSTEM.int;
			       VAR keysym: X.KeySym;
			       VAR status: SYSTEM.int ): SYSTEM.int;

PROCEDURE XmImVaSetFocusValues ( w: Xt.Widget;
				 SEQ args: SYSTEM.BYTE );

PROCEDURE XmImVaSetValues ( w: Xt.Widget;
			    SEQ args: SYSTEM.BYTE );

(********    End Public Function Declarations    ********)

(* The following includes are for source compatibility.  They might be
 * removed at some future time.
 *)

(* ---------------------------------------------------- *)
(*                     Xm/VendorS.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE XmIsVendorShell ( w: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / XmIsVendorShell ( w: Xt.Widget ): Xt.Boolean;

<*+ GENTYPEDEF *>

<* END *>

TYPE
  _XmVendorShellRec = RECORD
    (* Declaration without definition *)
  END;

  XmVendorShellWidget = POINTER TO _XmVendorShellRec;

  _XmVendorShellClassRec = RECORD
    (* Declaration without definition *)
  END;

  XmVendorShellWidgetClass = POINTER TO _XmVendorShellClassRec;

VAR
  vendorShellWidgetClass: Xt.WidgetClass;

(********    Public Function Declarations    ********)

PROCEDURE XmIsMotifWMRunning ( shell: Xt.Widget ): Xt.Boolean;

(********    End Public Function Declarations    ********)

(* ------------------------------------------------- *)
(*                     Xm/XmP.h                      *)
(* ------------------------------------------------- *)

(***************************************************************************
 *  Macros replacing toolkit macros so that gadgets are handled properly.
 ***************************************************************************)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros.
   H2D: names are already exists.
PROCEDURE XtName ( widget: Xt.Widget ): Xt.Boolean;
PROCEDURE XtIsManaged ( widget: Xt.Widget ): Xt.Boolean;
PROCEDURE XtIsSensitive ( widget: Xt.Widget ): Xt.Boolean;
*)

<* ELSE *>

(*
PROCEDURE  / XtName ( widget: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XtIsManaged ( widget: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XtIsSensitive ( widget: Xt.Widget ): Xt.Boolean;
*)

<* END *>

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE XtX ( w: Xt.Widget ): Xt.Position;
PROCEDURE XtY ( w: Xt.Widget ): Xt.Position;
PROCEDURE XtWidth ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE XtHeight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE XtBorderWidth ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE XtBackground ( w: Xt.Widget ): Xt.Pixel;
PROCEDURE XtSensitive ( w: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / XtX ( w: Xt.Widget ): Xt.Position;
PROCEDURE  / XtY ( w: Xt.Widget ): Xt.Position;
PROCEDURE  / XtWidth ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / XtHeight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / XtBorderWidth ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / XtBackground ( w: Xt.Widget ): Xt.Pixel;
PROCEDURE  / XtSensitive ( w: Xt.Widget ): Xt.Boolean;

<* END *>

(***********************************************************************
 *
 * Miscellaneous Private Defines
 *
 ***********************************************************************)

(*  Defines used for menu/button communication  *)

CONST
  XmMENU_POPDOWN = 0;
  XmMENU_PROCESS_TREE = 1;
  XmMENU_TRAVERSAL = 2;
  XmMENU_SHELL_POPDOWN = 3;
  XmMENU_CALLBACK = 4;
  XmMENU_BUTTON = 5;
  XmMENU_CASCADING = 6;
  XmMENU_SUBMENU = 7;
  XmMENU_ARM = 8;
  XmMENU_DISARM = 9;
  XmMENU_BAR_CLEANUP = 10;
  XmMENU_STATUS = 11;
  XmMENU_MEMWIDGET_UPDATE = 12;
  XmMENU_BUTTON_POPDOWN = 13;
  XmMENU_RESTORE_EXCLUDED_TEAROFF_TO_TOPLEVEL_SHELL = 14;
  XmMENU_RESTORE_TEAROFF_TO_TOPLEVEL_SHELL = 15;
  XmMENU_RESTORE_TEAROFF_TO_MENUSHELL = 16;
  XmMENU_GET_LAST_SELECT_TOPLEVEL = 17;
  XmMENU_TEAR_OFF_ARM = 18;

  XmRETURN = 0;        (*  For Motif 1.1 BC.  *)
  XmCANCEL = 1;        (*  For Motif 1.1 BC.  *)

(***********************************************************************
 *
 * Status for menus
 *
 ***********************************************************************)

  XmMENU_TORN_BIT = {0};
  XmMENU_TEAR_OFF_SHELL_DESCENDANT_BIT = {1};
  XmMENU_POPUP_POSTED_BIT = {2};

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE XmIsTorn ( mask: BITSET ): Xt.Boolean;
PROCEDURE XmIsTearOffShellDescendant ( mask: BITSET ): Xt.Boolean;
PROCEDURE XmPopupPosted ( mask: BITSET ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / XmIsTorn ( mask: BITSET ): Xt.Boolean;
PROCEDURE  / XmIsTearOffShellDescendant ( mask: BITSET ): Xt.Boolean;
PROCEDURE  / XmPopupPosted ( mask: BITSET ): Xt.Boolean;

<* END *>

TYPE
  XmMenuProc = PROCEDURE ( SYSTEM.int,
                           Xt.Widget,
                           SEQ SYSTEM.BYTE );

(***********************************************************************
 *
 * Simple Menu Structure
 *
 ***********************************************************************)

  _XmSimpleMenuRec = RECORD
    count           : SYSTEM.int;
    post_from_button: SYSTEM.int;
    callback        : Xt.XtCallbackProc;
    label_string    : XmStringTable;
    accelerator     : XmStringCharSetTable;
    accelerator_text: XmStringTable;
    mnemonic        : XmKeySymTable;
    mnemonic_charset: XmStringCharSetTable;
    button_type     : XmButtonTypeTable;
    button_set      : SYSTEM.int;
    option_label    : XmString;
    option_mnemonic : X.KeySym;
  END;

  XmSimpleMenuRec = _XmSimpleMenuRec;

  XmSimpleMenu = POINTER TO _XmSimpleMenuRec;

(*  For MapEvent: _XmMatchBtnEvent  *)

CONST
  XmIGNORE_EVENTTYPE = -1;

(*  Default minimum Toggle indicator dimension  *)
  XmDEFAULT_INDICATOR_DIM = 9;

(************************************************************************
 * defines needed for 3D visual enhancement of defaultButtonshadow and
 *  implementation of ToggleButton Indicatorsize.
 ************************************************************************)

  Xm3D_ENHANCE_PIXEL = 2;
  XmDEFAULT_TOP_MARGIN = 0;
  XmDEFAULT_BOTTOM_MARGIN = 0;

(************************************************************************
 *
 *  Resource definition function and structure used by Primitive, Gadget
 *  and Manager to define there get values hook processing lists
 *
 ************************************************************************)

  XmSYNTHETIC_NONE = 0;
  XmSYNTHETIC_LOAD = 1;

TYPE
  XmImportOperator = SYSTEM.int;

  XmExportProc = PROCEDURE ( Xt.Widget,
                             SYSTEM.int,
                             VAR Xt.XtArgVal );

  XmImportProc = PROCEDURE ( Xt.Widget,
                             SYSTEM.int,
                             VAR Xt.XtArgVal ): XmImportOperator;

  _XmSyntheticResource = RECORD
    resource_name  : Xt.String;
    resource_size  : Xt.Cardinal;
    resource_offset: Xt.Cardinal;
    export_proc    : XmExportProc;
    import_proc    : XmImportProc;
  END;

  XmSyntheticResource = _XmSyntheticResource;

(*   Structure and defines for parent process data  *)

  XmParentProcessAnyRec = RECORD
    process_type: SYSTEM.int;  (*  Common to all parent process records.  *)
  END;

  XmParentInputActionRec = RECORD
    process_type: SYSTEM.int;  (*  Common to all parent process records.  *)
    event       : Xlib.PtrXEvent;
    action      : SYSTEM.int;
    params      : Xt.StringList;
    num_params  : Xt.CardinalList;
  END;

  XmParentProcessDataRec = RECORD
    CASE : INTEGER OF
       0: any         : XmParentProcessAnyRec;
      |1: input_action: XmParentInputActionRec;
    END;
  END;

  XmParentProcessData = POINTER TO XmParentProcessDataRec;

CONST
  XmPARENT_PROCESS_ANY = 0;
  XmINPUT_ACTION = 1;

  XmPARENT_ACTIVATE = 0;
  XmPARENT_CANCEL = 1;

  XmINVALID_DIMENSION = 0FFFFH;
  XmBASELINE_GET = 0;
  XmBASELINE_SET = 1;

TYPE
  _XmBaselineMargins = RECORD
    get_or_set   : SHORTCARD;
    margin_top   : Xt.Dimension;
    margin_bottom: Xt.Dimension;
    shadow       : Xt.Dimension;
    highlight    : Xt.Dimension;
    text_height  : Xt.Dimension;
    margin_height: Xt.Dimension;
  END;

  XmBaselineMargins = _XmBaselineMargins;

  XmBaselineMarginsPtr = POINTER TO XmBaselineMargins;

CONST
  XmFOCUS_IN = 0;
  XmFOCUS_OUT = 1;
  XmENTER = 2;
  XmLEAVE = 3;

TYPE
  XmFocusChange = SYSTEM.int;

CONST
  XmNOT_NAVIGABLE = 0;
  XmCONTROL_NAVIGABLE = 1;
  XmTAB_NAVIGABLE = 2;
  XmDESCENDANTS_NAVIGABLE = 3;
  XmDESCENDANTS_TAB_NAVIGABLE = 4;

TYPE
  XmNavigability = SYSTEM.int;

  XmParentProcessProc = PROCEDURE ( Xt.Widget,
                                    XmParentProcessData ): Xt.Boolean;

  XmWidgetDispatchProc = PROCEDURE ( Xt.Widget,
				     VAR Xlib.XEvent,
				     X.Mask );

  XmMenuPopupProc = PROCEDURE ( Xt.Widget,
                                Xt.Widget,
                              	Xlib.PtrXEvent );

  XmMenuTraversalProc = PROCEDURE ( Xt.Widget,
                                    Xt.Widget,
                                    XmTraversalDirection );

  XmResizeFlagProc = PROCEDURE ( Xt.Widget,
                                 Xt.Boolean );

  XmRealizeOutProc = PROCEDURE ( Xt.Widget,
                                 XmKeySymTable,
                                 VAR Xlib.XSetWindowAttributes );

  XmVisualChangeProc = PROCEDURE ( Xt.Widget,
				   Xt.Widget,
                                   Xt.Widget ): Xt.Boolean;

  XmTraversalProc = PROCEDURE ( Xt.Widget,
                                Xt.XtPointer,
                              	Xt.XtPointer,
                                SYSTEM.int );

  XmFocusMovedProc = PROCEDURE ( Xt.Widget,
                                 Xt.XtPointer,
                               	Xt.XtPointer );

  XmCacheCopyProc = PROCEDURE ( Xt.XtPointer,
                                Xt.XtPointer,
                              	(* size_t *) CARDINAL );

  XmGadgetCacheProc = PROCEDURE ( Xt.XtPointer );

  XmCacheCompareProc = PROCEDURE ( Xt.XtPointer,
                                   Xt.XtPointer ): SYSTEM.int;

  XmWidgetBaselineProc = PROCEDURE ( Xt.Widget,
                                     VAR Xt.DimensionList,
                                     VAR SYSTEM.int ): Xt.Boolean;

  XmWidgetDisplayRectProc = PROCEDURE ( Xt.Widget,
                                        VAR Xlib.XRectangle ): Xt.Boolean;

  XmWidgetMarginsProc = PROCEDURE ( Xt.Widget, VAR XmBaselineMargins );

  XmWidgetNavigableProc = PROCEDURE ( Xt.Widget ): XmNavigability;

  XmFocusChangeProc = PROCEDURE ( Xt.Widget, XmFocusChange );

(****************
 *
 * Data structure for building a real translation table out of a
 * virtual string.
 *
 ****************)

  _XmBuildVirtualKeyStruct = RECORD
    mod   : Xt.Modifiers;
    key   : XmStringCharSet;
    action: XmStringCharSet;
  END;

  _XmBuildVirtualKeyList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF _XmBuildVirtualKeyStruct;

(***********************************************************************
 *
 * Types shared by Text and TextField widgets
 *
 ***********************************************************************)

(*
 * This struct is for support of Insert Selection targets.
 *)

  _XmTextInsertPair = RECORD
    selection: X.Atom;
    target   : X.Atom;
  END;

  _XmHighlightRec = RECORD
    position: XmTextPosition;    (*  Starting position.  *)
    mode    : XmHighlightMode;   (*  Highlighting mode for this position.  *)
  END;

  _XmHighlightList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF _XmHighlightRec;

  _XmHighlightData = RECORD
    number : Xt.Cardinal;      (*  Number of different highlight areas.  *)
    maximum: Xt.Cardinal;      (*  Number we've allocated space for.  *)
    list   : _XmHighlightList; (*  Pointer to array of highlight data.  *)
  END;

CONST
  XmDEST_SELECT = 0;
  XmPRIM_SELECT = 1;

TYPE
  XmSelectType = SYSTEM.int;

  _XmInsertSelect = RECORD
    done_status   : Xt.Boolean;   (*  completion status of insert selection  *)
    success_status: Xt.Boolean;   (*  success status of insert selection  *)
    select_type   : XmSelectType; (*  insert selection type  *)
    event : Xlib.PtrXSelectionRequestEvent; (* event that initiated the
                                             * insert selection *)
  END;

  _XmTextActionRec = RECORD
    event     : Xlib.PtrXEvent;
    params    : XmStringCharSetTable;
    num_params: Xt.CardinalList;
  END;

  _XmTextDropTransferRec = RECORD
    widget    : Xt.Widget;
    insert_pos: XmTextPosition;
    num_chars : SYSTEM.int;
    timestamp : X.Time;
    move      : Xt.Boolean;
  END;

  _XmTextPrimSelect = RECORD
    position : XmTextPosition;
    target   : X.Atom;
    time     : X.Time;
    num_chars: SYSTEM.int;
    ref_count: SYSTEM.int;
  END;

  XmTextContextDataRec = RECORD
    screen : Xlib.PtrScreen;
    context: Xutil.XContext;
    type   : SHORTCARD;
  END;

  XmTextContextData = POINTER TO XmTextContextDataRec;

CONST
  _XM_IS_DEST_CTX = 0;
  _XM_IS_GC_DATA_CTX = 1;
  _XM_IS_PIXMAP_CTX = 2;

  XmTEXT_DRAG_ICON_WIDTH = 64;
  XmTEXT_DRAG_ICON_HEIGHT = 64;
  XmTEXT_DRAG_ICON_X_HOT = 10;
  XmTEXT_DRAG_ICON_Y_HOT = 4;

(***********************************************************************
 *
 * Types and functions for Geometry Utilities
 *
 ***********************************************************************)

(*  Defines used by geometry manager utilities  *)
  XmGET_ACTUAL_SIZE = 1;
  XmGET_PREFERRED_SIZE = 2;
  XmGEO_PRE_SET = 3;
  XmGEO_POST_SET = 4;

(*  Defaults for Geometry Utility defines are always 0.  *)
  XmGEO_EXPAND = 0;
  XmGEO_CENTER = 1;
  XmGEO_PACK = 2;

  XmGEO_PROPORTIONAL = 0;
  XmGEO_AVERAGING = 1;
  XmGEO_WRAP = 2;

  XmGEO_ROW_MAJOR = 0;
  XmGEO_COLUMN_MAJOR = 1;

(*  XmGEO_COLUMN_MAJOR is not yet supported.  *)

TYPE
  XmGeoMatrix = POINTER TO _XmGeoMatrixRec;

  XmGeoMajorLayout = POINTER TO _XmGeoMajorLayoutRec;

  _XmKidGeometryRec = RECORD
    kid: Xt.Widget;             (*  ptr to kid  *)
    box: Xt.XtWidgetGeometry;   (*  kid geo box  *)
  END;

  XmKidGeometryRec = _XmKidGeometryRec;

  XmKidGeometry = POINTER TO _XmKidGeometryRec;

  XmGeoArrangeProc = PROCEDURE ( XmGeoMatrix,
                                 Xt.Position,
                               	 Xt.Position,
                                 VAR Xt.Dimension,
                               	 VAR Xt.Dimension );

  XmGeoExceptProc = PROCEDURE ( XmGeoMatrix ): Xt.Boolean;

  XmGeoExtDestructorProc = PROCEDURE ( Xt.XtPointer );

  XmGeoSegmentFixUpProc = PROCEDURE ( XmGeoMatrix,
                                      SYSTEM.int,
                                      XmGeoMajorLayout,
                                      XmKidGeometry );

  XmGeoRowLayoutRec = RECORD
    end         : Xt.Boolean;   (* Flag to mark end of rows. *)
    fix_up      : XmGeoSegmentFixUpProc; (* Used for non-ordinary layouts. *)
    even_width  : Xt.Dimension; (* If non-zero, set all boxes to same width.*)
    even_height : Xt.Dimension; (* If non-zero, set all boxes to same height.*)
    min_height  : Xt.Dimension; (* Minimum height, if stretch_height TRUE. *)
    stretch_height: Xt.Boolean; (* Stretch height to fill vertically. *)
    uniform_border: Xt.Boolean; (* Enforce on all kids this row, dflt F. *)
    border      : Xt.Dimension; (* Value to use if uniform_border set. *)
    fill_mode   : SHORTCARD;    (* Possible values: XmGEO_PACK, XmGEO_CENTER,
      	      	      	      	 * or XmGEO_EXPAND (default). *)
    fit_mode    : SHORTCARD;    (* Method for fitting boxes into space,
      	      	      	      	 * XmGEO_PROPORTIONAL (dflt), XmGEO_AVERAGING,
                                 * or XmGEO_WRAP. *)
    sticky_end  : Xt.Boolean;   (* Last box in row sticks to edge, dflt F. *)
    space_above : Xt.Dimension; (* Between-line spacing, default 0. *)
    space_end   : Xt.Dimension; (* End spacing (XmGEO_CENTER), default 0. *)
    space_between: Xt.Dimension;(* Internal spacing, default 0. *)
    max_box_height:Xt.Dimension;(* Set during arrange routine. *)
    boxes_width : Xt.Dimension; (* Set during arrange routine. *)
    fill_width  : Xt.Dimension; (* Set during arrange routine. *)
    box_count   : Xt.Dimension; (* Set during arrange routine. *)
  END;

  XmGeoRowLayout = POINTER TO XmGeoRowLayoutRec;

  XmGeoColumnLayoutRec = RECORD
    end         : Xt.Boolean;   (* Flag to mark end of columns. *)
    fix_up      : XmGeoSegmentFixUpProc;(* Used for non-ordinary layouts. *)
    even_height : Xt.Dimension; (* If non-zero, set all boxes to same height *)
    even_width  : Xt.Dimension; (* If non-zero, set all boxes to same width. *)
    min_width   : Xt.Dimension; (* Minimum width, if stretch_width TRUE. *)
    stretch_width : Xt.Boolean; (* Stretch width to fill horizontally. *)
    uniform_border: Xt.Boolean; (* Enforce on all kids this row, dflt F. *)
    border      : Xt.Dimension; (* Value to use if uniform_border set. *)
    fill_mode   : SHORTCARD;    (* Possible values: XmGEO_PACK, XmGEO_CENTER,
      	      	      	      	 * or XmGEO_EXPAND (default). *)
    fit_mode    : SHORTCARD;    (* Method for fitting boxes into space,
      	      	      	      	 * XmGEO_PROPORTIONAL (dflt), XmGEO_AVERAGING,
                                 * or XmGEO_WRAP. *)
    sticky_end  : Xt.Boolean;   (* Last box in row sticks to edge, dflt F. *)
    space_left  : Xt.Dimension; (* Between-column spacing, default 0. *)
    space_end   : Xt.Dimension; (* End spacing (XmGEO_CENTER), default 0. *)
    space_between: Xt.Dimension;(* Internal spacing, default 0. *)
    max_box_width: Xt.Dimension;(* Set during arrange routine. *)
    boxes_height: Xt.Dimension; (* Set during arrange routine. *)
    fill_height : Xt.Dimension; (* Set during arrange routine. *)
    box_count   : Xt.Dimension; (* Set during arrange routine. *)
  END;

  XmGeoColumnLayout = POINTER TO XmGeoColumnLayoutRec;

  XmGeoMajorLayoutRec = _XmGeoMajorLayoutRec;

  _XmGeoMatrixRec = RECORD
    composite     : Xt.Widget; (* Widget managing layout. *)
    instigator    : Xt.Widget; (* Widget initiating re-layout. *)
    instig_request: Xt.XtWidgetGeometry; (* Geometry layout request of instigatr. *)
    parent_request: Xt.XtWidgetGeometry; (* Subsequent layout request to parent.  *)
    in_layout: Xt.XtWidgetGeometryPtr; (* Geo. of instig. in layout (after Get). *)
    boxes: XmKidGeometry; (* Array of boxes, lines separated by NULL record. *)
    layouts: XmGeoMajorLayout; (* Array of major_order format info.          *)
    margin_w: Xt.Dimension; (* Sum of margin, highlight, & shadow thickness. *)
    margin_h: Xt.Dimension; (* Sum of margin, highlight, & shadow thickness. *)
    stretch_boxes : Xt.Boolean;   (* Set during arrange routine. *)
    uniform_border: Xt.Boolean;   (* Enforce on all kids, default FALSE. *)
    border        : Xt.Dimension; (* Value to use if uniform_border TRUE. *)
    max_major     : Xt.Dimension; (* Set during arrange routine. *)
    boxes_minor   : Xt.Dimension; (* Set during arrange routine. *)
    fill_minor    : Xt.Dimension; (* Set during arrange routine. *)
    width         : Xt.Dimension; (* Set during arrange routine. *)
    height        : Xt.Dimension; (* Set during arrange routine. *)
    set_except    : XmGeoExceptProc;
    almost_except : XmGeoExceptProc;
    no_geo_request: XmGeoExceptProc;
    extension     : Xt.XtPointer;
    ext_destructor: XmGeoExtDestructorProc;
    arrange_boxes : XmGeoArrangeProc;(* For user-defined arrangement routine.*)
    major_order   : SHORTCARD;
  END;

  XmGeoMatrixRec = _XmGeoMatrixRec;

  _XmGeoMajorLayoutRec = RECORD
    CASE : INTEGER OF
       0: row: XmGeoRowLayoutRec;
      |1: col: XmGeoColumnLayoutRec;
    END;
  END;

  XmGeoCreateProc = PROCEDURE ( Xt.Widget,
                                Xt.Widget,
                              	VAR Xt.XtWidgetGeometry ): XmGeoMatrix;

(*  XtInheritFocusMovedProc is provided for backwards compatibility.
 *  Its use is deprecated.
 *)

(************************************************************************
 *
 *  Fast subclassing macros and definitions
 *
 ************************************************************************)

(*    WARNING:  Application subclasses which choose to use fast
 *              subclassing must use only those bits between
 *              192 (XmFIRST_APPLICATION_SUBCLASS_BIT) and 255.
 *              All other fast subclass bits are reserved for
 *              future use.  Use of reserved fast subclass bits
 *              will cause binary compatibility breaks with
 *              future Motif versions.
 *)

CONST
  XmFIRST_APPLICATION_SUBCLASS_BIT = 192;
  XmCASCADE_BUTTON_BIT = 1;
  XmCASCADE_BUTTON_GADGET_BIT = 2;
  XmCOMMAND_BOX_BIT = 3;
  XmDIALOG_SHELL_BIT = 4;
  XmLIST_BIT = 5;
  XmFORM_BIT = 6;
  XmTEXT_FIELD_BIT = 7;
  XmGADGET_BIT = 8;
  XmLABEL_BIT = 9;
  XmLABEL_GADGET_BIT = 10;
  XmMAIN_WINDOW_BIT = 11;
  XmMANAGER_BIT = 12;
  XmMENU_SHELL_BIT = 13;
  XmDRAWN_BUTTON_BIT = 14;
  XmPRIMITIVE_BIT = 15;
  XmPUSH_BUTTON_BIT = 16;
  XmPUSH_BUTTON_GADGET_BIT = 17;
  XmROW_COLUMN_BIT = 18;
  XmSCROLL_BAR_BIT = 19;
  XmSCROLLED_WINDOW_BIT = 20;
  XmSELECTION_BOX_BIT = 21;
  XmSEPARATOR_BIT = 22;
  XmSEPARATOR_GADGET_BIT = 23;
  XmTEXT_BIT = 24;
  XmTOGGLE_BUTTON_BIT = 25;
  XmTOGGLE_BUTTON_GADGET_BIT = 26;
  XmDROP_TRANSFER_BIT = 27;
  XmDROP_SITE_MANAGER_BIT = 28;
  XmDISPLAY_BIT = 29;
  XmSCREEN_BIT = 30;
(*  31 is unused  *)
  XmARROW_BUTTON_BIT = 32;
  XmARROW_BUTTON_GADGET_BIT = 33;
  XmBULLETIN_BOARD_BIT = 34;
  XmDRAWING_AREA_BIT = 35;
  XmFILE_SELECTION_BOX_BIT = 36;
  XmFRAME_BIT = 37;
  XmMESSAGE_BOX_BIT = 38;
  XmSASH_BIT = 39;
  XmSCALE_BIT = 40;
  XmPANED_WINDOW_BIT = 41;
  XmVENDOR_SHELL_BIT = 42;
  XmCLIP_WINDOW_BIT = 43;
  XmDRAG_ICON_BIT = 44;
  XmTEAROFF_BUTTON_BIT = 45;
  XmDRAG_OVER_SHELL_BIT = 46;
  XmDRAG_CONTEXT_BIT = 47;
  XmFAST_SUBCLASS_TAIL_BIT = 48; (*  New entries precede this.  *)
  XmLAST_FAST_SUBCLASS_BIT = XmFAST_SUBCLASS_TAIL_BIT-1;

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE XmIsCascadeButton ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsCascadeButtonGadget ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsCommandBox ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsDialogShell ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsDisplay ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsList ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsForm ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsTextField ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsGadget ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsLabel ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsLabelGadget ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsMainWindow ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsManager ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsMenuShell ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsDragIcon ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsDropSiteManager ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsDropTransfer ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsDragOverShell ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsDragContext ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsDrawnButton ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsPrimitive ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsPushButton ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsPushButtonGadget ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsRowColumn ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsScreen ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsScrollBar ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsScrolledWindow ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsSelectionBox ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsSeparator ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsSeparatorGadget ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsText ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsTearOffButton ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsToggleButton ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsToggleButtonGadget ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsArrowButton ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsArrowButtonGadget ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsBulletinBoard ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsDrawingArea ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsFileSelectionBox ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsFrame ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsMessageBox ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsSash ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsScale ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE XmIsPanedWindow ( w: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / XmIsCascadeButton ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsCascadeButtonGadget ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsCommandBox ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsDialogShell ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsDisplay ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsList ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsForm ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsTextField ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsGadget ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsLabel ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsLabelGadget ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsMainWindow ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsManager ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsMenuShell ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsDragIcon ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsDropSiteManager ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsDropTransfer ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsDragOverShell ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsDragContext ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsDrawnButton ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsPrimitive ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsPushButton ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsPushButtonGadget ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsRowColumn ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsScreen ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsScrollBar ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsScrolledWindow ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsSelectionBox ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsSeparator ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsSeparatorGadget ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsText ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsTearOffButton ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsToggleButton ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsToggleButtonGadget ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsArrowButton ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsArrowButtonGadget ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsBulletinBoard ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsDrawingArea ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsFileSelectionBox ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsFrame ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsMessageBox ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsSash ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsScale ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / XmIsPanedWindow ( w: Xt.Widget ): Xt.Boolean;

<* END *>

(************************************************************************
 *
 *  Defines and macros for the XmResolvePart function
 *
 ************************************************************************)

(*   Widget class indices used with XmPartOffset and XmField macros   *)

CONST
  XmObjectIndex = 0;
  ObjectIndex = XmObjectIndex;
  XmRectObjIndex = XmObjectIndex+1;
  RectObjIndex = XmRectObjIndex;
  XmWindowObjIndex = XmRectObjIndex+1;
  WindowObjIndex = XmWindowObjIndex;
  XmCoreIndex = 0;
  CoreIndex = XmCoreIndex;
  XmCompositeIndex = XmWindowObjIndex+2;
  CompositeIndex = XmCompositeIndex;
  XmConstraintIndex = XmCompositeIndex+1;
  ConstraintIndex = XmConstraintIndex;
  XmGadgetIndex = XmRectObjIndex+1;
  XmPrimitiveIndex = XmWindowObjIndex+2;
  XmManagerIndex = XmConstraintIndex+1;
  XmArrowBIndex = XmPrimitiveIndex+1;
  XmArrowButtonIndex = XmArrowBIndex;
  XmLabelIndex = XmPrimitiveIndex+1;
  XmListIndex = XmPrimitiveIndex+1;
  XmScrollBarIndex = XmPrimitiveIndex+1;
  XmSeparatorIndex = XmPrimitiveIndex+1;
  XmTextIndex = XmPrimitiveIndex+1;
  XmCascadeBIndex = XmLabelIndex+1;
  XmCascadeButtonIndex = XmCascadeBIndex;
  XmDrawnBIndex = XmLabelIndex+1;
  XmDrawnButtonIndex = XmDrawnBIndex;
  XmPushBIndex = XmLabelIndex+1;
  XmPushButtonIndex = XmPushBIndex;
  XmToggleBIndex = XmLabelIndex+1;
  XmToggleButtonIndex = XmToggleBIndex;
  XmTearOffButtonIndex = XmPushBIndex+1;
  XmArrowBGIndex = XmGadgetIndex+1;
  XmArrowButtonGadgetIndex = XmArrowBGIndex;
  XmLabelGIndex = XmGadgetIndex+1;
  XmLabelGadgetIndex = XmLabelGIndex;
  XmSeparatoGIndex = XmGadgetIndex+1;
  XmSeparatorGadgetIndex = XmSeparatoGIndex;
  XmCascadeBGIndex = XmLabelGIndex+1;
  XmCascadeButtonGadgetIndex = XmCascadeBGIndex;
  XmPushBGIndex = XmLabelGIndex+1;
  XmPushButtonGadgetIndex = XmPushBGIndex;
  XmToggleBGIndex = XmLabelGIndex+1;
  XmToggleButtonGadgetIndex = XmToggleBGIndex;
  XmBulletinBIndex = XmManagerIndex+1;
  XmBulletinBoardIndex = XmBulletinBIndex;
  XmDrawingAIndex = XmManagerIndex+1;
  XmDrawingAreaIndex = XmDrawingAIndex;
  XmFrameIndex = XmManagerIndex+1;
  XmPanedWIndex = XmManagerIndex+1;
  XmPanedWindowIndex = XmPanedWIndex;
  XmSashIndex = XmPrimitiveIndex+1;
  XmRowColumnIndex = XmManagerIndex+1;
  XmScaleIndex = XmManagerIndex+1;
  XmScrolledWIndex = XmManagerIndex+1;
  XmScrolledWindowIndex = XmScrolledWIndex;
  XmFormIndex = XmBulletinBIndex+1;
  XmMessageBIndex = XmBulletinBIndex+1;
  XmMessageBoxIndex = XmMessageBIndex;
  XmSelectioBIndex = XmBulletinBIndex+1;
  XmSelectionBoxIndex = XmSelectioBIndex;
  XmMainWIndex = XmScrolledWIndex+1;
  XmMainWindowIndex = XmMainWIndex;
  XmCommandIndex = XmSelectioBIndex+1;
  XmFileSBIndex = XmSelectioBIndex+1;
  XmFileSelectionBoxIndex = XmFileSBIndex;
  XmShellIndex = XmCompositeIndex+1;
  ShellIndex = XmShellIndex;
  XmOverrideShellIndex = XmShellIndex+1;
  OverrideShellIndex = XmOverrideShellIndex;
  XmWMShellIndex = XmShellIndex+1;
  WMShellIndex = XmWMShellIndex;
  XmVendorShellIndex = XmWMShellIndex+1;
  VendorShellIndex = XmVendorShellIndex;
  XmTransientShellIndex = XmVendorShellIndex+1;
  TransientShellIndex = XmTransientShellIndex;
  XmTopLevelShellIndex = XmVendorShellIndex+1;
  TopLevelShellIndex = XmTopLevelShellIndex;
  XmApplicationShellIndex = XmTopLevelShellIndex+1;
  ApplicationShellIndex = XmApplicationShellIndex;
  XmDisplayIndex = XmApplicationShellIndex+1;
  XmDialogSIndex = XmTransientShellIndex+1;
  XmDialogShellIndex = XmDialogSIndex;
  XmMenuShellIndex = XmOverrideShellIndex+1;
  XmDragIconIndex = XmRectObjIndex+1;
  XmDropSiteManagerIndex = XmObjectIndex+1;
  XmDropTransferIndex = XmObjectIndex+1;
  XmDragOverShellIndex = XmVendorShellIndex+1;
  XmDragContextIndex = XmCoreIndex+1;

(*
 * XmOFFSETBITS is the number of bits used for the part offset within the
 * resource_offset field in the XmPartResource struct.  XmOFFSETMASK is the
 * bitmask to mask for the part offset.
 *)

TYPE
  _XmPartResource = RECORD
    resource_name  : Xt.String;   (* Resource name *)
    resource_class : Xt.String;   (* Resource class *)
    resource_type  : Xt.String;   (* Representation type desired *)
    resource_size  : Xt.Cardinal; (* Size in bytes of representation *)
    resource_offset: Xt.Cardinal; (* Index within & offset within part *)
    default_type   : Xt.String;   (* representation type of specified default*)
    default_addr   : Xt.XtPointer;(* Address of default resource *)
  END;

  XmPartResource = _XmPartResource;

(***********************************************************************
 *
 * XmRegion structure
 *
 *  This structure must match the opaque libX Region structure.
 *
 ***********************************************************************)

TYPE
  XmRegionBox = RECORD
    x1: SYSTEM.INT16;
    x2: SYSTEM.INT16;
    y1: SYSTEM.INT16;
    y2: SYSTEM.INT16;
  END;

  XmRegionBoxPtr = POINTER TO XmRegionBox;

  XmRegionBoxList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF XmRegionBox;

  _XmRegion = RECORD
    size    : LONGINT;
    numRects: LONGINT;
    rects   : XmRegionBoxList;
    extents : XmRegionBox;
  END;

  XmRegionRec = _XmRegion;

  XmRegion = POINTER TO _XmRegion;

(********    Private Function Declarations for GadgetUtil.c    ********)

PROCEDURE _XmInputInGadget ( cw: Xt.Widget;
                             x: SYSTEM.int;
                             y: SYSTEM.int ): XmGadget;

PROCEDURE _XmInputForGadget ( cw: Xt.Widget;
                              x: SYSTEM.int;
                              y: SYSTEM.int ): XmGadget;

PROCEDURE _XmConfigureObject ( g: Xt.Widget;
                               x: Xt.Position;
                               y: Xt.Position;
                               width: Xt.Dimension;
                               height: Xt.Dimension;
                               border_width: Xt.Dimension );

PROCEDURE _XmResizeObject ( g: Xt.Widget;
                            width: Xt.Dimension;
                            height: Xt.Dimension;
                            border_width: Xt.Dimension );

PROCEDURE _XmMoveObject ( g: Xt.Widget;
                          x: Xt.Position;
                          y: Xt.Position );

PROCEDURE _XmRedisplayGadgets ( w: Xt.Widget;
                                event: Xlib.PtrXEvent;
                                region: Xutil.Region );

PROCEDURE _XmDispatchGadgetInput ( g: Xt.Widget;
                                   VAR event: Xlib.XEvent;
                                   mask: X.Mask );

PROCEDURE __XmGetDefaultTime ( w: Xt.Widget;
                               VAR event: Xlib.XEvent ): X.Time;

(********    End Private Function Declarations    ********)
(******** _XmCreateImage ********)

(*  The _XmCreateImage macro is used to create XImage with client
 *  specific data for the bit and byte order.
 *  We still have to do the following because XCreateImage
 *  will stuff here display specific data and we want
 *  client specific values (i.e the bit orders we used for
 *  creating the bitmap data in Motif) -- BUG 4262
 *  Used in Motif 1.2 in DragIcon.c, MessageB.c, ReadImage.c and
 *  ImageCache.c
 *)

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE _XmCreateImage ( VAR IMAGE: Xlib.PtrXImage;
                           DISPLAY: Xlib.PtrDisplay;
                           DATA: Xlib.XPointer;
                           WIDTH, HEIGHT: SYSTEM.unsigned;
                           BYTE_ORDER: SYSTEM.int );

<* ELSE *>

PROCEDURE / _XmCreateImage ( VAR IMAGE: Xlib.PtrXImage;
                             DISPLAY: Xlib.PtrDisplay;
                             DATA: Xlib.XPointer;
                             WIDTH, HEIGHT: SYSTEM.unsigned;
                             BYTE_ORDER: SYSTEM.int );

<* END *>

(********    Private Function Declarations for ImageCache.c    ********)

PROCEDURE _XmInstallImage ( image: Xlib.PtrXImage;
                            image_name: ARRAY OF CHAR;
                            hot_x: SYSTEM.int;
                            hot_y: SYSTEM.int ): Xt.Boolean;

PROCEDURE _XmGetImage ( screen: Xlib.PtrScreen;
                        image_name: ARRAY OF CHAR;
                        VAR image: Xlib.PtrXImage ): Xt.Boolean;

PROCEDURE _XmGetPixmapData ( screen: Xlib.PtrScreen;
                             pixmap: X.Pixmap;
                             VAR image_name: Xt.String;
                             VAR depth: SYSTEM.int;
                             VAR foreground: Xt.Pixel;
                             VAR background: Xt.Pixel;
                             VAR hot_x: SYSTEM.int;
                             VAR hot_y: SYSTEM.int;
                             VAR width: Xt.Cardinal;
                             VAR height: Xt.Cardinal ): Xt.Boolean;

PROCEDURE _XmGetPixmap ( screen: Xlib.PtrScreen;
                         image_name: ARRAY OF CHAR;
                         depth: SYSTEM.int;
                         foreground: Xt.Pixel;
                         background: Xt.Pixel ): X.Pixmap;

PROCEDURE _XmInstallPixmap ( pixmap: X.Pixmap;
                             screen: Xlib.PtrScreen;
                             image_name: ARRAY OF CHAR;
                             foreground: Xt.Pixel;
                             background: Xt.Pixel ): Xt.Boolean;

(********    End Private Function Declarations    ********)
(********    Private Function Declarations for MapEvents.c    ********)

PROCEDURE _XmMapBtnEvent ( str: Xt.String;
                           VAR eventType: SYSTEM.int;
                           VAR button: Xt.Cardinal;
                           VAR modifiers: Xt.Cardinal ): Xt.Boolean;

PROCEDURE _XmMapKeyEvent ( str: Xt.String;
                           VAR eventType: SYSTEM.int;
                           VAR keysym: CARDINAL;
                           VAR modifiers: CARDINAL ): Xt.Boolean;

PROCEDURE _XmMatchBtnEvent ( VAR event: Xlib.XEvent;
                             eventType: SYSTEM.int;
                             button: CARDINAL;
                             modifiers: CARDINAL ): Xt.Boolean;

PROCEDURE _XmMatchKeyEvent ( VAR event: Xlib.XEvent;
                             eventType: SYSTEM.int;
                             key: CARDINAL;
                             modifiers: CARDINAL ): Xt.Boolean;

(********    End Private Function Declarations    ********)
(********    Private Function Declarations for ReadImage.c    ********)

PROCEDURE _XmGetImageFromFile ( filename: ARRAY OF CHAR ): Xlib.PtrXImage;

PROCEDURE _XmGetImageAndHotSpotFromFile ( filename: ARRAY OF CHAR;
                                          VAR hot_x: SYSTEM.int;
                                          VAR hot_y: SYSTEM.int ): Xlib.PtrXImage;

(********    End Private Function Declarations    ********)
(********    ResConvert.c    ********)

CONST
  XmLABEL_FONTLIST = 1;
  XmBUTTON_FONTLIST = 2;
  XmTEXT_FONTLIST = 3;

(********    Private Function Declarations for ResConvert.c    ********)

PROCEDURE _XmRegisterConverters (  );

PROCEDURE _XmWarning ( w: Xt.Widget; message: ARRAY OF CHAR );

PROCEDURE _XmStringsAreEqual ( in_str: ARRAY OF CHAR;
                               test_str: ARRAY OF CHAR ): Xt.Boolean;

PROCEDURE _XmGetDefaultFontList ( w: Xt.Widget;
                                  fontListType: SHORTCARD ): XmFontList;

PROCEDURE _XmConvertCSToString ( cs: XmString ): Xt.String;

PROCEDURE _XmCvtXmStringToCT ( VAR from: Xrm.XrmValue;
                               VAR to: Xrm.XrmValue ): Xt.Boolean;

(********    End Private Function Declarations    ********)
(********    Private Function Declarations for ResInd.c    ********)

TYPE
  XmSyntheticResourcesList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF XmSyntheticResource;

PROCEDURE _XmBuildResources ( VAR wc_resources_ptr: XmSyntheticResourcesList;
                              VAR wc_num_resources_ptr: SYSTEM.int;
                              sc_resources: XmSyntheticResourcesList;
                              sc_num_resources: SYSTEM.int );

PROCEDURE _XmInitializeSyntheticResources ( resources: XmSyntheticResourcesList;
                                            num_resources: SYSTEM.int );

PROCEDURE _XmPrimitiveGetValuesHook ( w: Xt.Widget;
                                      args: Xt.ArgList;
                                      VAR num_args: Xt.Cardinal );

PROCEDURE _XmGadgetGetValuesHook ( w: Xt.Widget;
                                   args: Xt.ArgList;
                                   VAR num_args: Xt.Cardinal );

PROCEDURE _XmManagerGetValuesHook ( w: Xt.Widget;
                                    args: Xt.ArgList;
                                    VAR num_args: Xt.Cardinal );

PROCEDURE _XmExtGetValuesHook ( w: Xt.Widget;
                                args: Xt.ArgList;
                                VAR num_args: Xt.Cardinal );

PROCEDURE _XmExtImportArgs ( w: Xt.Widget;
                             args: Xt.ArgList;
                             VAR num_args: Xt.Cardinal );

PROCEDURE _XmPrimitiveImportArgs ( w: Xt.Widget;
                                   args: Xt.ArgList;
                                   VAR num_args: Xt.Cardinal );

PROCEDURE _XmGadgetImportArgs ( w: Xt.Widget;
                                args: Xt.ArgList;
                                VAR num_args: Xt.Cardinal );

PROCEDURE _XmGadgetImportSecondaryArgs ( w: Xt.Widget;
                                         args: Xt.ArgList;
                                         VAR num_args: Xt.Cardinal );

PROCEDURE _XmManagerImportArgs ( w: Xt.Widget;
                                 args: Xt.ArgList;
                                 VAR num_args: Xt.Cardinal );

PROCEDURE _XmConvertUnits ( screen: Xlib.PtrScreen;
                            dimension: SYSTEM.int;
                            from_type: SYSTEM.int;
                            from_val: SYSTEM.int;
                            to_type: SYSTEM.int ): SYSTEM.int;

PROCEDURE _XmToHorizontalPixels ( widget: Xt.Widget;
                                  offset: SYSTEM.int;
                                  VAR value: Xt.XtArgVal ): XmImportOperator;

PROCEDURE _XmToVerticalPixels ( widget: Xt.Widget;
                                offset: SYSTEM.int;
                                VAR value: Xt.XtArgVal ): XmImportOperator;

PROCEDURE _XmFromHorizontalPixels ( widget: Xt.Widget;
                                    offset: SYSTEM.int;
                                    VAR value: Xt.XtArgVal );

PROCEDURE _XmFromVerticalPixels ( widget: Xt.Widget;
                                  offset: SYSTEM.int;
                                  VAR value: Xt.XtArgVal );

PROCEDURE _XmSortResourceList ( list: Xt.XrmResourceList;
                                len: Xt.Cardinal );

PROCEDURE _XmUnitTypeDefault ( widget: Xt.Widget;
                               offset: SYSTEM.int;
                               VAR value: Xrm.XrmValue );

PROCEDURE _XmGetUnitType ( widget: Xt.Widget ): SHORTCARD;

(********    End Private Function Declarations    ********)
(********    Private Function Declarations for UniqueEvnt.c    ********)

PROCEDURE _XmIsEventUnique ( VAR event: Xlib.XEvent ): Xt.Boolean;

PROCEDURE _XmRecordEvent ( VAR event: Xlib.XEvent );

(********    End Private Function Declarations    ********)
(********    Visual.c    ********)

(*  For the default color calculation and caching  *)

CONST
  XmLOOK_AT_SCREEN = 1;
  XmLOOK_AT_CMAP = 2;
  XmLOOK_AT_BACKGROUND = 4;
  XmLOOK_AT_FOREGROUND = 8;
  XmLOOK_AT_TOP_SHADOW = 16;
  XmLOOK_AT_BOTTOM_SHADOW = 32;
  XmLOOK_AT_SELECT = 64;
  XmBACKGROUND = 1;
  XmFOREGROUND = 2;
  XmTOP_SHADOW = 4;
  XmBOTTOM_SHADOW = 8;
  XmSELECT = 16;

(*   Structure used to hold color schemes   *)

TYPE
  _XmColorData = RECORD
    screen       : Xlib.PtrScreen;
    color_map    : X.Colormap;
    allocated    : SHORTCARD;
    background   : Xlib.XColor;
    foreground   : Xlib.XColor;
    top_shadow   : Xlib.XColor;
    bottom_shadow: Xlib.XColor;
    select       : Xlib.XColor;
  END;

  XmColorData = _XmColorData;

  XmColorDataList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF XmColorData;

  XmColorDataPtr = POINTER TO XmColorData;

(********    Private Function Declarations for Visual.c    ********)

PROCEDURE _XmRegisterPixmapConverters (  );

PROCEDURE _XmGetBGPixmapName (  ): Xt.String;

PROCEDURE _XmClearBGPixmapName (  );

PROCEDURE _XmForegroundColorDefault ( widget: Xt.Widget;
                                      offset: SYSTEM.int;
                                      VAR value: Xrm.XrmValue );

PROCEDURE _XmHighlightColorDefault ( widget: Xt.Widget;
                                     offset: SYSTEM.int;
                                     VAR value: Xrm.XrmValue );

PROCEDURE _XmBackgroundColorDefault ( widget: Xt.Widget;
                                      offset: SYSTEM.int;
                                      VAR value: Xrm.XrmValue );

PROCEDURE _XmTopShadowColorDefault ( widget: Xt.Widget;
                                     offset: SYSTEM.int;
                                     VAR value: Xrm.XrmValue );

PROCEDURE _XmBottomShadowColorDefault ( widget: Xt.Widget;
                                        offset: SYSTEM.int;
                                        VAR value: Xrm.XrmValue );

PROCEDURE _XmSelectColorDefault ( widget: Xt.Widget;
                                  offset: SYSTEM.int;
                                  VAR value: Xrm.XrmValue );

PROCEDURE _XmPrimitiveTopShadowPixmapDefault ( widget: Xt.Widget;
                                               offset: SYSTEM.int;
                                               VAR value: Xrm.XrmValue );

PROCEDURE _XmManagerTopShadowPixmapDefault ( widget: Xt.Widget;
                                             offset: SYSTEM.int;
                                             VAR value: Xrm.XrmValue );

PROCEDURE _XmPrimitiveHighlightPixmapDefault ( widget: Xt.Widget;
                                               offset: SYSTEM.int;
                                               VAR value: Xrm.XrmValue );

PROCEDURE _XmManagerHighlightPixmapDefault ( widget: Xt.Widget;
                                             offset: SYSTEM.int;
                                             VAR value: Xrm.XrmValue );

PROCEDURE _XmGetDefaultThresholdsForScreen ( screen: Xlib.PtrScreen );

PROCEDURE _XmGetDefaultBackgroundColorSpec ( screen: Xlib.PtrScreen ): Xt.String;

PROCEDURE _XmSetDefaultBackgroundColorSpec ( screen: Xlib.PtrScreen;
                                             new_color_spec: Xt.String );

PROCEDURE _XmGetDefaultColors ( screen: Xlib.PtrScreen;
                                color_map: X.Colormap ): XmColorDataList;

PROCEDURE _XmSearchColorCache ( which: CARDINAL;
                                values: XmColorDataList;
                                VAR ret: XmColorDataList ): Xt.Boolean;

PROCEDURE _XmAddToColorCache ( VAR new_rec: XmColorData ): XmColorDataList;

PROCEDURE _XmBlackPixel ( screen: Xlib.PtrScreen;
                          colormap: X.Colormap;
                          blackcolor: Xlib.XColor ): Xt.Pixel;

PROCEDURE _XmWhitePixel ( screen: Xlib.PtrScreen;
                          colormap: X.Colormap;
                          whitecolor: Xlib.XColor ): Xt.Pixel;

PROCEDURE _XmAccessColorData ( cd: XmColorDataList;
                               which: SHORTCARD ): Xt.Pixel;

PROCEDURE _XmGetColors ( screen: Xlib.PtrScreen;
                         color_map: X.Colormap;
                         background: Xt.Pixel ): XmColorDataList;

(********    End Private Function Declarations    ********)
(********    Private Function Declarations for XmString.c    ********)

PROCEDURE _XmGetFirstFont ( entry: XmFontListEntry ): Xlib.PtrXFontStruct;

PROCEDURE _XmFontListGetDefaultFont ( fontlist: XmFontList;
                                      VAR font_struct: Xlib.PtrXFontStruct ): Xt.Boolean;

PROCEDURE _XmFontListSearch ( fontlist: XmFontList;
                              charset: ARRAY OF CHAR;
                              VAR indx: SYSTEM.INT16;
                              VAR font_struct: Xlib.PtrXFontStruct ): Xt.Boolean;

PROCEDURE _XmStringIsXmString ( string: XmString ): Xt.Boolean;

PROCEDURE _XmStringInitContext ( VAR context: XmStringContext;
                                 string: _XmString ): Xt.Boolean;

PROCEDURE _XmStringGetNextSegment ( context: _XmStringContext;
                                    VAR charset: XmStringCharSet;
                                    VAR direction: XmStringDirection;
                                    VAR text: Xt.String;
                                    VAR char_count: SYSTEM.INT16;
                                    VAR separator: CHAR ): Xt.Boolean;

PROCEDURE _XmStringFreeContext ( context: _XmStringContext );

PROCEDURE _XmStringWidth ( fontlist: XmFontList;
                           string: _XmString ): Xt.Dimension;

PROCEDURE _XmStringHeight ( fontlist: XmFontList;
                            string: _XmString ): Xt.Dimension;

PROCEDURE _XmStringExtent ( fontlist: XmFontList;
                            string: _XmString;
                            VAR width: Xt.Dimension;
                            VAR height: Xt.Dimension );

PROCEDURE _XmStringEmpty ( string: _XmString ): Xt.Boolean;

PROCEDURE _XmStringDraw ( d: Xlib.PtrDisplay;
                          w: X.Window;
                          fontlist: XmFontList;
                          string: _XmString;
                          gc: Xlib.GC;
                          x: Xt.Position;
                          y: Xt.Position;
                          width: Xt.Dimension;
                          align: SHORTCARD;
                          lay_dir: SHORTCARD;
                          VAR clip: Xlib.XRectangle );

PROCEDURE _XmStringDrawImage ( d: Xlib.PtrDisplay;
                               w: X.Window;
                               fontlist: XmFontList;
                               string: _XmString;
                               gc: Xlib.GC;
                               x: Xt.Position;
                               y: Xt.Position;
                               width: Xt.Dimension;
                               align: SHORTCARD;
                               lay_dir: SHORTCARD;
                               VAR clip: Xlib.XRectangle );

PROCEDURE _XmStringDrawUnderline ( d: Xlib.PtrDisplay;
                                   w: X.Window;
                                   f: XmFontList;
                                   s: _XmString;
                                   gc: Xlib.GC;
                                   x: Xt.Position;
                                   y: Xt.Position;
                                   width: Xt.Dimension;
                                   align: SHORTCARD;
                                   lay_dir: SHORTCARD;
                                   VAR clip: Xlib.XRectangle;
                                   u: _XmString );

PROCEDURE _XmStringDrawMnemonic ( d: Xlib.PtrDisplay;
                                  w: X.Window;
                                  fontlist: XmFontList;
                                  string: _XmString;
                                  gc: Xlib.GC;
                                  x: Xt.Position;
                                  y: Xt.Position;
                                  width: Xt.Dimension;
                                  align: SHORTCARD;
                                  lay_dir: SHORTCARD;
                                  VAR clip: Xlib.XRectangle;
                                  mnemonic: Xt.String;
                                  charset: ARRAY OF CHAR );

PROCEDURE _XmStringCreate ( cs: XmString ): _XmString;

PROCEDURE _XmStringFree ( string: _XmString );

PROCEDURE _XmStringGetCurrentCharset (  ): XmStringCharSet;

PROCEDURE _XmCharsetCanonicalize ( charset: ARRAY OF CHAR ): XmStringCharSet;

PROCEDURE _XmStringUpdate ( fontlist: XmFontList; string: _XmString );

PROCEDURE _XmStringCopy ( string: _XmString ): _XmString;

PROCEDURE _XmStringByteCompare ( a: _XmString; b: _XmString ): Xt.Boolean;

PROCEDURE _XmStringHasSubstring ( string: _XmString;
                                  substring: _XmString ): Xt.Boolean;

PROCEDURE _XmStringCreateExternal ( fontlist: XmFontList;
                                    cs: _XmString ): XmString;

PROCEDURE _XmStringBaseline ( fontlist: XmFontList;
                              string: _XmString ): Xt.Dimension;

PROCEDURE _XmStringLineCount ( string: _XmString ): SYSTEM.int;

PROCEDURE _XmStringGetTextConcat ( string: XmString ): XmStringCharSet;

PROCEDURE _XmStringIsCurrentCharset ( c: ARRAY OF CHAR ): Xt.Boolean;

PROCEDURE _XmStringSingleSegment ( str: XmString;
                                   VAR pTextOut: Xt.String;
                                   VAR pCharsetOut: ARRAY OF CHAR ): Xt.Boolean;

PROCEDURE _XmStringUpdateWMShellTitle ( xmstr: XmString;
                                        shell: Xt.Widget );

(********    End Private Function Declarations    ********)
(********    Traversal.c    ********)

CONST
  XmTAB_ANY = 255;
  XmNONE_OR_BC = 254;

TYPE
  _XmFocusMovedCallbackStruct = RECORD
    reason      : SYSTEM.int;
    event       : Xlib.PtrXEvent;
    cont        : Xt.Boolean;
    old_focus   : Xt.Widget;
    new_focus   : Xt.Widget;
    focus_policy: SHORTCARD;
  END;

  XmFocusMovedCallbackStruct = _XmFocusMovedCallbackStruct;

  XmFocusMovedCallback = POINTER TO _XmFocusMovedCallbackStruct;

  _XmFocusDataRec = RECORD
    (* Declaration without definition *)
  END;

  XmFocusData = POINTER TO _XmFocusDataRec;

(********    Private Function Declarations for Traversal.c    ********)

PROCEDURE _XmCreateFocusData (  ): XmFocusData;

PROCEDURE _XmDestroyFocusData ( focusData: XmFocusData );

PROCEDURE _XmSetActiveTabGroup ( focusData: XmFocusData;
                                 tabGroup: Xt.Widget );

PROCEDURE _XmGetActiveItem ( w: Xt.Widget ): Xt.Widget;

PROCEDURE _XmNavigInitialize ( request: Xt.Widget;
                               new_wid: Xt.Widget;
                               args: Xt.ArgList;
                               VAR num_args: Xt.Cardinal );

PROCEDURE _XmNavigSetValues ( current: Xt.Widget;
                              request: Xt.Widget;
                              new_wid: Xt.Widget;
                              args: Xt.ArgList;
                              VAR num_args: Xt.Cardinal ): Xt.Boolean;

PROCEDURE _XmNavigChangeManaged ( wid: Xt.Widget );

PROCEDURE _XmNavigResize ( wid: Xt.Widget );

PROCEDURE _XmValidateFocus ( wid: Xt.Widget );

PROCEDURE _XmNavigDestroy ( wid: Xt.Widget );

PROCEDURE _XmCallFocusMoved ( old: Xt.Widget;
                              new_wid: Xt.Widget;
                              VAR event: Xlib.XEvent ): Xt.Boolean;

PROCEDURE _XmMgrTraversal ( wid: Xt.Widget;
                            direction: XmTraversalDirection ): Xt.Boolean;

PROCEDURE _XmClearFocusPath ( wid: Xt.Widget );

PROCEDURE _XmFocusIsHere ( w: Xt.Widget ): Xt.Boolean;

PROCEDURE _XmProcessTraversal ( w: Xt.Widget;
                                dir: XmTraversalDirection;
                                check: Xt.Boolean );

PROCEDURE _XmGetFocusPolicy ( w: Xt.Widget ): SHORTCARD;

PROCEDURE _XmFindTopMostShell ( w: Xt.Widget ): Xt.Widget;

PROCEDURE _XmFocusModelChanged ( wid: Xt.Widget;
                                 client_data: Xt.XtPointer;
                                 call_data: Xt.XtPointer );

PROCEDURE _XmGrabTheFocus ( w: Xt.Widget;
                            VAR event: Xlib.XEvent ): Xt.Boolean;

PROCEDURE _XmGetFocusData ( wid: Xt.Widget ): XmFocusData;

PROCEDURE _XmCreateVisibilityRect ( w: Xt.Widget;
                                    rectPtr: Xlib.PtrXRectangle ): Xt.Boolean;

PROCEDURE _XmSetRect ( VAR rect: Xlib.XRectangle;
                       w: Xt.Widget );

PROCEDURE _XmIntersectRect ( VAR srcRectA: Xlib.XRectangle;
                             widget: Xt.Widget;
                             VAR dstRect: Xlib.XRectangle ): SYSTEM.int;

PROCEDURE _XmEmptyRect ( VAR r: Xlib.XRectangle ): SYSTEM.int;

PROCEDURE _XmClearRect ( VAR r: Xlib.XRectangle );

PROCEDURE _XmIsNavigable ( wid: Xt.Widget ): Xt.Boolean;

PROCEDURE _XmWidgetFocusChange ( wid: Xt.Widget; change: XmFocusChange );

PROCEDURE _XmNavigate ( wid: Xt.Widget;
                        direction: XmTraversalDirection ): Xt.Widget;

PROCEDURE _XmFindNextTabGroup ( wid: Xt.Widget ): Xt.Widget;

PROCEDURE _XmFindPrevTabGroup ( wid: Xt.Widget ): Xt.Widget;

PROCEDURE _XmSetInitialOfTabGroup ( tab_group: Xt.Widget;
                                    init_focus: Xt.Widget );

PROCEDURE _XmResetTravGraph ( wid: Xt.Widget );

PROCEDURE _XmFocusIsInShell ( wid: Xt.Widget ): Xt.Boolean;

PROCEDURE _XmShellIsExclusive ( wid: Xt.Widget ): Xt.Boolean;

PROCEDURE _XmGetFirstFocus ( wid: Xt.Widget ): Xt.Widget;

(********    End Private Function Declarations    ********)
(********    Private Function Declarations for TravAct.c    ********)

PROCEDURE _XmTrackShellFocus ( widget: Xt.Widget;
                               client_data: Xt.XtPointer;
                               VAR event: Xlib.XEvent;
                               VAR dontSwallow: Xt.Boolean );

PROCEDURE _XmPrimitiveEnter ( wid: Xt.Widget;
                              VAR event: Xlib.XEvent;
                              params: Xt.StringList;
                              VAR num_params: Xt.Cardinal );

PROCEDURE _XmPrimitiveLeave ( wid: Xt.Widget;
                              VAR event: Xlib.XEvent;
                              params: Xt.StringList;
                              VAR num_params: Xt.Cardinal );

PROCEDURE _XmPrimitiveUnmap ( pw: Xt.Widget;
                              VAR event: Xlib.XEvent;
                              params: Xt.StringList;
                              VAR num_params: Xt.Cardinal );

PROCEDURE _XmPrimitiveFocusInInternal ( wid: Xt.Widget;
                                        VAR event: Xlib.XEvent;
                                        params: Xt.StringList;
                                        VAR num_params: Xt.Cardinal );

PROCEDURE _XmPrimitiveFocusOut ( wid: Xt.Widget;
                                 VAR event: Xlib.XEvent;
                                 params: Xt.StringList;
                                 VAR num_params: Xt.Cardinal );

PROCEDURE _XmPrimitiveFocusIn ( pw: Xt.Widget;
                                VAR event: Xlib.XEvent;
                                params: Xt.StringList;
                                VAR num_params: Xt.Cardinal );

PROCEDURE _XmEnterGadget ( wid: Xt.Widget;
                           VAR event: Xlib.XEvent;
                           params: Xt.StringList;
                           VAR num_params: Xt.Cardinal );

PROCEDURE _XmLeaveGadget ( wid: Xt.Widget;
                           VAR event: Xlib.XEvent;
                           params: Xt.StringList;
                           VAR num_params: Xt.Cardinal );

PROCEDURE _XmFocusInGadget ( wid: Xt.Widget;
                             VAR event: Xlib.XEvent;
                             params: Xt.StringList;
                             VAR num_params: Xt.Cardinal );

PROCEDURE _XmFocusOutGadget ( wid: Xt.Widget;
                              VAR event: Xlib.XEvent;
                              params: Xt.StringList;
                              VAR num_params: Xt.Cardinal );

PROCEDURE _XmManagerEnter ( wid: Xt.Widget;
                            VAR event_in: Xlib.XEvent;
                            params: Xt.StringList;
                            VAR num_params: Xt.Cardinal );

PROCEDURE _XmManagerLeave ( wid: Xt.Widget;
                            VAR event_in: Xlib.XEvent;
                            params: Xt.StringList;
                            VAR num_params: Xt.Cardinal );

PROCEDURE _XmManagerFocusInInternal ( wid: Xt.Widget;
                                      VAR event: Xlib.XEvent;
                                      params: Xt.StringList;
                                      VAR num_params: Xt.Cardinal );

PROCEDURE _XmManagerFocusIn ( mw: Xt.Widget;
                              VAR event: Xlib.XEvent;
                              params: Xt.StringList;
                              VAR num_params: Xt.Cardinal );

PROCEDURE _XmManagerFocusOut ( wid: Xt.Widget;
                               VAR event: Xlib.XEvent;
                               params: Xt.StringList;
                               VAR num_params: Xt.Cardinal );

PROCEDURE _XmManagerUnmap ( mw: Xt.Widget;
                            VAR event: Xlib.XEvent;
                            params: Xt.StringList;
                            VAR num_params: Xt.Cardinal );

(********    End Private Function Declarations    ********)
(********    Private Function Declarations for GeoUtils.c    ********)

PROCEDURE _XmHandleQueryGeometry ( wid: Xt.Widget;
                                   VAR intended: Xt.XtWidgetGeometry;
                                   VAR desired: Xt.XtWidgetGeometry;
                                   policy: SHORTCARD;
                                   createMatrix: XmGeoCreateProc ): Xt.XtGeometryResult;

TYPE
  XmGeoMatrixPtr = POINTER TO XmGeoMatrix;

  XmGeoMatrixList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF XmGeoMatrix;

PROCEDURE _XmHandleGeometryManager ( wid: Xt.Widget;
                                     instigator: Xt.Widget;
                                     VAR desired: Xt.XtWidgetGeometry;
                                     VAR allowed: Xt.XtWidgetGeometry;
                                     policy: SHORTCARD;
                                     VAR cachePtr: XmGeoMatrix;
                                     createMatrix: XmGeoCreateProc ): Xt.XtGeometryResult;

PROCEDURE _XmHandleSizeUpdate ( wid: Xt.Widget;
                                policy: SHORTCARD;
                                createMatrix: XmGeoCreateProc );

PROCEDURE _XmGeoMatrixAlloc ( numRows: CARDINAL;
                              numBoxes: CARDINAL;
                              extSize: CARDINAL ): XmGeoMatrix;

PROCEDURE _XmGeoMatrixFree ( geo_spec: XmGeoMatrix );

PROCEDURE _XmGeoSetupKid ( geo: XmKidGeometry;
                           kidWid: Xt.Widget ): Xt.Boolean;

PROCEDURE _XmGeoMatrixGet ( geoSpec: XmGeoMatrix; geoType: SYSTEM.int );

PROCEDURE _XmGeoMatrixSet ( geoSpec: XmGeoMatrix );

PROCEDURE _XmGeoAdjustBoxes ( geoSpec: XmGeoMatrix );

PROCEDURE _XmGeoGetDimensions ( geoSpec: XmGeoMatrix );

PROCEDURE _XmGeoArrangeBoxes ( geoSpec: XmGeoMatrix;
                               x: Xt.Position;
                               y: Xt.Position;
                               VAR pW: Xt.Dimension;
                               VAR pH: Xt.Dimension );

PROCEDURE _XmGeoBoxesSameWidth ( rowPtr: XmKidGeometry;
                                 width: Xt.Dimension ): Xt.Dimension;

PROCEDURE _XmGeoBoxesSameHeight ( rowPtr: XmKidGeometry;
                                  height: Xt.Dimension ): Xt.Dimension;

PROCEDURE _XmSeparatorFix ( geoSpec: XmGeoMatrix;
                            action: SYSTEM.int;
                            layoutPtr: XmGeoMajorLayout;
                            rowPtr: XmKidGeometry );

PROCEDURE _XmMenuBarFix ( geoSpec: XmGeoMatrix;
                          action: SYSTEM.int;
                          layoutPtr: XmGeoMajorLayout;
                          rowPtr: XmKidGeometry );

PROCEDURE _XmGeoLoadValues ( wid: Xt.Widget;
                             geoType: SYSTEM.int;
                             instigator: Xt.Widget;
                             VAR request: Xt.XtWidgetGeometry;
                             VAR geoResult: Xt.XtWidgetGeometry );

PROCEDURE _XmGeoCount_kids ( c: Xt.CompositeWidget ): SYSTEM.int;

PROCEDURE _XmGetKidGeo ( wid: Xt.Widget;
                         instigator: Xt.Widget;
                         VAR request: Xt.XtWidgetGeometry;
                         uniform_border: SYSTEM.int;
                         border: Xt.Dimension;
                         uniform_width_margins: SYSTEM.int;
                         uniform_height_margins: SYSTEM.int;
                         help: Xt.Widget;
                         geo_type: SYSTEM.int ): XmKidGeometry;

PROCEDURE _XmGeoClearRectObjAreas ( r: Xt.RectObj;
                                    VAR old: Xlib.XWindowChanges );

PROCEDURE _XmSetKidGeo ( kg: XmKidGeometry;
                         instigator: Xt.Widget );

PROCEDURE _XmGeometryEqual ( wid: Xt.Widget;
                             VAR geoA: Xt.XtWidgetGeometry;
                             VAR geoB: Xt.XtWidgetGeometry ): Xt.Boolean;

PROCEDURE _XmGeoReplyYes ( wid: Xt.Widget;
                           VAR desired: Xt.XtWidgetGeometry;
                           VAR response: Xt.XtWidgetGeometry ): Xt.Boolean;

PROCEDURE _XmMakeGeometryRequest ( w: Xt.Widget;
                                   VAR geom: Xt.XtWidgetGeometry ): Xt.XtGeometryResult;

(********    End Private Function Declarations    ********)
(********    Private Function Declarations for Dest.c    ********)

PROCEDURE _XmSetDestination ( dpy: Xlib.PtrDisplay; w: Xt.Widget );

(********    End Private Function Declarations    ********)
(********    Private Function Declarations for XmIm.c    ********)

PROCEDURE _XmImChangeManaged ( vw: Xt.Widget );

PROCEDURE _XmImRealize ( vw: Xt.Widget );

PROCEDURE _XmImResize ( vw: Xt.Widget );

PROCEDURE _XmImRedisplay ( vw: Xt.Widget );

(********    End Private Function Declarations    ********)
(********    Private Function Declarations for DragBS.c   ********)

PROCEDURE _XmInitAtomPairs ( display: Xlib.PtrDisplay );

PROCEDURE _XmInitTargetsTable ( display: Xlib.PtrDisplay );

PROCEDURE _XmIndexToTargets ( shell: Xt.Widget;
                              t_index: Xt.Cardinal;
                              VAR targetsRtn: X.PAAtom ): Xt.Cardinal;

PROCEDURE _XmTargetsToIndex ( shell: Xt.Widget;
                              VAR targets: X.Atom;
                              numTargets: Xt.Cardinal ): Xt.Cardinal;

PROCEDURE _XmAllocMotifAtom ( shell: Xt.Widget;
                              time: X.Time ): X.Atom;

PROCEDURE _XmFreeMotifAtom ( shell: Xt.Widget; atom: X.Atom );

PROCEDURE _XmDestroyMotifWindow ( dpy: Xlib.PtrDisplay );

PROCEDURE _XmGetDragProxyWindow ( display: Xlib.PtrDisplay ): X.Window;

(********    End Private Function Declarations    ********)
(********    Private Function Declarations for DragOverS.c    ********)

PROCEDURE _XmDragOverHide ( w: Xt.Widget;
                            clipOriginX: Xt.Position;
                            clipOriginY: Xt.Position;
                            clipRegion: XmRegion );

PROCEDURE _XmDragOverShow ( w: Xt.Widget;
                            clipOriginX: Xt.Position;
                            clipOriginY: Xt.Position;
                            clipRegion: XmRegion );

PROCEDURE _XmDragOverMove ( w: Xt.Widget;
                            x: Xt.Position;
                            y: Xt.Position );

PROCEDURE _XmDragOverChange ( w: Xt.Widget;
                              dropSiteStatus: SHORTCARD );

PROCEDURE _XmDragOverFinish ( w: Xt.Widget;
                              completionStatus: SHORTCARD );

PROCEDURE _XmDragOverGetActiveCursor ( w: Xt.Widget ): X.Cursor;

PROCEDURE _XmDragOverSetInitialPosition ( w: Xt.Widget;
                                          initialX: Xt.Position;
                                          initialY: Xt.Position );

(********    End Private Function Declarations    ********)
(********    Private Function Declarations for Region.c    ********)

PROCEDURE _XmRegionCreate (  ): XmRegion;

PROCEDURE _XmRegionCreateSize ( size: LONGINT ): XmRegion;

PROCEDURE _XmRegionComputeExtents ( r: XmRegion );

PROCEDURE _XmRegionGetExtents ( r: XmRegion; VAR rect: Xlib.XRectangle );

PROCEDURE _XmRegionUnionRectWithRegion ( VAR rect: Xlib.XRectangle;
                                         source: XmRegion;
                                         dest: XmRegion );

PROCEDURE _XmRegionIntersectRectWithRegion ( VAR rect: Xlib.XRectangle;
                                             source: XmRegion;
                                             dest: XmRegion );

PROCEDURE _XmRegionGetNumRectangles ( r: XmRegion ): LONGINT;

PROCEDURE _XmRegionGetRectangles ( r: XmRegion;
                                   VAR rects: Xlib.PAXRectangle;
                                   VAR nrects: LONGINT );

PROCEDURE _XmRegionSetGCRegion ( dpy: Xlib.PtrDisplay;
                                 gc: Xlib.GC;
                                 x_origin: SYSTEM.int;
                                 y_origin: SYSTEM.int;
                                 r: XmRegion );

PROCEDURE _XmRegionDestroy ( r: XmRegion );

PROCEDURE _XmRegionOffset ( pRegion: XmRegion;
                            x: SYSTEM.int;
                            y: SYSTEM.int );

PROCEDURE _XmRegionIntersect ( reg1: XmRegion;
                               reg2: XmRegion;
                               newReg: XmRegion );

PROCEDURE _XmRegionUnion ( reg1: XmRegion;
                           reg2: XmRegion;
                           newReg: XmRegion );

PROCEDURE _XmRegionSubtract ( regM: XmRegion;
                              regS: XmRegion;
                              regD: XmRegion );

PROCEDURE _XmRegionIsEmpty ( r: XmRegion ): Xt.Boolean;

PROCEDURE _XmRegionEqual ( r1: XmRegion;
                           r2: XmRegion ): Xt.Boolean;

PROCEDURE _XmRegionPointInRegion ( pRegion: XmRegion;
                                   x: SYSTEM.int;
                                   y: SYSTEM.int ): Xt.Boolean;

PROCEDURE _XmRegionClear ( r: XmRegion );

PROCEDURE _XmRegionShrink ( r: XmRegion;
                            dx: SYSTEM.int;
                            dy: SYSTEM.int );

PROCEDURE _XmRegionDrawShadow ( display: Xlib.PtrDisplay;
                                d: X.Drawable;
                                top_gc: Xlib.GC;
                                bottom_gc: Xlib.GC;
                                region: XmRegion;
                                border_thick: Xt.Dimension;
                                shadow_thick: Xt.Dimension;
                                shadow_type: CARDINAL );

(********    End Private Function Declarations    ********)
(********    Private Function Declarations for DragUnder.c    ********)

PROCEDURE _XmDragUnderAnimation ( w: Xt.Widget;
                                  clientData: Xt.XtPointer;
                                  callData: Xt.XtPointer );

(********    End Private Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/ExtObjectP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

CONST
  XmCACHE_EXTENSION = 1;
  XmDESKTOP_EXTENSION = 2;
  XmSHELL_EXTENSION = 3;
  XmPROTOCOL_EXTENSION = 4;
  XmDEFAULT_EXTENSION = 5;

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE XmIsExtObject ( w: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / XmIsExtObject ( w: Xt.Widget ): Xt.Boolean;

<* END *>

(*  Class record constants  *)

TYPE
  XmExtObject = POINTER TO _XmExtRec;

  XmExtObjectClass = POINTER TO _XmExtClassRec;

VAR
  xmExtObjectClass: Xt.WidgetClass;

CONST
  XmNUM_ELEMENTS = 4;
  XmNUM_BYTES = 99;

(*  Class Extension definitions  *)

TYPE
  _XmExtClassPart = RECORD
    syn_resources    : XmSyntheticResourcesList;
    num_syn_resources: SYSTEM.int;
    extension        : Xt.XtPointer;
  END;

  XmExtClassPart = _XmExtClassPart;

  XmExtClassPartPtr = POINTER TO _XmExtClassPart;

  _XmExtClassRec = RECORD
    object_class: Xt.ObjectClassPart;
    ext_class   : XmExtClassPart;
  END;

  XmExtClassRec = _XmExtClassRec;

  _XmExtPart = RECORD
    logicalParent: Xt.Widget;
    extensionType: SHORTCARD;
  END;

  XmExtPart = POINTER TO _XmExtPart;

  XmExtPartPtr = POINTER TO _XmExtPart;

  _XmExtRec = RECORD
    object: Xt.ObjectPart;
    ext   : XmExtPart;
  END;

  XmExtRec = _XmExtRec;

  _XmExtCache = RECORD
    data : ARRAY [0..XmNUM_BYTES-1] OF CHAR;
    inuse: Xt.Boolean;
  END;

  XmExtCache = _XmExtCache;

VAR
  xmExtClassRec: XmExtClassRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmExtObjAlloc ( size: SYSTEM.int ): Xt.XtPointer;

PROCEDURE _XmExtObjFree ( element: Xt.XtPointer );

PROCEDURE _XmBuildExtResources ( c: Xt.WidgetClass );

(********    End Private Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/DesktopP.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE XmIsDesktopObject ( w: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / XmIsDesktopObject ( w: Xt.Widget ): Xt.Boolean;

<* END *>

TYPE
  XmDesktopObject = POINTER TO _XmDesktopRec;

  XmDesktopObjectClass = POINTER TO _XmDesktopClassRec;

  _XmDesktopClassPart = RECORD
    child_class : Xt.WidgetClass;
    insert_child: Xt.XtWidgetProc;   (*  physically add child to parent   *)
    delete_child: Xt.XtWidgetProc;   (*  physically remove child          *)
    extension   : Xt.XtPointer;
  END;

  XmDesktopClassPart = _XmDesktopClassPart;

  XmDesktopClassPartPtr = POINTER TO _XmDesktopClassPart;

  _XmDesktopClassRec = RECORD
    object_class : Xt.ObjectClassPart;
    ext_class    : XmExtClassPart;
    desktop_class: XmDesktopClassPart;
  END;

  XmDesktopClassRec = _XmDesktopClassRec;

  _XmDesktopPart = RECORD
    parent      : Xt.Widget;
    children    : Xt.WidgetList;
    num_children: Xt.Cardinal;
    num_slots   : Xt.Cardinal;
  END;

  XmDesktopPart = _XmDesktopPart;

  XmDesktopPartPtr = POINTER TO _XmDesktopPart;

  _XmDesktopRec = RECORD
    object : Xt.ObjectPart;
    ext    : XmExtPart;
    desktop: XmDesktopPart;
  END;

  XmDesktopRec = _XmDesktopRec;

VAR
  xmDesktopClass: Xt.WidgetClass;

  xmDesktopClassRec: XmDesktopClassRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmGetActualClass ( display: Xlib.PtrDisplay;
                              w_class: Xt.WidgetClass ): Xt.WidgetClass;

PROCEDURE _XmSetActualClass ( display: Xlib.PtrDisplay;
                              w_class: Xt.WidgetClass;
                              actualClass: Xt.WidgetClass );

(********    End Private Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/VendorSP.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2.1
 *)

VAR
  vendorShellClassRec: ShellP.VendorShellClassRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmFilterResources ( resources: Xt.XtResourceList;
                               numResources: Xt.Cardinal;
                               filterClass: Xt.WidgetClass;
                               VAR filteredResourcesRtn: Xt.XtResourceList ): Xt.Cardinal;

PROCEDURE _XmAddGrab ( wid: Xt.Widget;
                       exclusive: Xt.Boolean;
                       spring_loaded: Xt.Boolean );

PROCEDURE _XmRemoveGrab ( wid: Xt.Widget );

PROCEDURE _XmRootGeometryManager ( w: Xt.Widget;
                                   VAR request: Xt.XtWidgetGeometry;
                                   VAR reply: Xt.XtWidgetGeometry ): Xt.XtGeometryResult;

PROCEDURE _XmVendorExtRealize ( w: Xt.Widget;
                                closure: Xt.XtPointer;
                                call_data: Xt.XtPointer );

PROCEDURE _XmGetDefaultDisplay (  ): Xlib.PtrDisplay;

(********    End Private Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/ManagerP.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2.4
 *)

CONST
  XmManagerClassExtVersion = 1;

TYPE
  XmTraversalChildrenProc = PROCEDURE ( Xt.Widget,
                                        VAR Xt.WidgetList,
                                      	VAR Xt.Cardinal ): Xt.Boolean;

(*  Structure used for storing accelerator and mnemonic information.  *)

  XmKeyboardData = RECORD
    eventType : CARDINAL;
    keysym    : X.KeySym;
    key       : X.KeyCode;
    modifiers : CARDINAL;
    component : Xt.Widget;
    needGrab  : Xt.Boolean;
    isMnemonic: Xt.Boolean;
  END;

  XmKeyboardDataList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF XmKeyboardData;

(*  The class definition  *)

  _XmManagerClassExtRec = RECORD
    next_extension    : Xt.XtPointer;
    record_type       : Xrm.XrmQuark;
    version           : LONGINT;
    record_size       : Xt.Cardinal;
    traversal_children: XmTraversalChildrenProc;
  END;

  XmManagerClassExtRec = _XmManagerClassExtRec;

  XmManagerClassExt = POINTER TO _XmManagerClassExtRec;

  _XmManagerClassPart = RECORD
    translations                : Xt.String;
    syn_resources               : XmSyntheticResourcesList;
    num_syn_resources           : SYSTEM.int;
    syn_constraint_resources    : XmSyntheticResourcesList;
    num_syn_constraint_resources: SYSTEM.int;
    parent_process              : XmParentProcessProc;
    extension                   : Xt.XtPointer;
  END;

  XmManagerClassPart = _XmManagerClassPart;

  _XmManagerClassRec = RECORD
    core_class      : Xt.CoreClassPart;
    composite_class : Xt.CompositeClassPart;
    constraint_class: Xt.ConstraintClassPart;
    manager_class   : XmManagerClassPart;
  END;

  XmManagerClassRec = _XmManagerClassRec;

(*   The instance definition   *)

  _XmManagerPart = RECORD
    foreground                     : Xt.Pixel;
    shadow_thickness               : Xt.Dimension;
    top_shadow_color               : Xt.Pixel;
    top_shadow_pixmap              : X.Pixmap;
    bottom_shadow_color            : Xt.Pixel;
    bottom_shadow_pixmap           : X.Pixmap;
    highlight_color                : Xt.Pixel;
    highlight_pixmap               : X.Pixmap;
    help_callback                  : Xt.XtCallbackList;
    user_data                      : Xt.XtPointer;
    traversal_on                   : Xt.Boolean;
    unit_type                      : SHORTCARD;
    navigation_type                : XmNavigationType;
    event_handler_added            : Xt.Boolean;
    active_child                   : Xt.Widget;
    highlighted_widget             : Xt.Widget;
    accelerator_widget             : Xt.Widget;
    has_focus                      : Xt.Boolean;
    string_direction               : XmStringDirection;
    keyboard_list                  : XmKeyboardDataList;
    num_keyboard_entries           : SYSTEM.INT16;
    size_keyboard_list             : SYSTEM.INT16;
    selected_gadget                : XmGadget;
    eligible_for_multi_button_event: XmGadget;
    background_GC                  : Xlib.GC;
    highlight_GC                   : Xlib.GC;
    top_shadow_GC                  : Xlib.GC;
    bottom_shadow_GC               : Xlib.GC;
    initial_focus                  : Xt.Widget;
  END;

  XmManagerPart = _XmManagerPart;

  _XmManagerRec = RECORD
    core      : Xt.CorePart;
    composite : Xt.CompositePart;
    constraint: Xt.ConstraintPart;
    manager   : XmManagerPart;
  END;

  XmManagerRec = _XmManagerRec;

(*   The constraint definition   *)

  _XmManagerConstraintPart = RECORD
    unused: SYSTEM.int;
  END;

  XmManagerConstraintPart = _XmManagerConstraintPart;

  _XmManagerConstraintRec = RECORD
    manager: XmManagerConstraintPart;
  END;

  XmManagerConstraintRec = _XmManagerConstraintRec;

  XmManagerConstraintPtr = POINTER TO _XmManagerConstraintRec;

VAR
  xmManagerClassRec: XmManagerClassRec;

(*   Access Macros   *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE XmParentTopShadowGC ( w: Xt.Widget ): Xlib.GC;
PROCEDURE XmParentBottomShadowGC ( w: Xt.Widget ): Xlib.GC;
PROCEDURE XmParentHighlightGC ( w: Xt.Widget ): Xlib.GC;
PROCEDURE XmParentBackgroundGC ( w: Xt.Widget ): Xlib.GC;
PROCEDURE MGR_KeyboardList ( m: Xt.Widget ): XmKeyboardDataList;
PROCEDURE MGR_NumKeyboardEntries ( m: Xt.Widget ): SYSTEM.INT16;
PROCEDURE MGR_SizeKeyboardList ( m: Xt.Widget ): SYSTEM.INT16;
PROCEDURE MGR_ShadowThickness ( m: Xt.Widget ): Xt.Dimension;

<* ELSE *>

PROCEDURE  / XmParentTopShadowGC ( w: Xt.Widget ): Xlib.GC;
PROCEDURE  / XmParentBottomShadowGC ( w: Xt.Widget ): Xlib.GC;
PROCEDURE  / XmParentHighlightGC ( w: Xt.Widget ): Xlib.GC;
PROCEDURE  / XmParentBackgroundGC ( w: Xt.Widget ): Xlib.GC;
PROCEDURE  / MGR_KeyboardList ( m: Xt.Widget ): XmKeyboardDataList;
PROCEDURE  / MGR_NumKeyboardEntries ( m: Xt.Widget ): SYSTEM.INT16;
PROCEDURE  / MGR_SizeKeyboardList ( m: Xt.Widget ): SYSTEM.INT16;
PROCEDURE  / MGR_ShadowThickness ( m: Xt.Widget ): Xt.Dimension;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmGadgetTraversePrevTabGroup ( wid: Xt.Widget;
                                          VAR event: Xlib.XEvent;
                                          params: Xt.StringList;
                                          VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetTraverseNextTabGroup ( wid: Xt.Widget;
                                          VAR event: Xlib.XEvent;
                                          params: Xt.StringList;
                                          VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetTraverseLeft ( wid: Xt.Widget;
                                  VAR event: Xlib.XEvent;
                                  params: XmStringCharSetTable;
                                  VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetTraverseRight ( wid: Xt.Widget;
                                   VAR event: Xlib.XEvent;
                                   params: Xt.StringList;
                                   VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetTraverseUp ( wid: Xt.Widget;
                                VAR event: Xlib.XEvent;
                                params: Xt.StringList;
                                VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetTraverseDown ( wid: Xt.Widget;
                                  VAR event: Xlib.XEvent;
                                  params: Xt.StringList;
                                  VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetTraverseNext ( wid: Xt.Widget;
                                  VAR event: Xlib.XEvent;
                                  params: Xt.StringList;
                                  VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetTraversePrev ( wid: Xt.Widget;
                                  VAR event: Xlib.XEvent;
                                  params: Xt.StringList;
                                  VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetTraverseHome ( wid: Xt.Widget;
                                  VAR event: Xlib.XEvent;
                                  params: Xt.StringList;
                                  VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetSelect ( wid: Xt.Widget;
                            VAR event: Xlib.XEvent;
                            params: Xt.StringList;
                            VAR num_params: Xt.Cardinal );

PROCEDURE _XmManagerParentActivate ( mw: Xt.Widget;
                                     VAR event: Xlib.XEvent;
                                     params: Xt.StringList;
                                     VAR num_params: Xt.Cardinal );

PROCEDURE _XmManagerParentCancel ( mw: Xt.Widget;
                                   VAR event: Xlib.XEvent;
                                   params: Xt.StringList;
                                   VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetButtonMotion ( wid: Xt.Widget;
                                  VAR event: Xlib.XEvent;
                                  params: Xt.StringList;
                                  VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetKeyInput ( wid: Xt.Widget;
                              VAR event: Xlib.XEvent;
                              params: Xt.StringList;
                              VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetArm ( wid: Xt.Widget;
                         VAR event: Xlib.XEvent;
                         params: Xt.StringList;
                         VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetDrag ( wid: Xt.Widget;
                          VAR event: Xlib.XEvent;
                          params: Xt.StringList;
                          VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetActivate ( wid: Xt.Widget;
                              VAR event: Xlib.XEvent;
                              params: Xt.StringList;
                              VAR num_params: Xt.Cardinal );

PROCEDURE _XmManagerHelp ( wid: Xt.Widget;
                           VAR event: Xlib.XEvent;
                           params: Xt.StringList;
                           VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetMultiArm ( wid: Xt.Widget;
                              VAR event: Xlib.XEvent;
                              params: Xt.StringList;
                              VAR num_params: Xt.Cardinal );

PROCEDURE _XmGadgetMultiActivate ( wid: Xt.Widget;
                                   VAR event: Xlib.XEvent;
                                   params: Xt.StringList;
                                   VAR num_params: Xt.Cardinal );

PROCEDURE _XmSocorro ( w: Xt.Widget;
                       VAR event: Xlib.XEvent;
                       params: Xt.StringList;
                       VAR num_params: Xt.Cardinal );

PROCEDURE _XmParentProcess ( widget: Xt.Widget;
                             data: XmParentProcessData ): Xt.Boolean;

PROCEDURE _XmClearShadowType ( w: Xt.Widget;
                               old_width: Xt.Dimension;
                               old_height: Xt.Dimension;
                               old_shadow_thickness: Xt.Dimension;
                               old_highlight_thickness: Xt.Dimension );

PROCEDURE _XmDestroyParentCallback ( w: Xt.Widget;
                                     client_data: Xt.XtPointer;
                                     call_data: Xt.XtPointer );

(********    End Private Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/PrimitiveP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2.1
 *)

CONST
  XmPrimitiveClassExtVersion = 1;

TYPE
  _XmPrimitiveClassExtRec = RECORD
    next_extension     : Xt.XtPointer;
    record_type        : Xrm.XrmQuark;
    version            : LONGINT;
    record_size        : Xt.Cardinal;
    widget_baseline    : XmWidgetBaselineProc;
    widget_display_rect: XmWidgetDisplayRectProc;
    widget_margins     : XmWidgetMarginsProc;
  END;

  XmPrimitiveClassExtRec = _XmPrimitiveClassExtRec;

  XmPrimitiveClassExt = POINTER TO _XmPrimitiveClassExtRec;

  XmPrimitiveClassExtPtr = POINTER TO XmPrimitiveClassExt;

  _XmPrimitiveClassPart = RECORD
    border_highlight  : Xt.XtWidgetProc;
    border_unhighlight: Xt.XtWidgetProc;
    translations      : Xt.String;
    arm_and_activate  : Xt.XtActionProc;
    syn_resources     : XmSyntheticResourcesList;
    num_syn_resources : SYSTEM.int;
    extension         : Xt.XtPointer;
  END;

  XmPrimitiveClassPart = _XmPrimitiveClassPart;

  _XmPrimitiveClassRec = RECORD
    core_class     : Xt.CoreClassPart;
    primitive_class: XmPrimitiveClassPart;
  END;

  XmPrimitiveClassRec = _XmPrimitiveClassRec;

(*   The Primitive instance record   *)

  _XmPrimitivePart = RECORD
    foreground          : Xt.Pixel;
    shadow_thickness    : Xt.Dimension;
    top_shadow_color    : Xt.Pixel;
    top_shadow_pixmap   : X.Pixmap;
    bottom_shadow_color : Xt.Pixel;
    bottom_shadow_pixmap: X.Pixmap;
    highlight_thickness : Xt.Dimension;
    highlight_color     : Xt.Pixel;
    highlight_pixmap    : X.Pixmap;
    help_callback       : Xt.XtCallbackList;
    user_data           : Xt.XtPointer;
    traversal_on        : Xt.Boolean;
    highlight_on_enter  : Xt.Boolean;
    have_traversal      : Xt.Boolean;
    unit_type           : SHORTCARD;
    navigation_type     : XmNavigationType;
    highlight_drawn     : Xt.Boolean;
    highlighted         : Xt.Boolean;
    highlight_GC        : Xlib.GC;
    top_shadow_GC       : Xlib.GC;
    bottom_shadow_GC    : Xlib.GC;
  END;

  XmPrimitivePart = _XmPrimitivePart;

  _XmPrimitiveRec = RECORD
    core     : Xt.CorePart;
    primitive: XmPrimitivePart;
  END;

  XmPrimitiveRec = _XmPrimitiveRec;

VAR
  xmPrimitiveClassRec: XmPrimitiveClassRec;

(*  Access Macros  *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE Prim_ShadowThickness ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE Prim_HaveTraversal ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE PCEPTR ( wc: Xt.WidgetClass ): XmPrimitiveClassExtPtr;
PROCEDURE _XmGetPrimitiveClassExtPtr ( wc, owner: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / Prim_ShadowThickness ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / Prim_HaveTraversal ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / PCEPTR ( wc: Xt.WidgetClass ): XmPrimitiveClassExtPtr;
PROCEDURE  / _XmGetPrimitiveClassExtPtr ( wc, owner: Xt.Widget ): Xt.Boolean;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmTraverseLeft ( w: Xt.Widget;
                            VAR event: Xlib.XEvent;
                            params: Xt.StringList;
                            VAR num_params: Xt.Cardinal );

PROCEDURE _XmTraverseRight ( w: Xt.Widget;
                             VAR event: Xlib.XEvent;
                             params: Xt.StringList;
                             VAR num_params: Xt.Cardinal );

PROCEDURE _XmTraverseUp ( w: Xt.Widget;
                          VAR event: Xlib.XEvent;
                          params: Xt.StringList;
                          VAR num_params: Xt.Cardinal );

PROCEDURE _XmTraverseDown ( w: Xt.Widget;
                            VAR event: Xlib.XEvent;
                            params: Xt.StringList;
                            VAR num_params: Xt.Cardinal );

PROCEDURE _XmTraverseNext ( w: Xt.Widget;
                            VAR event: Xlib.XEvent;
                            params: Xt.StringList;
                            VAR num_params: Xt.Cardinal );

PROCEDURE _XmTraversePrev ( w: Xt.Widget;
                            VAR event: Xlib.XEvent;
                            params: Xt.StringList;
                            VAR num_params: Xt.Cardinal );

PROCEDURE _XmTraverseHome ( w: Xt.Widget;
                            VAR event: Xlib.XEvent;
                            params: Xt.StringList;
                            VAR num_params: Xt.Cardinal );

PROCEDURE _XmTraverseNextTabGroup ( w: Xt.Widget;
                                    VAR event: Xlib.XEvent;
                                    params: Xt.StringList;
                                    VAR num_params: Xt.Cardinal );

PROCEDURE _XmTraversePrevTabGroup ( w: Xt.Widget;
                                    VAR event: Xlib.XEvent;
                                    params: Xt.StringList;
                                    VAR num_params: Xt.Cardinal );

PROCEDURE _XmPrimitiveHelp ( wid: Xt.Widget;
                             VAR event: Xlib.XEvent;
                             params: Xt.StringList;
                             VAR num_params: Xt.Cardinal );

PROCEDURE _XmPrimitiveParentActivate ( pw: Xt.Widget;
                                       VAR event: Xlib.XEvent;
                                       params: Xt.StringList;
                                       VAR num_params: Xt.Cardinal );

PROCEDURE _XmPrimitiveParentCancel ( pw: Xt.Widget;
                                     VAR event: Xlib.XEvent;
                                     params: Xt.StringList;
                                     VAR num_params: Xt.Cardinal );

PROCEDURE _XmDifferentBackground ( w: Xt.Widget;
                                   parent: Xt.Widget ): Xt.Boolean;

(********    End Private Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/GadgetP.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2.4
 *)

(*  Masks to define input the gadget is interested in  *)

CONST
  XmNO_EVENT = 0H;
  XmENTER_EVENT = 1H;
  XmLEAVE_EVENT = 2H;
  XmFOCUS_IN_EVENT = 4H;
  XmFOCUS_OUT_EVENT = 8H;
  XmMOTION_EVENT = 10H;
  XmARM_EVENT = 20H;
  XmACTIVATE_EVENT = 40H;
  XmHELP_EVENT = 80H;
  XmKEY_EVENT = 100H;
  XmMULTI_ARM_EVENT = 200H;
  XmMULTI_ACTIVATE_EVENT = 400H;
  XmBDRAG_EVENT = 800H;
  XmALL_EVENT = 0FFFH;

  XmGadgetClassExtVersion = 1;

(*  Gadget cache header for each gadget's Cache Part  *)

TYPE
  XmGadgetCachePtr = POINTER TO _XmGadgetCache;

  _XmGadgetCache = RECORD
    next     : XmGadgetCachePtr;
    prev     : XmGadgetCachePtr;
    ref_count: SYSTEM.int;
  END;

  XmGadgetCache = _XmGadgetCache;

(*  A cache entry for each class which desires gadget caching  *)

  _XmCacheClassPart = RECORD
    cache_head   : XmGadgetCache;
    cache_copy   : XmCacheCopyProc;
    cache_delete : XmGadgetCacheProc;
    cache_compare: XmCacheCompareProc;
  END;

  XmCacheClassPart = _XmCacheClassPart;

  XmCacheClassPartPtr = POINTER TO _XmCacheClassPart;

(*  A struct for properly aligning the data part of the cache entry.  *)

  _XmGadgetCacheRef = RECORD
    cache: XmGadgetCache;
    data : Xt.XtArgVal;
  END;

  XmGadgetCacheRef = _XmGadgetCacheRef;

  XmGadgetCacheRefPtr = POINTER TO _XmGadgetCacheRef;

(*   Gadget class structure   *)

  _XmGadgetClassExtRec = RECORD
    next_extension     : Xt.XtPointer;
    record_type        : Xrm.XrmQuark;
    version            : LONGINT;
    record_size        : Xt.Cardinal;
    widget_baseline    : XmWidgetBaselineProc;
    widget_display_rect: XmWidgetDisplayRectProc;
  END;

  XmGadgetClassExtRec = _XmGadgetClassExtRec;

  XmGadgetClassExt = POINTER TO _XmGadgetClassExtRec;

  XmGadgetClassExtPtr = POINTER TO XmGadgetClassExt;

  _XmGadgetClassPart = RECORD
    border_highlight  : Xt.XtWidgetProc;
    border_unhighlight: Xt.XtWidgetProc;
    arm_and_activate  : Xt.XtActionProc;
    input_dispatch    : XmWidgetDispatchProc;
    visual_change     : XmVisualChangeProc;
    syn_resources     : XmSyntheticResourcesList;
    num_syn_resources : SYSTEM.int;
    cache_part        : XmCacheClassPartPtr;
    extension         : Xt.XtPointer;
  END;

  XmGadgetClassPart = _XmGadgetClassPart;

(*   Full class record declaration for Gadget class   *)

  _XmGadgetClassRec = RECORD
    rect_class  : Xt.RectObjClassPart;
    gadget_class: XmGadgetClassPart;
  END;

  XmGadgetClassRec = _XmGadgetClassRec;

(*   The Gadget instance record   *)

  _XmGadgetPart = RECORD
    shadow_thickness   : Xt.Dimension;
    highlight_thickness: Xt.Dimension;
    help_callback      : Xt.XtCallbackList;
    user_data          : Xt.XtPointer;
    traversal_on       : Xt.Boolean;
    highlight_on_enter : Xt.Boolean;
    have_traversal     : Xt.Boolean;
    unit_type          : SHORTCARD;
    navigation_type    : XmNavigationType;
    highlight_drawn    : Xt.Boolean;
    highlighted        : Xt.Boolean;
    visible            : Xt.Boolean;
    event_mask         : X.Mask;
  END;

  XmGadgetPart = _XmGadgetPart;

(*   Full instance record declaration   *)

  _XmGadgetRec = RECORD
    object   : Xt.ObjectPart;
    rectangle: Xt.RectObjPart;
    gadget   : XmGadgetPart;
  END;

  XmGadgetRec = _XmGadgetRec;

VAR
  xmGadgetClassRec: XmGadgetClassRec;

(*  Gadget access Macros  *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE G_ShadowThickness ( g: Xt.Widget ): Xt.Dimension;
PROCEDURE G_HighlightThickness ( g: Xt.Widget ): Xt.Dimension;
PROCEDURE GCEPTR ( wc: Xt.WidgetClass ): XmGadgetClassExtPtr;
PROCEDURE _XmGetGadgetClassExtPtr ( wc: Xt.WidgetClass;
                                    owner: Xrm.XrmQuark ): XmGadgetClassExtPtr;

<* ELSE *>

PROCEDURE  / G_ShadowThickness ( g: Xt.Widget ): Xt.Dimension;
PROCEDURE  / G_HighlightThickness ( g: Xt.Widget ): Xt.Dimension;
PROCEDURE  / GCEPTR ( wc: Xt.WidgetClass ): XmGadgetClassExtPtr;
PROCEDURE  / _XmGetGadgetClassExtPtr ( wc: Xt.WidgetClass;
                                       owner: Xrm.XrmQuark ): XmGadgetClassExtPtr;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmBuildGadgetResources ( c: Xt.WidgetClass );

(********    End Private Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/BaseClassP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

CONST
  XmBaseClassExtVersion = 2;

TYPE
  XmGetSecResDataFunc = PROCEDURE ( Xt.WidgetClass,
				    VAR XmSecondaryResourceDataPtr ): Xt.Cardinal;

  _XmObjectClassExtRec = RECORD
    next_extension: Xt.XtPointer;
    record_type   : Xrm.XrmQuark;
    version       : LONGINT;
    record_size   : Xt.Cardinal;
  END;

  XmObjectClassExtRec = _XmObjectClassExtRec;

  XmObjectClassExt = POINTER TO _XmObjectClassExtRec;

  _XmGenericClassExtRec = RECORD
    next_extension: Xt.XtPointer;
    record_type   : Xrm.XrmQuark;
    version       : LONGINT;
    record_size   : Xt.Cardinal;
  END;

  XmGenericClassExtRec = _XmGenericClassExtRec;

  XmGenericClassExt = POINTER TO _XmGenericClassExtRec;

  XmGenericClassExtPtr = POINTER TO XmGenericClassExt;

  XmWrapperDataPtr = POINTER TO _XmWrapperDataRec;

  _XmWrapperDataRec = RECORD
    next             : XmWrapperDataPtr;
    widgetClass      : Xt.WidgetClass;
    initializeLeaf   : Xt.XtInitProc;
    setValuesLeaf    : Xt.XtSetValuesFunc;
    getValuesLeaf    : Xt.XtArgsProc;
    realize          : Xt.XtRealizeProc;
    classPartInitLeaf: Xt.XtWidgetClassProc;
    resize           : Xt.XtWidgetProc;
    geometry_manager : Xt.XtGeometryHandler;
    init_depth       : Xt.Cardinal;
  END;

  XmWrapperDataRec = _XmWrapperDataRec;

  XmWrapperData = POINTER TO XmWrapperDataRec;

  _XmBCEFlags = ARRAY [0..31] OF SET8;

  _XmBaseClassExtRec = RECORD
    next_extension        : Xt.XtPointer;
    record_type           : Xrm.XrmQuark;
    version               : LONGINT;
    record_size           : Xt.Cardinal;
    initializePrehook     : Xt.XtInitProc;
    setValuesPrehook      : Xt.XtSetValuesFunc;
    initializePosthook    : Xt.XtInitProc;
    setValuesPosthook     : Xt.XtSetValuesFunc;
    secondaryObjectClass  : Xt.WidgetClass;
    secondaryObjectCreate : Xt.XtInitProc;
    getSecResData         : XmGetSecResDataFunc;
    flags                 : _XmBCEFlags;
    getValuesPrehook      : Xt.XtArgsProc;
    getValuesPosthook     : Xt.XtArgsProc;
    classPartInitPrehook  : Xt.XtWidgetClassProc;
    classPartInitPosthook : Xt.XtWidgetClassProc;
    ext_resources         : Xt.XtResourceList;
    compiled_ext_resources: Xt.XtResourceList;
    num_ext_resources     : Xt.Cardinal;
    use_sub_resources     : Xt.Boolean;
    widgetNavigable       : XmWidgetNavigableProc;
    focusChange           : XmFocusChangeProc;
    wrapperData           : XmWrapperData;
  END;

  XmBaseClassExtRec = _XmBaseClassExtRec;

  XmBaseClassExt = POINTER TO _XmBaseClassExtRec;

  _XmWidgetExtDataRec = RECORD
    widget   : Xt.Widget;
    reqWidget: Xt.Widget;
    oldWidget: Xt.Widget;
  END;

  XmWidgetExtDataRec = _XmWidgetExtDataRec;

  XmWidgetExtData = POINTER TO _XmWidgetExtDataRec;

VAR
  XmQmotif: Xrm.XrmQuark;
  _XmInheritClass: SYSTEM.int;

TYPE
  XmBaseClassExtPtr = POINTER TO XmBaseClassExt;

VAR
  _Xm_fastPtr: XmBaseClassExtPtr;

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE _XmBCEPTR ( wc: Xt.WidgetClass ): XmBaseClassExtPtr;
PROCEDURE _XmBCE ( wc: Xt.WidgetClass ): XmBaseClassExt;
PROCEDURE _XmGetBaseClassExtPtr ( wc: Xt.WidgetClass;
                                     owner: Xrm.XrmQuark ): XmBaseClassExtPtr;

<* ELSE *>

PROCEDURE  / _XmBCEPTR ( wc: Xt.WidgetClass ): XmBaseClassExtPtr;
PROCEDURE  / _XmBCE ( wc: Xt.WidgetClass ): XmBaseClassExt;
PROCEDURE  / _XmGetBaseClassExtPtr ( wc: Xt.WidgetClass;
                                     owner: Xrm.XrmQuark ): XmBaseClassExtPtr;

<* END *>

(*  defines for 256 bit (at least) bit field  *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE _XmGetFlagsBit ( field: _XmBCEFlags;
                           bit: SET8 ): SET8;
PROCEDURE _XmSetFlagsBit ( field: _XmBCEFlags;
                           bit: SET8 );
PROCEDURE _XmFastSubclassInit ( wc: Xt.WidgetClass;
                                bit_field: SET8);

<* ELSE *>

PROCEDURE  / _XmGetFlagsBit ( field: _XmBCEFlags;
                              bit: SET8 ): SET8;
PROCEDURE  / _XmSetFlagsBit ( VAR field: _XmBCEFlags;
                              bit: SET8 );
PROCEDURE  / _XmFastSubclassInit ( wc: Xt.WidgetClass;
                                   bit_field: SET8);

<* END *>

(* _XmGetBaseClassExtPtr can return NULL or a pointer to a NULL extension,
   for non Motif classes in particular, so we check that up front.
   We use the global _Xm_fastPtr for that purpose, this variable exists
   already in BaseClass.c for apparently no other use *)

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE _XmIsFastSubclass ( wc: Xt.WidgetClass;
                              bit: SHORTCARD): Xt.Boolean;

<* ELSE *>

PROCEDURE  / _XmIsFastSubclass ( wc: Xt.WidgetClass;
                                 bit: SHORTCARD): Xt.Boolean;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmIsSlowSubclass ( wc: Xt.WidgetClass;
                              bit: CARDINAL ): Xt.Boolean;

PROCEDURE _XmGetClassExtensionPtr ( VAR listHeadPtr: XmGenericClassExt;
                                    owner: Xrm.XrmQuark ): XmGenericClassExtPtr;

PROCEDURE _XmPushWidgetExtData ( widget: Xt.Widget;
                                 data: XmWidgetExtData;
                                 extType: SHORTCARD );

PROCEDURE _XmPopWidgetExtData ( widget: Xt.Widget;
                                VAR dataRtn: XmWidgetExtData;
                                extType: SHORTCARD );

PROCEDURE _XmGetWidgetExtData ( widget: Xt.Widget;
                                extType: SHORTCARD ): XmWidgetExtData;

PROCEDURE _XmFreeWidgetExtData ( widget: Xt.Widget );

PROCEDURE _XmBaseClassPartInitialize ( wc: Xt.WidgetClass );

PROCEDURE _XmInitializeExtensions (  );

PROCEDURE _XmIsStandardMotifWidgetClass ( wc: Xt.WidgetClass ): Xt.Boolean;

PROCEDURE _XmSecondaryResourceData ( bcePtr: XmBaseClassExt;
                                     VAR secResDataRtn: XmSecondaryResourceDataPtr;
                                     client_data: Xt.XtPointer;
                                     name: Xt.String;
                                     class_name: Xt.String;
                                     basefunctionpointer: XmResourceBaseProc ): Xt.Cardinal;

PROCEDURE _XmTransformSubResources ( comp_resources: Xt.XtResourceList;
                                     num_comp_resources: Xt.Cardinal;
                                     VAR resources: Xt.XtResourceList;
                                     VAR num_resources: Xt.Cardinal );

(********    End Private Function Declarations    ********)

(* --------------------------------------------------- *)
(*                     Xm/ArrowB.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

VAR
  xmArrowButtonWidgetClass: Xt.WidgetClass;

TYPE
  XmArrowButtonWidgetClass = POINTER TO _XmArrowButtonClassRec;

  XmArrowButtonWidget = POINTER TO _XmArrowButtonRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateArrowButton ( parent: Xt.Widget; name: XmStringCharSet;
                                arglist: Xt.ArgList;
                                argcount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/ArrowBP.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(*   Arrow class structure   *)

TYPE
  _XmArrowButtonClassPart = RECORD
    extension: Xt.XtPointer;
  END;

  XmArrowButtonClassPart = _XmArrowButtonClassPart;

(*   Full class record declaration for Arrow class   *)

  _XmArrowButtonClassRec = RECORD
    core_class       : Xt.CoreClassPart;
    primitive_class  : XmPrimitiveClassPart;
    arrowbutton_class: XmArrowButtonClassPart;
  END;

  XmArrowButtonClassRec = _XmArrowButtonClassRec;

(*   The ArrowButton instance record   *)

  _XmArrowButtonPart = RECORD
    activate_callback: Xt.XtCallbackList;
    arm_callback     : Xt.XtCallbackList;
    disarm_callback  : Xt.XtCallbackList;
    direction        : SHORTCARD;   (* the direction the arrow is pointing *)
    selected         : Xt.Boolean;
    top_count        : SYSTEM.INT16;
    cent_count       : SYSTEM.INT16;
    bot_count        : SYSTEM.INT16;
    top              : Xlib.PtrXRectangle;
    cent             : Xlib.PtrXRectangle;
    bot              : Xlib.PtrXRectangle;
    arrow_GC         : Xlib.GC;     (* graphics context for arrow drawing *)
    timer            : Xt.XtIntervalId;
    multiClick       : SHORTCARD;   (* KEEP/DISCARD resource  *)
    click_count      : SYSTEM.int;
    armTimeStamp     : X.Time;
    insensitive_GC   : Xlib.GC;     (* graphics context for insensitive arrow drawing *)
  END;

  XmArrowButtonPart = _XmArrowButtonPart;

(*   Full instance record declaration   *)

  _XmArrowButtonRec = RECORD
    core       : Xt.CorePart;
    primitive  : XmPrimitivePart;
    arrowbutton: XmArrowButtonPart;
  END;

  XmArrowButtonRec = _XmArrowButtonRec;

VAR
  xmArrowButtonClassRec: XmArrowButtonClassRec;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/ArrowBG.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

VAR
  xmArrowButtonGadgetClass: Xt.WidgetClass;

TYPE
  XmArrowButtonGadgetClass = POINTER TO _XmArrowButtonGadgetClassRec;

  XmArrowButtonGadget = POINTER TO _XmArrowButtonGadgetRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateArrowButtonGadget ( parent: Xt.Widget;
                                      name: XmStringCharSet;
                                      arglist: Xt.ArgList;
                                      argcount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/ArrowBGP.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(*   Arrow class structure   *)

TYPE
  _XmArrowButtonGadgetClassPart = RECORD
    extension: Xt.XtPointer;
  END;

  XmArrowButtonGadgetClassPart = _XmArrowButtonGadgetClassPart;

(*   Full class record declaration for Arrow class   *)

  _XmArrowButtonGadgetClassRec = RECORD
    rect_class        : Xt.RectObjClassPart;
    gadget_class      : XmGadgetClassPart;
    arrow_button_class: XmArrowButtonGadgetClassPart;
  END;

  XmArrowButtonGadgetClassRec = _XmArrowButtonGadgetClassRec;

(* "Gadget caching" is currently under investigation for ArrowBG.  It would
 * be very desirable to cache the XRectangles, requiring immediate reference
 * instead of indirectly through pointers.  ArrowBG will be cached by Beta.
 *)

(* The Arrow instance record *)

  _XmArrowButtonGadgetPart = RECORD
    activate_callback: Xt.XtCallbackList;
    arm_callback     : Xt.XtCallbackList;
    disarm_callback  : Xt.XtCallbackList;
    direction        : SHORTCARD;  (* the direction the arrow is pointing *)
    selected         : Xt.Boolean;
    top_count        : SYSTEM.INT16;
    cent_count       : SYSTEM.INT16;
    bot_count        : SYSTEM.INT16;
    top              : Xlib.PtrXRectangle;
    cent             : Xlib.PtrXRectangle;
    bot              : Xlib.PtrXRectangle;
    old_x            : Xt.Position;
    old_y            : Xt.Position;
    arrow_GC         : Xlib.GC;    (* graphics context for arrow drawing *)
    timer            : Xt.XtIntervalId;
    multiClick       : SHORTCARD;  (* KEEP/DISCARD resource *)
    click_count      : SYSTEM.int;
    insensitive_GC   : Xlib.GC;    (* graphics context for insensitive arrow drawing *)
  END;

  XmArrowButtonGadgetPart = _XmArrowButtonGadgetPart;

(* Full instance record declaration *)

  _XmArrowButtonGadgetRec = RECORD
    object     : Xt.ObjectPart;
    rectangle  : Xt.RectObjPart;
    gadget     : XmGadgetPart;
    arrowbutton: XmArrowButtonGadgetPart;
  END;

  XmArrowButtonGadgetRec = _XmArrowButtonGadgetRec;

VAR
  xmArrowButtonGadgetClassRec: XmArrowButtonGadgetClassRec;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/AtomMgr.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(********    Public Function Declarations    ********)

PROCEDURE XmInternAtom ( display: Xlib.PtrDisplay;
                         name: ARRAY OF CHAR;
                         only_if_exists: Xt.Boolean ): X.Atom;

PROCEDURE XmGetAtomName ( display: Xlib.PtrDisplay;
                          atom: X.Atom ): Xt.String;

(********    End Public Function Declarations    ********)

CONST
  XmNameToAtom = XmGetAtomName;

(* ------------------------------------------------------ *)
(*                     Xm/BulletinB.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2
 *)

(*  Class record constants  *)

VAR
  xmBulletinBoardWidgetClass: Xt.WidgetClass;

TYPE
  XmBulletinBoardWidgetClass = POINTER TO _XmBulletinBoardClassRec;

  XmBulletinBoardWidget = POINTER TO _XmBulletinBoardRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateBulletinBoard ( p: Xt.Widget;
                                  name: Xt.String;
                                  args: Xt.ArgList;
                                  n: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateBulletinBoardDialog ( ds_p: Xt.Widget;
                                        name: Xt.String;
                                        bb_args: Xt.ArgList;
                                        bb_n: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/BulletinBP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(****************************************************************************
 * this suffix is added to dialog shells created by Xm convenience routines *
 * so that, for example, a call to create a form dialog named f generates a *
 * dialog shell named f_popup in addition to a form named f                 *
 ****************************************************************************)

CONST
  XmDIALOG_SUFFIX = '_popup';
  XmDIALOG_SUFFIX_SIZE = 6;

(*  Constraint part record for bulletin board  *)

TYPE
  _XmBulletinBoardConstraintPart = RECORD
    unused: CHAR;
  END;

  XmBulletinBoardConstraintPart = _XmBulletinBoardConstraintPart;

  XmBulletinBoardConstraint = POINTER TO _XmBulletinBoardConstraintPart;

(*   New fields for the BulletinBoard widget class record   *)

  _XmBulletinBoardClassPart = RECORD
    always_install_accelerators: Xt.Boolean;
    geo_matrix_create          : XmGeoCreateProc;
    focus_moved_proc           : XmFocusMovedProc;
    extension                  : Xt.XtPointer;
  END;

  XmBulletinBoardClassPart =  _XmBulletinBoardClassPart;

(*  Full class record declaration  *)

  _XmBulletinBoardClassRec = RECORD
    core_class          : Xt.CoreClassPart;
    composite_class     : Xt.CompositeClassPart;
    constraint_class    : Xt.ConstraintClassPart;
    manager_class       : XmManagerClassPart;
    bulletin_board_class: XmBulletinBoardClassPart;
  END;

  XmBulletinBoardClassRec = _XmBulletinBoardClassRec;

(*  New fields for the BulletinBoard widget record  *)

  _XmBulletinBoardPart = RECORD
    margin_width          : Xt.Dimension;      (* margins *)
    margin_height         : Xt.Dimension;
    default_button        : Xt.Widget;         (* widgets *)
    dynamic_default_button: Xt.Widget;         (* widgets *)
    cancel_button         : Xt.Widget;
    dynamic_cancel_button : Xt.Widget;
    focus_callback        : Xt.XtCallbackList; (* callback lists *)
    map_callback          : Xt.XtCallbackList;
    unmap_callback        : Xt.XtCallbackList;
    text_translations     : Xt.XtTranslations;
    button_font_list      : XmFontList;        (* font lists *)
    label_font_list       : XmFontList;
    text_font_list        : XmFontList;
    allow_overlap         : Xt.Boolean;        (* policies *)
    default_position      : Xt.Boolean;
    auto_unmanage         : Xt.Boolean;
    resize_policy         : SHORTCARD;
    old_width             : Xt.Dimension;      (* shadow resources *)
    old_height            : Xt.Dimension;
    old_shadow_thickness  : Xt.Dimension;
    shadow_type           : SHORTCARD;
    in_set_values         : Xt.Boolean;        (* internal flag *)
    initial_focus         : Xt.Boolean;
    no_resize             : Xt.Boolean;        (* dialog resources *)
    dialog_style          : SHORTCARD;
    dialog_title          : XmString;
    shell                 : Xt.Widget;
    _UNUSED               : Xt.Widget;
    geo_cache             : XmGeoMatrix; (* Cache for geometry management. *)
  END;

  XmBulletinBoardPart = _XmBulletinBoardPart;

(****************************************************************
 *
 * Full instance record declaration
 *
 ****************************************************************)

  _XmBulletinBoardRec = RECORD
    core          : Xt.CorePart;
    composite     : Xt.CompositePart;
    constraint    : Xt.ConstraintPart;
    manager       : XmManagerPart;
    bulletin_board: XmBulletinBoardPart;
  END;

  XmBulletinBoardRec = _XmBulletinBoardRec;

VAR
  xmBulletinBoardClassRec: XmBulletinBoardClassRec;

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE BB_CancelButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE BB_DynamicCancelButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE BB_DefaultButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE BB_DynamicDefaultButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE BB_MarginHeight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE BB_MarginWidth ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE BB_ButtonFontList ( w: Xt.Widget ): XmFontList;
PROCEDURE BB_LabelFontList ( w: Xt.Widget ): XmFontList;
PROCEDURE BB_TextFontList ( w: Xt.Widget ): XmFontList;
PROCEDURE BB_StringDirection ( w: Xt.Widget ): XmStringDirection;
PROCEDURE BB_ResizePolicy ( w: Xt.Widget ): SHORTCARD;
PROCEDURE BB_InSetValues ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE BB_InitialFocus ( w: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / BB_CancelButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / BB_DynamicCancelButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / BB_DefaultButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / BB_DynamicDefaultButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / BB_MarginHeight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / BB_MarginWidth ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / BB_ButtonFontList ( w: Xt.Widget ): XmFontList;
PROCEDURE  / BB_LabelFontList ( w: Xt.Widget ): XmFontList;
PROCEDURE  / BB_TextFontList ( w: Xt.Widget ): XmFontList;
PROCEDURE  / BB_StringDirection ( w: Xt.Widget ): XmStringDirection;
PROCEDURE  / BB_ResizePolicy ( w: Xt.Widget ): SHORTCARD;
PROCEDURE  / BB_InSetValues ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / BB_InitialFocus ( w: Xt.Widget ): Xt.Boolean;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmBB_CreateButtonG ( bb: Xt.Widget;
                                l_string: XmString;
                                name: ARRAY OF CHAR ): Xt.Widget;

PROCEDURE _XmBB_CreateLabelG ( bb: Xt.Widget;
                               l_string: XmString;
                               name: ARRAY OF CHAR ): Xt.Widget;

PROCEDURE _XmBulletinBoardSizeUpdate ( wid: Xt.Widget );

PROCEDURE _XmBulletinBoardFocusMoved ( wid: Xt.Widget;
                                       client_data: Xt.XtPointer;
                                       data: Xt.XtPointer );

PROCEDURE _XmBulletinBoardReturn ( wid: Xt.Widget;
                                   VAR event: Xlib.XEvent;
                                   params: Xt.StringList;
                                   VAR numParams: Xt.Cardinal );

PROCEDURE _XmBulletinBoardCancel ( wid: Xt.Widget;
                                   VAR event: Xlib.XEvent;
                                   params: Xt.StringList;
                                   VAR numParams: Xt.Cardinal );

PROCEDURE _XmBulletinBoardMap ( wid: Xt.Widget;
                                VAR event: Xlib.XEvent;
                                params: Xt.StringList;
                                VAR numParams: Xt.Cardinal );

PROCEDURE _XmBulletinBoardSetDefaultShadow ( button: Xt.Widget );

PROCEDURE _XmBulletinBoardSetDynDefaultButton ( wid: Xt.Widget;
                                                newDefaultButton: Xt.Widget );

PROCEDURE _XmBBUpdateDynDefaultButton ( bb: Xt.Widget );

(********    End Private Function Declarations    ********)

(* -------------------------------------------------- *)
(*                     Xm/Label.h                     *)
(* -------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(*   Widget class and record definitions   *)

VAR
  xmLabelWidgetClass: Xt.WidgetClass;

TYPE
  XmLabelWidgetClass = POINTER TO _XmLabelClassRec;

  XmLabelWidget = POINTER TO _XmLabelRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateLabel ( parent: Xt.Widget;
                          name: ARRAY OF CHAR;
                          arglist: Xt.ArgList;
                          argCount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* --------------------------------------------------- *)
(*                     Xm/LabelP.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

CONST
  XmUNSPECIFIED = -1;

TYPE
(* The Label Widget Class and instance records *)

  _XmLabelClassPart = RECORD
    setOverrideCallback: Xt.XtWidgetProc;
    menuProcs          : XmMenuProc;
    (* XtTranslations *)
    translations       : Xt.String;
    extension          : Xt.XtPointer;  (* Pointer to extension record *)
  END;

  XmLabelClassPart = _XmLabelClassPart;

(*  label class record  *)

  _XmLabelClassRec = RECORD
    core_class     : Xt.CoreClassPart;
    primitive_class: XmPrimitiveClassPart;
    label_class    : XmLabelClassPart;
  END;

  XmLabelClassRec = _XmLabelClassRec;

VAR
  xmLabelClassRec: XmLabelClassRec;

(* Inherited  Functions exported by label *)

CONST
  XmInheritSetOverrideCallback = Xt._XtInherit;
  XmInheritResize = Xt._XtInherit;
  XmInheritRealize = Xt._XtInherit;

(* The padding between label text and accelerator text *)

  LABEL_ACC_PAD = 15;

(*   The Label instance record   *)

TYPE
  _XmLabelPart = RECORD
    _label          : _XmString;      (* String sent to this widget *)
    _acc_text       : _XmString;
    mnemonic        : X.KeySym;
(** mnemonic        : CHAR; **)
    mnemonicCharset : XmStringCharSet;
    accelerator     : Xt.String;
    label_type      : SHORTCARD;
    alignment       : SHORTCARD;
    string_direction: SHORTCARD;
    font            : XmFontList;
    margin_height   : Xt.Dimension;   (* margin around widget *)
    margin_width    : Xt.Dimension;
    margin_left     : Xt.Dimension;   (* additional margins on *)
    margin_right    : Xt.Dimension;   (* each side of widget *)
    margin_top      : Xt.Dimension;   (* text (or pixmap) is placed *)
    margin_bottom   : Xt.Dimension;   (* inside the margins *)
    recompute_size  : Xt.Boolean;
    pixmap          : X.Pixmap;
    pixmap_insen    : X.Pixmap;
    (*  PRIVATE members -- values computed by LabelWidgetClass methods  *)
    normal_GC       : Xlib.GC;        (* GC for text *)
    insensitive_GC  : Xlib.GC;
    TextRect        : Xlib.XRectangle;(* The bounding box of the text, or clip
                                       * rectangle of the window; whichever is
                                       * smaller *)
    acc_TextRect    : Xlib.XRectangle;(* The bounding box of the text, or clip
                                       * rectangle of the window; whichever is
                                       * smaller *)
    skipCallback    : Xt.Boolean;     (* set by RowColumn when entryCallback
                                       * is provided. *)
    menu_type       : SHORTCARD;
  END;

  XmLabelPart = _XmLabelPart;

  _XmLabelRec = RECORD
    core     : Xt.CorePart;
    primitive: XmPrimitivePart;
    label    : XmLabelPart;
  END;

  XmLabelRec = _XmLabelRec;

(*  MACROS  *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE Lab_MarginWidth ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE Lab_MarginHeight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE Lab_MarginTop ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE Lab_MarginBottom ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE Lab_MarginRight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE Lab_MarginLeft ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE Lab_TextRect_x ( w: Xt.Widget ): Xt.Position;
PROCEDURE Lab_TextRect_y ( w: Xt.Widget ): Xt.Position;
PROCEDURE Lab_TextRect_width ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE Lab_TextRect_height ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE Lab_IsText ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE Lab_IsPixmap ( w: Xt.Widget ): X.Pixmap;
PROCEDURE Lab_Font ( w: Xt.Widget ): XmFontList;
PROCEDURE Lab_Mnemonic ( w: Xt.Widget ): X.KeySym;
PROCEDURE Lab_Accelerator ( w: Xt.Widget ): Xt.String;
(* PROCEDURE Lab_AcceleratorText ( w: Xt.Widget ): Xt.String; *)
PROCEDURE Lab_MenuType ( w: Xt.Widget ): SHORTCARD;
PROCEDURE Lab_Shadow ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE Lab_Highlight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE Lab_Baseline ( w: Xt.Widget ): Xt.Dimension;

<* ELSE *>

PROCEDURE  / Lab_MarginWidth ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / Lab_MarginHeight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / Lab_MarginTop ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / Lab_MarginBottom ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / Lab_MarginRight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / Lab_MarginLeft ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / Lab_TextRect_x ( w: Xt.Widget ): Xt.Position;
PROCEDURE  / Lab_TextRect_y ( w: Xt.Widget ): Xt.Position;
PROCEDURE  / Lab_TextRect_width ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / Lab_TextRect_height ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / Lab_IsText ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / Lab_IsPixmap ( w: Xt.Widget ): X.Pixmap;
PROCEDURE  / Lab_Font ( w: Xt.Widget ): XmFontList;
PROCEDURE  / Lab_Mnemonic ( w: Xt.Widget ): X.KeySym;
PROCEDURE  / Lab_Accelerator ( w: Xt.Widget ): Xt.String;
(* PROCEDURE  / Lab_AcceleratorText ( w: Xt.Widget ): Xt.String; *)
PROCEDURE  / Lab_MenuType ( w: Xt.Widget ): SHORTCARD;
PROCEDURE  / Lab_Shadow ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / Lab_Highlight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / Lab_Baseline ( w: Xt.Widget ): Xt.Dimension;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmCalcLabelDimensions ( wid: Xt.Widget );

(********    End Private Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/CascadeB.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

VAR
  xmCascadeButtonWidgetClass: Xt.WidgetClass;

TYPE
  XmCascadeButtonWidget = POINTER TO _XmCascadeButtonRec;

  XmCascadeButtonWidgetClass = POINTER TO _XmCascadeButtonClassRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateCascadeButton ( parent: Xt.Widget;
                                  name: ARRAY OF CHAR;
                                  al: Xt.ArgList;
                                  ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCascadeButtonHighlight ( cb: Xt.Widget;
                                     highlight: Xt.Boolean );

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/CascadeBP.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2.3
 *)

(*  The CascadeButton instance record  *)

TYPE
  _XmCascadeButtonPart = RECORD
    (*  resources  *)
    activate_callback: Xt.XtCallbackList;   (*  widget fired callback  *)
    cascade_callback : Xt.XtCallbackList;   (*  called when the menu is   *)
(*  about to be pulled down  *)
    submenu          : Xt.Widget;           (*  the menu to pull down  *)
    cascade_pixmap   : X.Pixmap;            (*  pixmap for the cascade  *)
    map_delay        : SYSTEM.int;          (*  time delay for posting  *)
(*  internal fields  *)
    armed            : Xt.Boolean;          (*  armed flag  *)
    cascade_rect     : Xlib.XRectangle;     (*  location of cascade *)
    timer            : Xt.XtIntervalId;     (*  timeout id  *)
    armed_pixmap     : X.Pixmap;            (*  arm arrow cascade  *)
  END;

  XmCascadeButtonPart = _XmCascadeButtonPart;

(*  Full instance record declaration  *)

  _XmCascadeButtonRec = RECORD
    core          : Xt.CorePart;
    primitive     : XmPrimitivePart;
    label         : XmLabelPart;
    cascade_button: XmCascadeButtonPart;
  END;

  XmCascadeButtonRec = _XmCascadeButtonRec;

(*  OBSOLETE (for compatibility only). *)

  _XmCascadeButtonWidgetRec = RECORD
    core          : Xt.CorePart;
    primitive     : XmPrimitivePart;
    label         : XmLabelPart;
    cascade_button: XmCascadeButtonPart;
  END;

  XmCascadeButtonWidgetRec = _XmCascadeButtonWidgetRec;

(*  CascadeButton class structure  *)

  _XmCascadeButtonClassPart = RECORD
    extension: Xt.XtPointer;   (*  Pointer to extension record  *)
  END;

  XmCascadeButtonClassPart = _XmCascadeButtonClassPart;

(*  Full class record declaration for CascadeButton class  *)

  _XmCascadeButtonClassRec = RECORD
    core_class          : Xt.CoreClassPart;
    primitive_class     : XmPrimitiveClassPart;
    label_class         : XmLabelClassPart;
    cascade_button_class: XmCascadeButtonClassPart;
  END;

  XmCascadeButtonClassRec = _XmCascadeButtonClassRec;

VAR
  xmCascadeButtonClassRec: XmCascadeButtonClassRec;

(*  Access macro definitions  *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE CB_Submenu ( cb: Xt.Widget ): Xt.Widget;
PROCEDURE CB_ActivateCall ( cb: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE CB_CascadeCall ( cb: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE CB_CascadePixmap ( cb: Xt.Widget ): X.Pixmap;
PROCEDURE CB_ArmedPixmap ( cb: Xt.Widget ): X.Pixmap;
PROCEDURE CB_Cascade_x ( cb: Xt.Widget ): Xt.Position;
PROCEDURE CB_Cascade_y ( cb: Xt.Widget ): Xt.Position;
PROCEDURE CB_Cascade_width ( cb: Xt.Widget ): Xt.Dimension;
PROCEDURE CB_Cascade_height ( cb: Xt.Widget ): Xt.Dimension;
PROCEDURE CB_HasCascade ( cb: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / CB_Submenu ( cb: Xt.Widget ): Xt.Widget;
PROCEDURE  / CB_ActivateCall ( cb: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / CB_CascadeCall ( cb: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / CB_CascadePixmap ( cb: Xt.Widget ): X.Pixmap;
PROCEDURE  / CB_ArmedPixmap ( cb: Xt.Widget ): X.Pixmap;
PROCEDURE  / CB_Cascade_x ( cb: Xt.Widget ): Xt.Position;
PROCEDURE  / CB_Cascade_y ( cb: Xt.Widget ): Xt.Position;
PROCEDURE  / CB_Cascade_width ( cb: Xt.Widget ): Xt.Dimension;
PROCEDURE  / CB_Cascade_height ( cb: Xt.Widget ): Xt.Dimension;
PROCEDURE  / CB_HasCascade ( cb: Xt.Widget ): Xt.Boolean;

<* END *>

CONST
  XmCB_ARMED_BIT    = SET8{0};
  XmCB_TRAVERSE_BIT = SET8{1};

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE CB_IsArmed ( cb: Xt.Widget ): Xt.Boolean;
PROCEDURE CB_Traversing ( cb: Xt.Widget ): Xt.Boolean;
PROCEDURE CB_SetBit ( byte: Xt.Boolean;
                      bit: SET8;
                      v: BOOLEAN );
PROCEDURE CB_SetArmed ( cb: Xt.Widget; v: BOOLEAN );
PROCEDURE CB_SetTraverse ( cb: Xt.Widget; v: BOOLEAN );

<* ELSE *>

PROCEDURE / CB_IsArmed ( cb: Xt.Widget ): Xt.Boolean;
PROCEDURE / CB_Traversing ( cb: Xt.Widget ): Xt.Boolean;
PROCEDURE / CB_SetBit ( VAR byte: Xt.Boolean;
                        bit: SET8;
                        v: BOOLEAN );
PROCEDURE / CB_SetArmed ( cb: Xt.Widget; v: BOOLEAN );
PROCEDURE / CB_SetTraverse ( cb: Xt.Widget; v: BOOLEAN );

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmCBHelp ( w: Xt.Widget;
                      VAR event: Xlib.XEvent;
                      params: Xt.StringList;
                      VAR num_params: Xt.Cardinal );

PROCEDURE _XmCascadingPopup ( cb: Xt.Widget;
                              VAR event: Xlib.XEvent;
                              doCascade: Xt.Boolean );

(********    End Private Function Declarations    ********)

(* --------------------------------------------------- *)
(*                     Xm/LabelG.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(* Widget class and record definitions *)

VAR
  xmLabelGadgetClass: Xt.WidgetClass;

TYPE
  XmLabelGadgetClass = POINTER TO _XmLabelGadgetClassRec;

  XmLabelGadget = POINTER TO _XmLabelGadgetRec;

  XmLabelGCacheObject = POINTER TO _XmLabelGCacheObjRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateLabelGadget ( parent: Xt.Widget;
                                name: ARRAY OF CHAR;
                                arglist: Xt.ArgList;
                                argCount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/LabelGP.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2.1
 *)

(**************************************************************
 * The Label Gadget Cache Object's class and instance records *
 **************************************************************)

TYPE
  _XmLabelGCacheObjClassPart = RECORD
    foo: SYSTEM.int;
  END;

  XmLabelGCacheObjClassPart = _XmLabelGCacheObjClassPart;

(*  label cache class record  *)

  _XmLabelGCacheObjClassRec = RECORD
    object_class     : Xt.ObjectClassPart;
    ext_class        : XmExtClassPart;
    label_class_cache: XmLabelGCacheObjClassPart;
  END;

  XmLabelGCacheObjClassRec = _XmLabelGCacheObjClassRec;

(*   The Label Gadget Cache instance record   *)

  _XmLabelGCacheObjPart = RECORD
    label_type      : SHORTCARD;
    alignment       : SHORTCARD;
    string_direction: XmStringDirection;
    margin_height   : Xt.Dimension; (* margin around widget *)
    margin_width    : Xt.Dimension;
    margin_left     : Xt.Dimension; (* additional margins on *)
    margin_right    : Xt.Dimension; (* each side of widget *)
    margin_top      : Xt.Dimension; (* text (or pixmap) is placed *)
    margin_bottom   : Xt.Dimension; (* inside the margins *)
    recompute_size  : Xt.Boolean;
    skipCallback    : Xt.Boolean;   (* set by RowColumn when entryCallback
                                     * is provided. *)
    menu_type       : SHORTCARD;
  END;

  XmLabelGCacheObjPart = _XmLabelGCacheObjPart;

  _XmLabelGCacheObjRec = RECORD
    object     : Xt.ObjectPart;
    ext        : XmExtPart;
    label_cache: XmLabelGCacheObjPart;
  END;

  XmLabelGCacheObjRec = _XmLabelGCacheObjRec;

(*  The Label Widget Class and instance records  *)
(*************************************************)

  _XmLabelGadgetClassPart = RECORD
    setOverrideCallback: Xt.XtWidgetProc;
    menuProcs          : XmMenuProc;
    extension          : Xt.XtPointer; (* Pointer to extension record *)
  END;

  XmLabelGadgetClassPart = _XmLabelGadgetClassPart;

(*  label class record  *)

  _XmLabelGadgetClassRec = RECORD
    rect_class  : Xt.RectObjClassPart;
    gadget_class: XmGadgetClassPart;
    label_class : XmLabelGadgetClassPart;
  END;

  XmLabelGadgetClassRec = _XmLabelGadgetClassRec;

  XmLabelGCache = POINTER TO XmLabelGCacheObjPart;

  _XmLabelGadgetPart = RECORD
    _label         : _XmString;       (* String sent to this widget *)
    _acc_text      : _XmString;
    mnemonic       : X.KeySym;
    mnemonicCharset: XmStringCharSet;
    accelerator    : Xt.String;
    font           : XmFontList;
    pixmap         : X.Pixmap;
    pixmap_insen   : X.Pixmap;
    (* PRIVATE members -- values computed by LabelWidgetClass methods *)
    normal_GC      : Xlib.GC;         (* GC for text *)
    insensitive_GC : Xlib.GC;
    TextRect       : Xlib.XRectangle; (* The bounding box of the text, or clip
                                       * rectangle of the window; whichever is
                                       * smaller *)
    acc_TextRect   : Xlib.XRectangle; (* The bounding box of the text, or clip
                                       * rectangle of the window; whichever is
                                       * smaller *)
    cache          : XmLabelGCache;
  END;

  XmLabelGadgetPart = _XmLabelGadgetPart;

  _XmLabelGadgetRec = RECORD
    object   : Xt.ObjectPart;
    rectangle: Xt.RectObjPart;
    gadget   : XmGadgetPart;
    label    : XmLabelGadgetPart;
  END;

  XmLabelGadgetRec = _XmLabelGadgetRec;

VAR
  xmLabelGCacheObjClassRec: XmLabelGCacheObjClassRec;
  xmLabelGadgetClassRec: XmLabelGadgetClassRec;

(*  Padding between label text and accelerator text  *)

CONST
  LABELG_ACC_PAD = 15;

(* MACROS *)
(********
 * Macros for cached instance fields
 *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE LabG_LabelType ( w: Xt.Widget ): SHORTCARD;
PROCEDURE LabG_Alignment ( w: Xt.Widget ): SHORTCARD;
PROCEDURE LabG_StringDirection ( w: Xt.Widget ): XmStringDirection;
PROCEDURE LabG_MarginHeight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE LabG_MarginWidth ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE LabG_MarginLeft ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE LabG_MarginRight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE LabG_MarginTop ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE LabG_MarginBottom ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE LabG_RecomputeSize ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE LabG_SkipCallback ( w: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE LabG_MenuType ( w: Xt.Widget ): SHORTCARD;

<* ELSE *>

PROCEDURE  / LabG_LabelType ( w: Xt.Widget ): SHORTCARD;
PROCEDURE  / LabG_Alignment ( w: Xt.Widget ): SHORTCARD;
PROCEDURE  / LabG_StringDirection ( w: Xt.Widget ): XmStringDirection;
PROCEDURE  / LabG_MarginHeight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / LabG_MarginWidth ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / LabG_MarginLeft ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / LabG_MarginRight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / LabG_MarginTop ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / LabG_MarginBottom ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / LabG_RecomputeSize ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / LabG_SkipCallback ( w: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / LabG_MenuType ( w: Xt.Widget ): SHORTCARD;

<* END *>

(********
 * Macros for UNcached instance fields
 *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE LabG__label ( w: Xt.Widget ): _XmString;
PROCEDURE LabG__acceleratorText ( w: Xt.Widget ): _XmString;
PROCEDURE LabG_Font ( w: Xt.Widget ): XmFontList;
PROCEDURE LabG_Mnemonic ( w: Xt.Widget ): X.KeySym;
PROCEDURE LabG_MnemonicCharset ( w: Xt.Widget ): XmStringCharSet;
PROCEDURE LabG_Accelerator ( w: Xt.Widget ): Xt.String;
PROCEDURE LabG_Pixmap ( w: Xt.Widget ): X.Pixmap;
PROCEDURE LabG_PixmapInsensitive ( w: Xt.Widget ): X.Pixmap;
PROCEDURE LabG_NormalGC ( w: Xt.Widget ): Xlib.GC;
PROCEDURE LabG_InsensitiveGC ( w: Xt.Widget ): Xlib.GC;
PROCEDURE LabG_TextRect ( w: Xt.Widget ): Xlib.XRectangle;
PROCEDURE LabG_AccTextRect ( w: Xt.Widget ): Xlib.XRectangle;

<* ELSE *>

PROCEDURE  / LabG__label ( w: Xt.Widget ): _XmString;
PROCEDURE  / LabG__acceleratorText ( w: Xt.Widget ): _XmString;
PROCEDURE  / LabG_Font ( w: Xt.Widget ): XmFontList;
PROCEDURE  / LabG_Mnemonic ( w: Xt.Widget ): X.KeySym;
PROCEDURE  / LabG_MnemonicCharset ( w: Xt.Widget ): XmStringCharSet;
PROCEDURE  / LabG_Accelerator ( w: Xt.Widget ): Xt.String;
PROCEDURE  / LabG_Pixmap ( w: Xt.Widget ): X.Pixmap;
PROCEDURE  / LabG_PixmapInsensitive ( w: Xt.Widget ): X.Pixmap;
PROCEDURE  / LabG_NormalGC ( w: Xt.Widget ): Xlib.GC;
PROCEDURE  / LabG_InsensitiveGC ( w: Xt.Widget ): Xlib.GC;
PROCEDURE  / LabG_TextRect ( w: Xt.Widget ): Xlib.XRectangle;
PROCEDURE  / LabG_AccTextRect ( w: Xt.Widget ): Xlib.XRectangle;

<* END *>

(********
 * Convenience Macros
 *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE LabG_TextRect_x ( w: Xt.Widget ): Xt.Position;
PROCEDURE LabG_TextRect_y ( w: Xt.Widget ): Xt.Position;
PROCEDURE LabG_TextRect_width ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE LabG_TextRect_height ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE LabG_IsText ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE LabG_IsPixmap ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE LabG_Cache ( w: Xt.Widget ): XmLabelGCache;
PROCEDURE LabG_Shadow ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE LabG_Highlight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE LabG_Baseline ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE LabG_ClassCachePart ( w: Xt.Widget ): XmCacheClassPartPtr;

<* ELSE *>

PROCEDURE  / LabG_TextRect_x ( w: Xt.Widget ): Xt.Position;
PROCEDURE  / LabG_TextRect_y ( w: Xt.Widget ): Xt.Position;
PROCEDURE  / LabG_TextRect_width ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / LabG_TextRect_height ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / LabG_IsText ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / LabG_IsPixmap ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / LabG_Cache ( w: Xt.Widget ): XmLabelGCache;
PROCEDURE  / LabG_Shadow ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / LabG_Highlight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / LabG_Baseline ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / LabG_ClassCachePart ( w: Xt.Widget ): XmCacheClassPartPtr;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmLabelCacheCompare ( A: Xt.XtPointer;
                                 B: Xt.XtPointer ): SYSTEM.int;

PROCEDURE _XmCalcLabelGDimensions ( wid: Xt.Widget );

PROCEDURE _XmReCacheLabG ( wid: Xt.Widget );

PROCEDURE _XmAssignLabG_MarginHeight ( lw: XmLabelGadget;
                                       value: Xt.Dimension );

PROCEDURE _XmAssignLabG_MarginWidth ( lw: XmLabelGadget;
                                      value: Xt.Dimension );

PROCEDURE _XmAssignLabG_MarginLeft ( lw: XmLabelGadget;
                                     value: Xt.Dimension );

PROCEDURE _XmAssignLabG_MarginRight ( lw: XmLabelGadget;
                                      value: Xt.Dimension );

PROCEDURE _XmAssignLabG_MarginTop ( lw: XmLabelGadget;
                                    value: Xt.Dimension );

PROCEDURE _XmAssignLabG_MarginBottom ( lw: XmLabelGadget;
                                       value: Xt.Dimension );

PROCEDURE _XmProcessDrag ( w: Xt.Widget;
                           VAR event: Xlib.XEvent;
                           params: Xt.StringList;
                           VAR num_params: Xt.Cardinal );

(********    End Private Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/CascadeBG.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2
 *)

VAR
  xmCascadeButtonGadgetClass: Xt.WidgetClass;

TYPE
  XmCascadeButtonGadgetClass = POINTER TO _XmCascadeButtonGadgetClassRec;

  XmCascadeButtonGadget = POINTER TO _XmCascadeButtonGadgetRec;

  XmCascadeButtonGCacheObject = POINTER TO _XmCascadeButtonGCacheObjRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateCascadeButtonGadget ( parent: Xt.Widget;
                                        name: ARRAY OF CHAR;
                                        al: Xt.ArgList;
                                        ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCascadeButtonGadgetHighlight ( wid: Xt.Widget;
                                           highlight: Xt.Boolean );

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/CascadeBGP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2.4
 *)

(*********************************************************************
 * The Arrow Cache record for the menu cascade button
 *********************************************************************)

TYPE
  _XmArrowPixmap = RECORD
    height             : Xt.Dimension;
    width              : Xt.Dimension;
    depth              : CARDINAL;
    top_shadow_color   : Xt.Pixel;
    bottom_shadow_color: Xt.Pixel;
    foreground_color   : Xt.Pixel;
    display            : Xlib.PtrDisplay;
    screen             : Xlib.PtrScreen;
    pixmap             : X.Pixmap;
  END;

  XmArrowPixmap = _XmArrowPixmap;

(*********************************************************************)
(*  The CascadeButton Gadget Cache Object's class and instance records *)
(*********************************************************************)

  _XmCascadeButtonGCacheObjClassPart = RECORD
    foo: SYSTEM.int;
  END;

  XmCascadeButtonGCacheObjClassPart = _XmCascadeButtonGCacheObjClassPart;

  _XmCascadeButtonGCacheObjClassRec = RECORD
    object_class              : Xt.ObjectClassPart;
    ext_class                 : XmExtClassPart;
    label_class_cache         : XmLabelGCacheObjClassPart;
    cascade_button_class_cache: XmCascadeButtonGCacheObjClassPart;
  END;

  XmCascadeButtonGCacheObjClassRec = _XmCascadeButtonGCacheObjClassRec;

  _XmCascadeButtonGCacheObjPart = RECORD
    cascade_pixmap: X.Pixmap;           (*  pixmap for the cascade  *)
    map_delay     : SYSTEM.int;         (*  time delay for posting  *)
    armed_pixmap  : X.Pixmap;
  END;

  XmCascadeButtonGCacheObjPart = _XmCascadeButtonGCacheObjPart;

  _XmCascadeButtonGCacheObjRec = RECORD
    object              : Xt.ObjectPart;
    ext                 : XmExtPart;
    label_cache         : XmLabelGCacheObjPart;
    cascade_button_cache: XmCascadeButtonGCacheObjPart;
  END;

  XmCascadeButtonGCacheObjRec = _XmCascadeButtonGCacheObjRec;

(*  The CascadeButtonGadget instance record  *)

  XmCascadeButtonGCache = POINTER TO _XmCascadeButtonGCacheObjPart;

  _XmCascadeButtonGadgetPart = RECORD
    (*  resources  *)
    submenu          : Xt.Widget;         (* the menu to pull down *)
    activate_callback: Xt.XtCallbackList; (* widget fired callback *)
    cascade_callback : Xt.XtCallbackList; (* optional callback, called
      	      	      	      	      	   * when the menu is about
      	      	      	      	      	   * to be pulled down *)
    (*  internal fields  *)
    armed            : Xt.Boolean;        (* armed flag *)
    cascade_rect     : Xlib.XRectangle;   (* location of cascade *)
    timer            : Xt.XtIntervalId;   (* timeout id *)
    cache            : XmCascadeButtonGCache;
  END;

  XmCascadeButtonGadgetPart = _XmCascadeButtonGadgetPart;

(*  Full instance record declaration  *)

  _XmCascadeButtonGadgetRec = RECORD
    object        : Xt.ObjectPart;
    rectangle     : Xt.RectObjPart;
    gadget        : XmGadgetPart;
    label         : XmLabelGadgetPart;
    cascade_button: XmCascadeButtonGadgetPart;
  END;

  XmCascadeButtonGadgetRec = _XmCascadeButtonGadgetRec;

(*  CascadeButton class structure  *)

  _XmCascadeButtonGadgetClassPart = RECORD
    extension: Xt.XtPointer;      (*  Pointer to extension record  *)
  END;

  XmCascadeButtonGadgetClassPart = _XmCascadeButtonGadgetClassPart;

(*  Full class record declaration for CascadeButton class  *)

  _XmCascadeButtonGadgetClassRec = RECORD
    rect_class          : Xt.RectObjClassPart;
    gadget_class        : XmGadgetClassPart;
    label_class         : XmLabelGadgetClassPart;
    cascade_button_class: XmCascadeButtonGadgetClassPart;
  END;

  XmCascadeButtonGadgetClassRec = _XmCascadeButtonGadgetClassRec;

VAR
  xmCascadeButtonGCacheObjClassRec: XmCascadeButtonGCacheObjClassRec;
  xmCascadeButtonGadgetClassRec: XmCascadeButtonGadgetClassRec;

(*  Access macro definitions  for UNcached fields *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE CBG_Submenu ( cb: Xt.Widget ): Xt.Widget;
PROCEDURE CBG_ActivateCall ( cb: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE CBG_CascadeCall ( cb: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE CBG_Armed ( cb: Xt.Widget ): Xt.Boolean;
PROCEDURE CBG_CascadeRect ( cb: Xt.Widget ): Xlib.XRectangle;
PROCEDURE CBG_Timer ( cb: Xt.Widget ): Xt.XtIntervalId;
PROCEDURE CBG_Cascade_x ( cb: Xt.Widget ): Xt.Position;
PROCEDURE CBG_Cascade_y ( cb: Xt.Widget ): Xt.Position;
PROCEDURE CBG_Cascade_width ( cb: Xt.Widget ): Xt.Dimension;
PROCEDURE CBG_Cascade_height ( cb: Xt.Widget ): Xt.Dimension;
PROCEDURE CBG_HasCascade ( cb: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / CBG_Submenu ( cb: Xt.Widget ): Xt.Widget;
PROCEDURE  / CBG_ActivateCall ( cb: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / CBG_CascadeCall ( cb: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / CBG_Armed ( cb: Xt.Widget ): Xt.Boolean;
PROCEDURE  / CBG_CascadeRect ( cb: Xt.Widget ): Xlib.XRectangle;
PROCEDURE  / CBG_Timer ( cb: Xt.Widget ): Xt.XtIntervalId;
PROCEDURE  / CBG_Cascade_x ( cb: Xt.Widget ): Xt.Position;
PROCEDURE  / CBG_Cascade_y ( cb: Xt.Widget ): Xt.Position;
PROCEDURE  / CBG_Cascade_width ( cb: Xt.Widget ): Xt.Dimension;
PROCEDURE  / CBG_Cascade_height ( cb: Xt.Widget ): Xt.Dimension;
PROCEDURE  / CBG_HasCascade ( cb: Xt.Widget ): Xt.Boolean;

<* END *>

CONST
  XmCBG_ARMED_BIT    = SET8{0};
  XmCBG_TRAVERSE_BIT = SET8{1};

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE CBG_IsArmed ( cb: Xt.Widget ): Xt.Boolean;
PROCEDURE CBG_Traversing ( cb: Xt.Widget ): Xt.Boolean;
PROCEDURE CBG_SetBit ( byte: Xt.Boolean;
                       bit: SET8;
                       v: BOOLEAN );
PROCEDURE CBG_SetArmed ( cb: Xt.Widget;
                         v: BOOLEAN );
PROCEDURE CBG_SetTraverse ( cb: Xt.Widget;
                            v: BOOLEAN );

<* ELSE *>

PROCEDURE  / CBG_IsArmed ( cb: Xt.Widget ): Xt.Boolean;
PROCEDURE  / CBG_Traversing ( cb: Xt.Widget ): Xt.Boolean;
PROCEDURE  / CBG_SetBit ( VAR byte: Xt.Boolean;
                          bit: SET8;
                          v: BOOLEAN );
PROCEDURE  / CBG_SetArmed ( cb: Xt.Widget;
                            v: BOOLEAN );
PROCEDURE  / CBG_SetTraverse ( cb: Xt.Widget;
                               v: BOOLEAN );

<* END *>

(*  Access macro definitions  for Cached fields *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE CBG_CascadePixmap ( cb: Xt.Widget ): X.Pixmap;
PROCEDURE CBG_MapDelay ( cb: Xt.Widget ): SYSTEM.int;
PROCEDURE CBG_ArmedPixmap ( cb: Xt.Widget ): X.Pixmap;

<* ELSE *>

PROCEDURE  / CBG_CascadePixmap ( cb: Xt.Widget ): X.Pixmap;
PROCEDURE  / CBG_MapDelay ( cb: Xt.Widget ): SYSTEM.int;
PROCEDURE  / CBG_ArmedPixmap ( cb: Xt.Widget ): X.Pixmap;

<* END *>

(******************************
 *  Convenience Macros
 ******************************)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE CBG_Cache ( w: Xt.Widget ): XmCascadeButtonGCache;
PROCEDURE CBG_ClassCachePart ( w: Xt.Widget ): XmCacheClassPartPtr;

<* ELSE *>

PROCEDURE  / CBG_Cache ( w: Xt.Widget ): XmCascadeButtonGCache;
PROCEDURE  / CBG_ClassCachePart ( w: Xt.Widget ): XmCacheClassPartPtr;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmArrowPixmapCacheCompare ( A: Xt.XtPointer;
                                       B: Xt.XtPointer ): SYSTEM.int;

PROCEDURE _XmArrowPixmapCacheDelete ( data: Xt.XtPointer );

PROCEDURE _XmCreateArrowPixmaps ( wid: Xt.Widget );

(********    End Private Function Declarations    ********)

(* --------------------------------------------------- *)
(*                     Xm/CacheP.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2.4
 *)

(*  a few convenience macros  *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE ClassCacheHead ( cp: XmCacheClassPartPtr ): XmCacheCompareProc;
PROCEDURE ClassCacheCopy ( cp: XmCacheClassPartPtr ): XmCacheCopyProc;
PROCEDURE ClassCacheCompare ( cp: XmCacheClassPartPtr ): XmCacheCompareProc;
PROCEDURE CacheDataPtr ( p: XmGadgetCacheRefPtr ): Xt.XtPointer;
PROCEDURE DataToGadgetCache ( p: Xt.XtPointer ): Xt.XtPointer;

<* ELSE *>

PROCEDURE  / ClassCacheHead ( cp: XmCacheClassPartPtr ): XmCacheCompareProc;
PROCEDURE  / ClassCacheCopy ( cp: XmCacheClassPartPtr ): XmCacheCopyProc;
PROCEDURE  / ClassCacheCompare ( cp: XmCacheClassPartPtr ): XmCacheCompareProc;
PROCEDURE  / CacheDataPtr ( p: XmGadgetCacheRefPtr ): Xt.XtPointer;
PROCEDURE DataToGadgetCache ( p: Xt.XtPointer ): Xt.XtPointer;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmCacheDelete ( data: Xt.XtPointer );

PROCEDURE _XmCacheCopy ( src: Xt.XtPointer;
                         dest: Xt.XtPointer;
                         size: LONGCARD );

PROCEDURE _XmCachePart ( cp: XmCacheClassPartPtr;
                         cpart: Xt.XtPointer;
                         size: LONGCARD ): Xt.XtPointer;

(********    End Private Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/SelectioB.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2
 *)

(*  Class record constants  *)

VAR
  xmSelectionBoxWidgetClass: Xt.WidgetClass;

TYPE
  XmSelectionBoxWidgetClass = POINTER TO _XmSelectionBoxClassRec;

  XmSelectionBoxWidget = POINTER TO _XmSelectionBoxRec;

(********    Public Function Declarations    ********)

PROCEDURE XmSelectionBoxGetChild ( sb: Xt.Widget;
                                   which: SHORTCARD ): Xt.Widget;

PROCEDURE XmCreateSelectionBox ( p: Xt.Widget;
                                 name: ARRAY OF CHAR;
                                 args: Xt.ArgList;
                                 n: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateSelectionDialog ( ds_p: Xt.Widget;
                                    name: ARRAY OF CHAR;
                                    sb_args: Xt.ArgList;
                                    sb_n: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreatePromptDialog ( ds_p: Xt.Widget;
                                 name: ARRAY OF CHAR;
                                 sb_args: Xt.ArgList;
                                 sb_n: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/SelectioBP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*  Defines for use in allocation geometry matrix.  *)

CONST
  XmSB_MAX_WIDGETS_VERT = 8;

(*  Constraint part record for SelectionBox widget  *)

TYPE
  _XmSelectionBoxConstraintPart = RECORD
    unused: CHAR;
  END;

  XmSelectionBoxConstraintPart = _XmSelectionBoxConstraintPart;

  XmSelectionBoxConstraint = POINTER TO _XmSelectionBoxConstraintPart;

(*   New fields for the SelectionBox widget class record   *)

  _XmSelectionBoxClassPart = RECORD
    list_callback: Xt.XtCallbackProc;
    extension    : Xt.XtPointer;        (* Pointer to extension record *)
  END;

  XmSelectionBoxClassPart = _XmSelectionBoxClassPart;

(*  Full class record declaration  *)

  _XmSelectionBoxClassRec = RECORD
    core_class          : Xt.CoreClassPart;
    composite_class     : Xt.CompositeClassPart;
    constraint_class    : Xt.ConstraintClassPart;
    manager_class       : XmManagerClassPart;
    bulletin_board_class: XmBulletinBoardClassPart;
    selection_box_class : XmSelectionBoxClassPart;
  END;

  XmSelectionBoxClassRec = _XmSelectionBoxClassRec;

(*  New fields for the SelectionBox widget record  *)

  _XmSelectionBoxPart = RECORD
    list_label                 : Xt.Widget;         (* list Label *)
    list_label_string          : XmString;
    list                       : Xt.Widget;         (* List *)
    list_items                 : XmStringTable;
    list_item_count            : SYSTEM.int;
    list_visible_item_count    : SYSTEM.int;
    list_selected_item_position: SYSTEM.int;
    selection_label            : Xt.Widget;         (* selection Label *)
    selection_label_string     : XmString;
    text                       : Xt.Widget;         (* Text *)
    text_string                : XmString;
    text_columns               : SYSTEM.INT16;
    work_area                  : Xt.Widget;         (* other widget *)
    separator                  : Xt.Widget;         (* separator *)
    ok_button                  : Xt.Widget;         (* enter button *)
    ok_label_string            : XmString;
    apply_button               : Xt.Widget;         (* apply button *)
    apply_label_string         : XmString;
    cancel_label_string        : XmString;          (* cancel button label *)
    help_button                : Xt.Widget;         (* help button *)
    help_label_string          : XmString;
    ok_callback                : Xt.XtCallbackList; (* callbacks *)
    apply_callback             : Xt.XtCallbackList;
    cancel_callback            : Xt.XtCallbackList;
    no_match_callback          : Xt.XtCallbackList;
    text_accelerators          : Xt.XtAccelerators;
    must_match                 : Xt.Boolean;        (* flags *)
    adding_sel_widgets         : Xt.Boolean;
    minimize_buttons           : Xt.Boolean;
    dialog_type                : SHORTCARD;         (* prompt or selection *)
    child_placement            : SHORTCARD;
  END;

  XmSelectionBoxPart = _XmSelectionBoxPart;

(****************************************************************
 *
 * Full instance record declaration
 *
 ****************************************************************)

  _XmSelectionBoxRec = RECORD
    core          : Xt.CorePart;
    composite     : Xt.CompositePart;
    constraint    : Xt.ConstraintPart;
    manager       : XmManagerPart;
    bulletin_board: XmBulletinBoardPart;
    selection_box : XmSelectionBoxPart;
  END;

  XmSelectionBoxRec = _XmSelectionBoxRec;

VAR
  xmSelectionBoxClassRec: XmSelectionBoxClassRec;

(*   access macros   *)

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE SB_ListLabel ( w: Xt.Widget ): Xt.Widget;
PROCEDURE SB_List ( w: Xt.Widget ): Xt.Widget;
PROCEDURE SB_SelectionLabel ( w: Xt.Widget ): Xt.Widget;
PROCEDURE SB_Text ( w: Xt.Widget ): Xt.Widget;
PROCEDURE SB_WorkArea ( w: Xt.Widget ): Xt.Widget;
PROCEDURE SB_Separator ( w: Xt.Widget ): Xt.Widget;
PROCEDURE SB_OkButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE SB_ApplyButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE SB_CancelButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE SB_HelpButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE SB_DefaultButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE SB_MarginHeight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE SB_MarginWidth ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE SB_ButtonFontList ( w: Xt.Widget ): XmFontList;
PROCEDURE SB_LabelFontList ( w: Xt.Widget ): XmFontList;
PROCEDURE SB_TextFontList ( w: Xt.Widget ): XmFontList;
PROCEDURE SB_StringDirection ( w: Xt.Widget ): XmStringDirection;
PROCEDURE SB_AddingSelWidgets ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE SB_TextAccelerators ( w: Xt.Widget ): Xt.XtAccelerators;
PROCEDURE SB_ListItemCount ( w: Xt.Widget ): SYSTEM.int;
PROCEDURE SB_ListSelectedItemPosition ( w: Xt.Widget ): SYSTEM.int;
PROCEDURE SB_ListVisibleItemCount ( w: Xt.Widget ): SYSTEM.int;
PROCEDURE SB_TextColumns ( w: Xt.Widget ): SYSTEM.INT16;
PROCEDURE SB_MinimizeButtons ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE SB_MustMatch ( w: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / SB_ListLabel ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / SB_List ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / SB_SelectionLabel ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / SB_Text ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / SB_WorkArea ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / SB_Separator ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / SB_OkButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / SB_ApplyButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / SB_CancelButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / SB_HelpButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / SB_DefaultButton ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / SB_MarginHeight ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / SB_MarginWidth ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / SB_ButtonFontList ( w: Xt.Widget ): XmFontList;
PROCEDURE  / SB_LabelFontList ( w: Xt.Widget ): XmFontList;
PROCEDURE  / SB_TextFontList ( w: Xt.Widget ): XmFontList;
PROCEDURE  / SB_StringDirection ( w: Xt.Widget ): XmStringDirection;
PROCEDURE  / SB_AddingSelWidgets ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / SB_TextAccelerators ( w: Xt.Widget ): Xt.XtAccelerators;
PROCEDURE  / SB_ListItemCount ( w: Xt.Widget ): SYSTEM.int;
PROCEDURE  / SB_ListSelectedItemPosition ( w: Xt.Widget ): SYSTEM.int;
PROCEDURE  / SB_ListVisibleItemCount ( w: Xt.Widget ): SYSTEM.int;
PROCEDURE  / SB_TextColumns ( w: Xt.Widget ): SYSTEM.INT16;
PROCEDURE  / SB_MinimizeButtons ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / SB_MustMatch ( w: Xt.Widget ): Xt.Boolean;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmSelectionBoxCreateListLabel ( sel: XmSelectionBoxWidget );

PROCEDURE _XmSelectionBoxCreateSelectionLabel ( sel: XmSelectionBoxWidget );

PROCEDURE _XmSelectionBoxCreateList ( sel: XmSelectionBoxWidget );

PROCEDURE _XmSelectionBoxCreateText ( sel: XmSelectionBoxWidget );

PROCEDURE _XmSelectionBoxCreateSeparator ( sel: XmSelectionBoxWidget );

PROCEDURE _XmSelectionBoxCreateOkButton ( sel: XmSelectionBoxWidget );

PROCEDURE _XmSelectionBoxCreateApplyButton ( sel: XmSelectionBoxWidget );

PROCEDURE _XmSelectionBoxCreateCancelButton ( sel: XmSelectionBoxWidget );

PROCEDURE _XmSelectionBoxCreateHelpButton ( sel: XmSelectionBoxWidget );

PROCEDURE _XmSelectionBoxGeoMatrixCreate ( wid: Xt.Widget;
                                           instigator: Xt.Widget;
                                           VAR desired: Xt.XtWidgetGeometry ): XmGeoMatrix;

PROCEDURE _XmSelectionBoxNoGeoRequest ( geoSpec: XmGeoMatrix ): Xt.Boolean;

PROCEDURE _XmSelectionBoxGetSelectionLabelString ( wid: Xt.Widget;
                                                   resource_offset: SYSTEM.int;
                                                   VAR value: Xt.XtArgVal );

PROCEDURE _XmSelectionBoxGetListLabelString ( wid: Xt.Widget;
                                              resource_offset: SYSTEM.int;
                                              VAR value: Xt.XtArgVal );

PROCEDURE _XmSelectionBoxGetTextColumns ( wid: Xt.Widget;
                                          resource_offset: SYSTEM.int;
                                          VAR value: Xt.XtArgVal );

PROCEDURE _XmSelectionBoxGetTextString ( wid: Xt.Widget;
                                         resource_offset: SYSTEM.int;
                                         VAR value: Xt.XtArgVal );

PROCEDURE _XmSelectionBoxGetListItems ( wid: Xt.Widget;
                                        resource_offset: SYSTEM.int;
                                        VAR value: Xt.XtArgVal );

PROCEDURE _XmSelectionBoxGetListItemCount ( wid: Xt.Widget;
                                            resource_offset: SYSTEM.int;
                                            VAR value: Xt.XtArgVal );

PROCEDURE _XmSelectionBoxGetListVisibleItemCount ( wid: Xt.Widget;
                                                   resource_offset: SYSTEM.int;
                                                   VAR value: Xt.XtArgVal );

PROCEDURE _XmSelectionBoxGetOkLabelString ( wid: Xt.Widget;
                                            resource_offset: SYSTEM.int;
                                            VAR value: Xt.XtArgVal );

PROCEDURE _XmSelectionBoxGetApplyLabelString ( wid: Xt.Widget;
                                               resource_offset: SYSTEM.int;
                                               VAR value: Xt.XtArgVal );

PROCEDURE _XmSelectionBoxGetCancelLabelString ( wid: Xt.Widget;
                                                resource_offset: SYSTEM.int;
                                                VAR value: Xt.XtArgVal );

PROCEDURE _XmSelectionBoxGetHelpLabelString ( wid: Xt.Widget;
                                              resource_offset: SYSTEM.int;
                                              VAR value: Xt.XtArgVal );

PROCEDURE _XmSelectionBoxUpOrDown ( wid: Xt.Widget;
                                    VAR event: Xlib.XEvent;
                                    argv: Xt.StringList;
                                    VAR argc: Xt.Cardinal );

PROCEDURE _XmSelectionBoxRestore ( wid: Xt.Widget;
                                   VAR event: Xlib.XEvent;
                                   argv: Xt.StringList;
                                   VAR argc: Xt.Cardinal );

(********    End Private Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/Command.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2.1
 *)

(*  Class record constants  *)

VAR
  xmCommandWidgetClass: Xt.WidgetClass;

TYPE
  XmCommandWidgetClass = POINTER TO _XmCommandClassRec;

  XmCommandWidget = POINTER TO _XmCommandRec;

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE XmIsCommand ( w: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / XmIsCommand ( w: Xt.Widget ): Xt.Boolean;

<* END *>

(********    Public Function Declarations    ********)

PROCEDURE XmCreateCommand ( parent: Xt.Widget;
                            name: ARRAY OF CHAR; al: Xt.ArgList;
                            ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCommandGetChild ( widget: Xt.Widget;
                              child: SHORTCARD ): Xt.Widget;

PROCEDURE XmCommandSetValue ( widget: Xt.Widget;
                              value: XmString );

PROCEDURE XmCommandAppendValue ( widget: Xt.Widget;
                                 value: XmString );

PROCEDURE XmCommandError ( widget: Xt.Widget;
                           error: XmString );

PROCEDURE XmCreateCommandDialog ( ds_p: Xt.Widget;
                                  name: ARRAY OF CHAR;
                                  fsb_args: Xt.ArgList;
                                  fsb_n: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/CommandP.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*  Constraint part record for Command widget  *)

TYPE
  _XmCommandConstraintPart = RECORD
    unused: CHAR;
  END;

  XmCommandConstraintPart = _XmCommandConstraintPart;

  XmCommandConstraint = POINTER TO _XmCommandConstraintPart;

(*   New fields for the Command widget class record   *)

  _XmCommandClassPart = RECORD
    extension: Xt.XtPointer;   (*  Pointer to extension record  *)
  END;

  XmCommandClassPart = _XmCommandClassPart;

(*  Full class record declaration  *)

  _XmCommandClassRec = RECORD
    core_class          : Xt.CoreClassPart;
    composite_class     : Xt.CompositeClassPart;
    constraint_class    : Xt.ConstraintClassPart;
    manager_class       : XmManagerClassPart;
    bulletin_board_class: XmBulletinBoardClassPart;
    selection_box_class : XmSelectionBoxClassPart;
    command_class       : XmCommandClassPart;
  END;

  XmCommandClassRec = _XmCommandClassRec;

(*  New fields for the Command widget record  *)

  _XmCommandPart = RECORD
    callback              : Xt.XtCallbackList;
    value_changed_callback: Xt.XtCallbackList;
    history_max_items     : SYSTEM.int;
    error                 : Xt.Boolean;  (*  error has been made visible in list  *)
  END;

  XmCommandPart = _XmCommandPart;

(****************************************************************
 *
 * Full instance record declaration
 *
 ****************************************************************)

  _XmCommandRec = RECORD
    core          : Xt.CorePart;
    composite     : Xt.CompositePart;
    constraint    : Xt.ConstraintPart;
    manager       : XmManagerPart;
    bulletin_board: XmBulletinBoardPart;
    selection_box : XmSelectionBoxPart;
    command       : XmCommandPart;
  END;

  XmCommandRec = _XmCommandRec;

VAR
  xmCommandClassRec: XmCommandClassRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmCommandReturn ( wid: Xt.Widget;
                             VAR event: Xlib.XEvent;
                             params: Xt.StringList;
                             VAR numParams: Xt.Cardinal );

PROCEDURE _XmCommandUpOrDown ( wid: Xt.Widget;
                               VAR event: Xlib.XEvent;
                               argv: Xt.StringList;
                               VAR argc: Xt.Cardinal );

(********    End Private Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                    Xm/CutPasteP.h                    *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2.2
 *)

(*  XmClipboard return status definitions  *)

CONST
  XmClipboardFail = 0;
  XmClipboardSuccess = 1;
  XmClipboardTruncate = 2;
  XmClipboardLocked = 4;
  XmClipboardBadFormat = 5;
  XmClipboardNoData = 6;

(*  XmClipboard pre-1.2 definitions  *)

  ClipboardFail = 0;
  ClipboardSuccess = 1;
  ClipboardTruncate = 2;
  ClipboardLocked = 4;
  ClipboardBadFormat = 5;
  ClipboardNoData = 6;

TYPE
  XmClipboardPendingRec = RECORD
    DataId   : LONGINT;
    PrivateId: LONGINT;
  END;

  XmClipboardPendingList = POINTER TO ARRAY OF XmClipboardPendingRec;

  XmCutPasteProc = PROCEDURE ( (* w *) Xt.Widget,
                               (* data_id *) VAR LONGINT,
                               (* private_id *) VAR SYSTEM.int,
     	       	    	       (* reason *) VAR SYSTEM.int );

  VoidProc = PROCEDURE ( (* w *) Xt.Widget,
                         (* data_id *) VAR SYSTEM.int,
                         (* private_id *) VAR SYSTEM.int,
                         (* reason *) VAR SYSTEM.int );

(********    Public Function Declarations    ********)

PROCEDURE XmClipboardBeginCopy ( display: Xlib.PtrDisplay;
                                 window: X.Window;
                                 label: XmString;
                                 widget: Xt.Widget;
                                 callback: VoidProc;
                                 VAR itemid: LONGINT ): SYSTEM.int;

PROCEDURE XmClipboardStartCopy ( display: Xlib.PtrDisplay;
                                 window: X.Window;
                                 label: XmString;
                                 timestamp: X.Time;
                                 widget: Xt.Widget;
                                 callback: XmCutPasteProc;
                                 VAR itemid: LONGINT ): SYSTEM.int;

PROCEDURE XmClipboardCopy ( display: Xlib.PtrDisplay;
                            window: X.Window;
                            itemid: LONGINT;
                            format: ARRAY OF CHAR;
                            buffer: Xt.String;
                            length: LONGCARD;
                            private_id: LONGINT;
                            VAR dataid: LONGINT ): SYSTEM.int;

PROCEDURE XmClipboardEndCopy ( display: Xlib.PtrDisplay;
                               window: X.Window;
                               itemid: LONGINT ): SYSTEM.int;

PROCEDURE XmClipboardCancelCopy ( display: Xlib.PtrDisplay;
                                  window: X.Window;
                                  itemid: LONGINT ): SYSTEM.int;

PROCEDURE XmClipboardWithdrawFormat ( display: Xlib.PtrDisplay;
                                      window: X.Window;
                                      data: LONGINT ): SYSTEM.int;

PROCEDURE XmClipboardCopyByName ( display: Xlib.PtrDisplay;
                                  window: X.Window;
                                  data: LONGINT;
                                  buffer: Xt.XtPointer;
                                  length: LONGCARD;
                                  private_id: LONGINT ): SYSTEM.int;

PROCEDURE XmClipboardUndoCopy ( display: Xlib.PtrDisplay;
                                window: X.Window ): SYSTEM.int;

PROCEDURE XmClipboardLock ( display: Xlib.PtrDisplay;
                            window: X.Window ): SYSTEM.int;

PROCEDURE XmClipboardUnlock ( display: Xlib.PtrDisplay;
                              window: X.Window;
                              all_levels: SYSTEM.int ): SYSTEM.int;

PROCEDURE XmClipboardStartRetrieve ( display: Xlib.PtrDisplay;
                                     window: X.Window;
                                     timestamp: X.Time ): SYSTEM.int;

PROCEDURE XmClipboardEndRetrieve ( display: Xlib.PtrDisplay;
                                   window: X.Window ): SYSTEM.int;

PROCEDURE XmClipboardRetrieve ( display: Xlib.PtrDisplay;
                                window: X.Window;
                                format: ARRAY OF CHAR;
                                buffer: Xt.String;
                                length: LONGCARD;
                                VAR outlength: LONGCARD;
                                VAR private_id: LONGINT ): SYSTEM.int;

PROCEDURE XmClipboardInquireCount ( display: Xlib.PtrDisplay;
                                    window: X.Window;
                                    VAR count: SYSTEM.int;
     	       	    	      	    VAR maxlength: LONGCARD ): SYSTEM.int;

PROCEDURE XmClipboardInquireFormat ( display: Xlib.PtrDisplay;
                                     window: X.Window;
                                     n: SYSTEM.int;
                                     buffer: Xt.String;
                                     bufferlength: LONGCARD;
                                     VAR outlength: LONGCARD ): SYSTEM.int;

PROCEDURE XmClipboardInquireLength ( display: Xlib.PtrDisplay;
                                     window: X.Window;
                                     format: ARRAY OF CHAR;
                                     VAR length: LONGCARD ): SYSTEM.int;

PROCEDURE XmClipboardInquirePendingItems ( display: Xlib.PtrDisplay;
                                           window: X.Window;
                                           format: ARRAY OF CHAR;
                                           VAR list: XmClipboardPendingList;
                                           VAR count: LONGCARD ): SYSTEM.int;

PROCEDURE XmClipboardRegisterFormat ( display: Xlib.PtrDisplay;
                                      format_name: ARRAY OF CHAR;
                                      format_length: SYSTEM.int ): SYSTEM.int;

(********    End Public Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/DialogS.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

VAR
  xmDialogShellWidgetClass: Xt.WidgetClass;

TYPE
  XmDialogShellWidgetClass = POINTER TO _XmDialogShellClassRec;

  XmDialogShellWidget = POINTER TO _XmDialogShellRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateDialogShell ( p: Xt.Widget;
                                name: ARRAY OF CHAR;
                                al: Xt.ArgList;
                                ac: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/DialogSP.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(*  The DialogShell instance record  *)

TYPE
  XmDialogShellPart = RECORD
(*  internal fields  *)
    grab_kind: Xt.XtGrabKind;
    old_x    : Xt.Position;
    old_y    : Xt.Position;
  END;

(*  Full instance record declaration  *)

  _XmDialogShellRec = RECORD
    core     : Xt.CorePart;
    composite: Xt.CompositePart;
    shell    : ShellP.ShellPart;
    wm       : ShellP.WMShellPart;
    vendor   : ShellP.VendorShellPart;
    transient: ShellP.TransientShellPart;
    dialog   : XmDialogShellPart;
  END;

  XmDialogShellRec = _XmDialogShellRec;

(*  OBSOLETE (for compatibility only). *)

  _XmDialogShellWidgetRec = RECORD
    core     : Xt.CorePart;
    composite: Xt.CompositePart;
    shell    : ShellP.ShellPart;
    wm       : ShellP.WMShellPart;
    vendor   : ShellP.VendorShellPart;
    transient: ShellP.TransientShellPart;
    dialog   : XmDialogShellPart;
  END;

  XmDialogShellWidgetRec = _XmDialogShellWidgetRec;

(*  DialogShell class structure  *)

  _XmDialogShellClassPart = RECORD
    extension: Xt.XtPointer;   (*  Pointer to extension record  *)
  END;

  XmDialogShellClassPart = _XmDialogShellClassPart;

(*  Full class record declaration  *)

  _XmDialogShellClassRec = RECORD
    core_class           : Xt.CoreClassPart;
    composite_class      : Xt.CompositeClassPart;
    shell_class          : ShellP.ShellClassPart;
    wm_shell_class       : ShellP.WMShellClassPart;
    vendor_shell_class   : ShellP.VendorShellClassPart;
    transient_shell_class: ShellP.TransientShellClassPart;
    dialog_shell_part    : XmDialogShellClassPart;
  END;

  XmDialogShellClassRec = _XmDialogShellClassRec;

VAR
  xmDialogShellClassRec: XmDialogShellClassRec;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/ShellEP.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

CONST
  _XmRAW_MAP = 0;
  _XmPOPUP_MAP = 1;
  _XmMANAGE_MAP = 2;

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE XmIsShellExt ( w: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / XmIsShellExt ( w: Xt.Widget ): Xt.Boolean;

<* END *>

TYPE
  XmShellExtObject = POINTER TO _XmShellExtRec;

  XmShellExtObjectClass = POINTER TO _XmShellExtClassRec;

  _XmShellExtClassPart = RECORD
    structureNotifyHandler: Xt.XtEventHandler;
    extension             : Xt.XtPointer;
  END;

  XmShellExtClassPart = _XmShellExtClassPart;

  XmShellExtClassPartPtr = POINTER TO _XmShellExtClassPart;

  _XmShellExtClassRec = RECORD
    object_class : Xt.ObjectClassPart;
    ext_class    : XmExtClassPart;
    desktop_class: XmDesktopClassPart;
    shell_class  : XmShellExtClassPart;
  END;

  XmShellExtClassRec = _XmShellExtClassRec;

  _XmShellExtPart = RECORD
    lastConfigureRequest: LONGCARD;
    useAsyncGeometry    : Xt.Boolean;
  END;

  XmShellExtPart = _XmShellExtPart;

  XmShellExtPartPtr = POINTER TO _XmShellExtPart;

  _XmShellExtRec = RECORD
    object : Xt.ObjectPart;
    ext    : XmExtPart;
    desktop: XmDesktopPart;
    shell  : XmShellExtPart;
  END;

  XmShellExtRec = _XmShellExtRec;

VAR
  xmShellExtObjectClass: Xt.WidgetClass;
  xmShellExtClassRec: XmShellExtClassRec;

(********    Private Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/MwmUtil.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2.4
 *)

(*
 * Contents of the _MWM_HINTS property.
 *)

TYPE
  MotifWmHints = RECORD
(* These correspond to XmRInt resources. (VendorSE.c) *)
    flags      : SYSTEM.int;
    functions  : SYSTEM.int;
    decorations: SYSTEM.int;
    input_mode : SYSTEM.int;
    status     : SYSTEM.int;
  END;

  MwmHints = MotifWmHints;

(* bit definitions for MwmHints.flags *)

CONST
  MWM_HINTS_FUNCTIONS = 1;
  MWM_HINTS_DECORATIONS = 2;
  MWM_HINTS_INPUT_MODE = 4;
  MWM_HINTS_STATUS = 8;

(* bit definitions for MwmHints.functions *)
  MWM_FUNC_ALL = 1;
  MWM_FUNC_RESIZE = 2;
  MWM_FUNC_MOVE = 4;
  MWM_FUNC_MINIMIZE = 8;
  MWM_FUNC_MAXIMIZE = 16;
  MWM_FUNC_CLOSE = 32;

(* bit definitions for MwmHints.decorations *)
  MWM_DECOR_ALL = 1;
  MWM_DECOR_BORDER = 2;
  MWM_DECOR_RESIZEH = 4;
  MWM_DECOR_TITLE = 8;
  MWM_DECOR_MENU = 16;
  MWM_DECOR_MINIMIZE = 32;
  MWM_DECOR_MAXIMIZE = 64;

(* values for MwmHints.input_mode *)
  MWM_INPUT_MODELESS = 0;
  MWM_INPUT_PRIMARY_APPLICATION_MODAL = 1;
  MWM_INPUT_APPLICATION_MODAL = MWM_INPUT_PRIMARY_APPLICATION_MODAL;
  MWM_INPUT_SYSTEM_MODAL = 2;
  MWM_INPUT_FULL_APPLICATION_MODAL = 3;

(* bit definitions for MwmHints.status *)
  MWM_TEAROFF_WINDOW = 1;

(*
 * The following is for compatibility only. It use is deprecated.
 *)
(*
 * Contents of the _MWM_INFO property.
 *)

TYPE
  MotifWmInfo = RECORD
    flags    : LONGINT;
    wm_window: X.Window;
  END;

  MwmInfo = MotifWmInfo;

(* bit definitions for MotifWmInfo .flags *)

CONST
  MWM_INFO_STARTUP_STANDARD = 1;
  MWM_INFO_STARTUP_CUSTOM = 2;

(*
 * Definitions for the _MWM_HINTS property.
 *)

TYPE
  PropMotifWmHints = RECORD
 (* 32-bit property items are stored as long on the client (whether
  * that means 32 bits or 64).  XChangeProperty handles the conversion
  * to the actual 32-bit quantities sent to the server.
  *)
    flags      : LONGCARD;
    functions  : LONGCARD;
    decorations: LONGCARD;
    inputMode  : LONGINT;
    status     : LONGCARD;
  END;

  PropMwmHints = PropMotifWmHints;

(* number of elements of size 32 in _MWM_HINTS *)

CONST
  PROP_MOTIF_WM_HINTS_ELEMENTS = 5;
  PROP_MWM_HINTS_ELEMENTS = PROP_MOTIF_WM_HINTS_ELEMENTS;

(* atom name for _MWM_HINTS property *)
  _XA_MOTIF_WM_HINTS = '_MOTIF_WM_HINTS';
  _XA_MWM_HINTS = _XA_MOTIF_WM_HINTS;

(*
 * Definitions for the _MWM_MESSAGES property.
 *)
  _XA_MOTIF_WM_MESSAGES = '_MOTIF_WM_MESSAGES';
  _XA_MWM_MESSAGES = _XA_MOTIF_WM_MESSAGES;

(* atom that enables client frame offset messages *)
  _XA_MOTIF_WM_OFFSET = '_MOTIF_WM_OFFSET';

(*
 * Definitions for the _MWM_MENU property.
 *)

(* atom name for _MWM_MENU property *)
  _XA_MOTIF_WM_MENU = '_MOTIF_WM_MENU';
  _XA_MWM_MENU = _XA_MOTIF_WM_MENU;

(*
 * Definitions for the _MWM_INFO property.
 *)

TYPE
  PropMotifWmInfo = RECORD
    flags   : LONGINT;
    wmWindow: X.Window;
  END;

  PropMwmInfo = PropMotifWmInfo;

(* number of elements of size 32 in _MWM_INFO *)

CONST
  PROP_MOTIF_WM_INFO_ELEMENTS = 2;
  PROP_MWM_INFO_ELEMENTS = PROP_MOTIF_WM_INFO_ELEMENTS;

(* atom name for _MWM_INFO property *)
  _XA_MOTIF_WM_INFO = '_MOTIF_WM_INFO';
  _XA_MWM_INFO = _XA_MOTIF_WM_INFO;

(*
 * Miscellaneous atom definitions
 *)

(* atom for motif input bindings *)
  _XA_MOTIF_BINDINGS = '_MOTIF_BINDINGS';

(* ------------------------------------------------------ *)
(*                     Xm/VendorSEP.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2.2
 *)

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE XmIsVendorShellExt ( w: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / XmIsVendorShellExt ( w: Xt.Widget ): Xt.Boolean;

<* END *>

TYPE
  XmVendorShellExtObject = POINTER TO _XmVendorShellExtRec;

  XmVendorShellExtObjectClass = POINTER TO _XmVendorShellExtClassRec;

  _XmVendorShellExtClassPart = RECORD
    delete_window_handler: Xt.XtCallbackProc;
    offset_handler       : Xt.XtCallbackProc;
    extension            : Xt.XtPointer;
  END;

  XmVendorShellExtClassPart = _XmVendorShellExtClassPart;

  XmVendorShellExtClassPartPtr = POINTER TO _XmVendorShellExtClassPart;

  _XmVendorShellExtClassRec = RECORD
    object_class : Xt.ObjectClassPart;
    ext_class    : XmExtClassPart;
    desktop_class: XmDesktopClassPart;
    shell_class  : XmShellExtClassPart;
    vendor_class : XmVendorShellExtClassPart;
  END;

  XmVendorShellExtClassRec = _XmVendorShellExtClassRec;

  _XmVendorShellExtPart = RECORD
    default_font_list   : XmFontList;
    focus_policy        : SHORTCARD;
    focus_data          : XmFocusData;
    delete_response     : SHORTCARD;
    unit_type           : SHORTCARD;
    mwm_hints           : MwmHints;
    mwm_info            : MwmInfo;
    mwm_menu            : Xt.String;
    focus_moved_callback: Xt.XtCallbackList;
   (*
    * internal fields
    *)
    old_managed         : Xt.Widget;
    xAtMap              : Xt.Position;
    yAtMap              : Xt.Position;
    xOffset             : Xt.Position;
    yOffset             : Xt.Position;
    lastOffsetSerial    : LONGCARD;
    lastMapRequest      : LONGCARD;
    externalReposition  : Xt.Boolean;
    mapStyle            : SHORTCARD;
    realize_callback    : Xt.XtCallbackList;
    grab_kind           : Xt.XtGrabKind;
    audible_warning     : Xt.Boolean;
    button_font_list    : XmFontList;
    label_font_list     : XmFontList;
    text_font_list      : XmFontList;
    input_method_string : Xt.String;
    preedit_type_string : Xt.String;
    light_threshold     : CARDINAL;
    dark_threshold      : CARDINAL;
    foreground_threshold: CARDINAL;
    im_height           : CARDINAL;
    im_info             : Xt.XtPointer;
    im_vs_height_set    : Xt.Boolean;
  END;

  XmVendorShellExtPart = _XmVendorShellExtPart;

  XmVendorShellExtPartPtr = POINTER TO _XmVendorShellExtPart;

  _XmVendorShellExtRec = RECORD
    object : Xt.ObjectPart;
    ext    : XmExtPart;
    desktop: XmDesktopPart;
    shell  : XmShellExtPart;
    vendor : XmVendorShellExtPart;
  END;

  XmVendorShellExtRec = _XmVendorShellExtRec;

VAR
  xmVendorShellExtObjectClass: Xt.WidgetClass;
  xmVendorShellExtClassRec: XmVendorShellExtClassRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmGetAudibleWarning ( w: Xt.Widget ): SHORTCARD;

PROCEDURE _XmGetIconPixmapName (  ): Xt.String;

PROCEDURE _XmClearIconPixmapName (  );

(********    End Private Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/DialogSEP.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2.3
 *)

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE XmIsDialogShellExt ( w: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / XmIsDialogShellExt ( w: Xt.Widget ): Xt.Boolean;

<* END *>

TYPE
  XmDialogShellExtObjectClass = POINTER TO _XmDialogShellExtClassRec;

  XmDialogShellExtObject = POINTER TO _XmDialogShellExtRec;

  _XmDialogShellExtClassPart = RECORD
    extension: Xt.XtPointer;   (* Pointer to extension record *)
  END;

  XmDialogShellExtClassPart = _XmDialogShellExtClassPart;

  XmDialogShellExtClassPartPtr = POINTER TO _XmDialogShellExtClassPart;

  _XmDialogShellExtClassRec = RECORD
    object_class : Xt.ObjectClassPart;
    ext_class    : XmExtClassPart;
    desktop_class: XmDesktopClassPart;
    shell_class  : XmShellExtClassPart;
    vendor_class : XmVendorShellExtClassPart;
    dialog_class : XmDialogShellExtClassPart;
  END;

  XmDialogShellExtClassRec = _XmDialogShellExtClassRec;

  _XmDialogShellExtPart = RECORD
    empty: SYSTEM.int;
  END;

  XmDialogShellExtPart = _XmDialogShellExtPart;

  _XmDialogShellExtRec = RECORD
    object : Xt.ObjectPart;
    ext    : XmExtPart;
    desktop: XmDesktopPart;
    shell  : XmShellExtPart;
    vendor : XmVendorShellExtPart;
    dialog : XmDialogShellExtPart;
  END;

  XmDialogShellExtRec = _XmDialogShellExtRec;

VAR
  xmDialogShellExtObjectClass: Xt.WidgetClass;
  xmDialogShellExtClassRec: XmDialogShellExtClassRec;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/DragDropP.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2.4 (Invited by Ego)
 *)

(* -------------------------------------------------- *)
(*                     Xm/DragC.h                     *)
(* -------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*  defines for the dragFinish completionStatus field  *)

CONST
  XmHELP = 2;

(*
 * Some global stuff that will go into Xm.h
 *)

TYPE
  XmID = CARDINAL;

(***********************************************************************
 *
 * DragContext
 *
 ***********************************************************************)

CONST
  _XA_MOTIF_DROP = '_MOTIF_DROP';
  _XA_DRAG_FAILURE = '_MOTIF_DRAG_FAILURE';
  _XA_DRAG_SUCCESS = '_MOTIF_DRAG_SUCCESS';

  XmTOP_LEVEL_ENTER = 0;
  XmTOP_LEVEL_LEAVE = 1;
  XmDRAG_MOTION = 2;
  XmDROP_SITE_ENTER = 3;
  XmDROP_SITE_LEAVE = 4;
  XmDROP_START = 5;
  XmDROP_FINISH = 6;
  XmDRAG_DROP_FINISH = 7;
  XmOPERATION_CHANGED = 8;

  XmDROP = 0;
  XmDROP_HELP = 1;
  XmDROP_CANCEL = 2;
  XmDROP_INTERRUPT = 3;

(*  values for operation  *)
  XmDROP_NOOP = 0;
  XmDROP_MOVE = 1;
  XmDROP_COPY = 2;
  XmDROP_LINK = 4;
  XmBLEND_ALL = 0;
  XmBLEND_STATE_SOURCE = 1;
  XmBLEND_JUST_SOURCE = 2;
  XmBLEND_NONE = 3;

  XmDROP_FAILURE = 0;
  XmDROP_SUCCESS = 1;

  XmCR_TOP_LEVEL_ENTER = 0;
  XmCR_TOP_LEVEL_LEAVE = 1;
  XmCR_DRAG_MOTION = 2;
  XmCR_DROP_SITE_ENTER = 3;
  XmCR_DROP_SITE_LEAVE = 4;
  XmCR_DROP_START = 5;
  XmCR_DROP_FINISH = 6;
  XmCR_DRAG_DROP_FINISH = 7;
  XmCR_OPERATION_CHANGED = 8;
  _XmNUMBER_DND_CB_REASONS = 9;

(*  Class record constants  *)

TYPE
  XmDragContextClass = POINTER TO _XmDragContextClassRec;

  XmDragContext = POINTER TO _XmDragContextRec;

  _XmAnyICCCallbackStruct = RECORD
    reason   : SYSTEM.int;
    event    : Xlib.PtrXEvent;
    timeStamp: X.Time;
  END;

  XmAnyICCCallbackStruct = _XmAnyICCCallbackStruct;

  XmAnyICCCallback = POINTER TO _XmAnyICCCallbackStruct;

  _XmTopLevelEnterCallbackStruct = RECORD
    reason           : SYSTEM.int;
    event            : Xlib.PtrXEvent;
    timeStamp        : X.Time;
    screen           : Xlib.PtrScreen;
   (*
    * the window field is different if this is an outbound or inbound
    * callback. Outbound == reciever, Inbound == initiator.
    *)
    window           : X.Window;
    x                : Xt.Position;
    y                : Xt.Position;
    dragProtocolStyle: SHORTCARD;
    iccHandle        : X.Atom;
  END;

  XmTopLevelEnterCallbackStruct = _XmTopLevelEnterCallbackStruct;

  XmTopLevelEnterCallback = POINTER TO _XmTopLevelEnterCallbackStruct;

  _XmTopLevelLeaveCallbackStruct = RECORD
    reason   : SYSTEM.int;
    event    : Xlib.PtrXEvent;
    timeStamp: X.Time;
    screen   : Xlib.PtrScreen;
    window   : X.Window;
  END;

  XmTopLevelLeaveCallbackStruct = _XmTopLevelLeaveCallbackStruct;

  XmTopLevelLeaveCallback = POINTER TO _XmTopLevelLeaveCallbackStruct;

(*
 * this message is sent from the receiver to the initiator to
 * indicate that the motion message with the associated timestamp has
 * caused a drop-site to be entered
 *)

  _XmDropSiteEnterCallbackStruct = RECORD
    reason        : SYSTEM.int;
    event         : Xlib.PtrXEvent;
    timeStamp     : X.Time;
    operation     : SHORTCARD;
    operations    : SHORTCARD;
    dropSiteStatus: SHORTCARD;
    x             : Xt.Position;
    y             : Xt.Position;
  END;

  XmDropSiteEnterCallbackStruct = _XmDropSiteEnterCallbackStruct;

  XmDropSiteEnterCallback = POINTER TO _XmDropSiteEnterCallbackStruct;

(*
 * this message is sent from the receiver to the initiator to
 * indicate that the motion message with the associated timestamp has
 * caused a drop-site to be left
 *)

  _XmDropSiteLeaveCallbackStruct = RECORD
    reason   : SYSTEM.int;
    event    : Xlib.PtrXEvent;
    timeStamp: X.Time;
  END;

  XmDropSiteLeaveCallbackStruct = _XmDropSiteLeaveCallbackStruct;

  XmDropSiteLeaveCallback = POINTER TO _XmDropSiteLeaveCallbackStruct;

  _XmDragMotionCallbackStruct = RECORD
    reason        : SYSTEM.int;
    event         : Xlib.PtrXEvent;
    timeStamp     : X.Time;
    operation     : SHORTCARD;
    operations    : SHORTCARD;
    dropSiteStatus: SHORTCARD;
    x             : Xt.Position;
    y             : Xt.Position;
  END;

  XmDragMotionCallbackStruct = _XmDragMotionCallbackStruct;

  XmDragMotionCallback = POINTER TO _XmDragMotionCallbackStruct;

  _XmOperationChangedCallbackStruct = RECORD
    reason        : SYSTEM.int;
    event         : Xlib.PtrXEvent;
    timeStamp     : X.Time;
    operation     : SHORTCARD;
    operations    : SHORTCARD;
    dropSiteStatus: SHORTCARD;
  END;

  XmOperationChangedCallbackStruct = _XmOperationChangedCallbackStruct;

  XmOperationChangedCallback = POINTER TO _XmOperationChangedCallbackStruct;

  _XmDropStartCallbackStruct = RECORD
    reason        : SYSTEM.int;
    event         : Xlib.PtrXEvent;
    timeStamp     : X.Time;
    operation     : SHORTCARD;
    operations    : SHORTCARD;
    dropSiteStatus: SHORTCARD;
    dropAction    : SHORTCARD;
    x             : Xt.Position;
    y             : Xt.Position;
    window        : X.Window;
    iccHandle     : X.Atom;
  END;

  XmDropStartCallbackStruct = _XmDropStartCallbackStruct;

  XmDropStartCallback = POINTER TO _XmDropStartCallbackStruct;

  _XmDropFinishCallbackStruct = RECORD
    reason          : SYSTEM.int;
    event           : Xlib.PtrXEvent;
    timeStamp       : X.Time;
    operation       : SHORTCARD;
    operations      : SHORTCARD;
    dropSiteStatus  : SHORTCARD;
    dropAction      : SHORTCARD;
    completionStatus: SHORTCARD;
  END;

  XmDropFinishCallbackStruct = _XmDropFinishCallbackStruct;

  XmDropFinishCallback = POINTER TO _XmDropFinishCallbackStruct;

  _XmDragDropFinishCallbackStruct = RECORD
    reason   : SYSTEM.int;
    event    : Xlib.PtrXEvent;
    timeStamp: X.Time;
  END;

  XmDragDropFinishCallbackStruct = _XmDragDropFinishCallbackStruct;

  XmDragDropFinishCallback = POINTER TO _XmDragDropFinishCallbackStruct;

VAR
  xmDragContextClass: Xt.WidgetClass;

(********    Public Function Declarations    ********)

PROCEDURE XmDragStart ( w: Xt.Widget;
                        VAR event: Xlib.XEvent;
                        args: Xt.ArgList;
                        numArgs: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmDragCancel ( dragContext: Xt.Widget );

PROCEDURE XmTargetsAreCompatible ( dpy: Xlib.PtrDisplay;
                                   exportTargets: X.PAAtom;
                                   numExportTargets: Xt.Cardinal;
                                   importTargets: X.PAAtom;
                                   numImportTargets: Xt.Cardinal ): Xt.Boolean;

(********    End Public Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/DragIcon.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE XmIsDragIconObjectClass ( w: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / XmIsDragIconObjectClass ( w: Xt.Widget ): Xt.Boolean;

<* END *>

CONST
  XmATTACH_NORTH_WEST = 0;
  XmATTACH_NORTH = 1;
  XmATTACH_NORTH_EAST = 2;
  XmATTACH_EAST = 3;
  XmATTACH_SOUTH_EAST = 4;
  XmATTACH_SOUTH = 5;
  XmATTACH_SOUTH_WEST = 6;
  XmATTACH_WEST = 7;
  XmATTACH_CENTER = 8;
  XmATTACH_HOT = 9;

TYPE
  XmDragIconObject = POINTER TO _XmDragIconRec;

  XmDragIconObjectClass = POINTER TO _XmDragIconClassRec;

VAR
  xmDragIconObjectClass: Xt.WidgetClass;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateDragIcon ( parent: Xt.Widget;
                             name: ARRAY OF CHAR;
                             argList: Xt.ArgList;
                             argCount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/DragIconP.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2.3
 *)

TYPE
  XmCloneVisualProc = PROCEDURE ( XmDragIconObject,
                                  Xt.Widget,
                                  Xt.Widget );

  XmMovePixmapProc = PROCEDURE ( XmDragIconObject,
                                 XmDragIconObject,
                               	 XmDragIconObject,
                                 Xt.Position,
                               	 Xt.Position );

  _XmDragIconClassPart = RECORD
    extension: Xt.XtPointer;
  END;

  XmDragIconClassPart = _XmDragIconClassPart;

  _XmDragIconClassRec = RECORD
    rectangle_class: Xt.RectObjClassPart;
    dragIcon_class : XmDragIconClassPart;
  END;

  XmDragIconClassRec = _XmDragIconClassRec;

  _XmDragIconPart = RECORD
    depth         : Xt.Cardinal;
    pixmap        : X.Pixmap;
    width         : Xt.Dimension;
    height        : Xt.Dimension;
    mask          : X.Pixmap;
    hot_x         : Xt.Position;
    hot_y         : Xt.Position;
    offset_x      : Xt.Position;
    offset_y      : Xt.Position;
    attachment    : SHORTCARD;
    isDirty       : Xt.Boolean;
    region        : Xutil.Region;
    restore_region: Xutil.Region;
    x_offset      : Xt.Position;
    y_offset      : Xt.Position;
  END;

  XmDragIconPart = _XmDragIconPart;

  XmDragIconPartPtr = POINTER TO _XmDragIconPart;

  _XmDragIconRec = RECORD
    object   : Xt.ObjectPart;
    rectangle: Xt.RectObjPart;
    drag     : XmDragIconPart;
  END;

  XmDragIconRec = _XmDragIconRec;

VAR
  xmDragIconClassRec: XmDragIconClassRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmDestroyDefaultDragIcon ( icon: XmDragIconObject );

PROCEDURE _XmDragIconIsDirty ( icon: XmDragIconObject ): Xt.Boolean;

PROCEDURE _XmDragIconClean ( icon1: XmDragIconObject; icon2: XmDragIconObject;
                             icon3: XmDragIconObject );

PROCEDURE _XmGetTextualDragIcon ( w: Xt.Widget ): Xt.Widget;

(********    End Private Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/DragOverS.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2.3
 *)

(***********************************************************************
 *
 * DragOverShell Widget
 *
 ***********************************************************************)

(*  Class record constants  *)

TYPE
  XmDragOverShellWidget = POINTER TO _XmDragOverShellRec;

  XmDragOverShellWidgetClass = POINTER TO _XmDragOverShellClassRec;

VAR
  xmDragOverShellWidgetClass: Xt.WidgetClass;

(*  DON'T ADD STUFF AFTER THIS #endif  *)

(* ------------------------------------------------------- *)
(*                     Xm/DragOverSP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE DOExpose ( do: Xt.Widget );

<* ELSE *>

PROCEDURE / DOExpose ( do: Xt.Widget );

<* END *>

(*
 * DRAGOVER SHELL
 *)

TYPE
  _XmDragOverShellClassPart = RECORD
    extension: Xt.XtPointer;
  END;

  XmDragOverShellClassPart = _XmDragOverShellClassPart;

(*  Full class record declaration  *)

  _XmDragOverShellClassRec = RECORD
    core_class          : Xt.CoreClassPart;
    composite_class     : Xt.CompositeClassPart;
    shell_class         : ShellP.ShellClassPart;
    wm_shell_class      : ShellP.WMShellClassPart;
    vendor_shell_class  : ShellP.VendorShellClassPart;
    dragOver_shell_class: XmDragOverShellClassPart;
  END;

  XmDragOverShellClassRec = _XmDragOverShellClassRec;

  _XmBackingRec = RECORD
    x     : Xt.Position;
    y     : Xt.Position;
    pixmap: X.Pixmap;
  END;

  XmBackingRec = _XmBackingRec;

  XmBacking = POINTER TO _XmBackingRec;

  _XmDragOverBlendRec = RECORD
    sourceIcon: XmDragIconObject; (*  source icon  *)
    sourceX   : Xt.Position;      (*  source location in blend  *)
    sourceY   : Xt.Position;      (*  source location in blend  *)
    mixedIcon : XmDragIconObject; (*  blended icon  *)
    gc        : Xlib.GC;          (*  appropriate depth  *)
  END;

  XmDragOverBlendRec = _XmDragOverBlendRec;

  XmDragOverBlend = POINTER TO _XmDragOverBlendRec;

  _XmDragOverShellPart = RECORD
    hotX            : Xt.Position;        (*  current hotX  *)
    hotY            : Xt.Position;        (*  current hotY  *)
    cursorState     : SHORTCARD;          (*  current cursor state  *)
    mode            : SHORTCARD;
    activeMode      : SHORTCARD;
    initialX        : Xt.Position;        (*  initial hotX  *)
    initialY        : Xt.Position;        (*  initial hotY  *)
    stateIcon       : XmDragIconObject;   (*  current state icon  *)
    opIcon          : XmDragIconObject;   (*  current operation icon  *)
    cursorBlend     : XmDragOverBlendRec; (*  cursor blending  *)
    rootBlend       : XmDragOverBlendRec; (*  pixmap or window blending  *)
    cursorForeground: Xt.Pixel;
    cursorBackground: Xt.Pixel;
    ncCursor        : X.Cursor;           (*  noncached cursor  *)
    activeCursor    : X.Cursor;           (*  the current cursor  *)
    backing         : XmBackingRec;       (*  backing store for pixdrag  *)
    tmpPix          : X.Pixmap;           (*  temp storage for pixdrag  *)
    tmpBit          : X.Pixmap;           (*  temp storage for pixdrag  *)
    isVisible       : Xt.Boolean;         (*  shell is visible  *)
  END;

  XmDragOverShellPart = _XmDragOverShellPart;

  _XmDragOverShellRec = RECORD
    core     : Xt.CorePart;
    composite: Xt.CompositePart;
    shell    : ShellP.ShellPart;
    wm       : ShellP.WMShellPart;
    vendor   : ShellP.VendorShellPart;
    drag     : XmDragOverShellPart;
  END;

  XmDragOverShellRec = _XmDragOverShellRec;

VAR
  xmDragOverShellClassRec: XmDragOverShellClassRec;

(* ----------------------------------------------------- *)
(*                     Xm/DropSMgr.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

CONST
  XmCR_DROP_SITE_LEAVE_MESSAGE = 1;
  XmCR_DROP_SITE_ENTER_MESSAGE = 2;
  XmCR_DROP_SITE_MOTION_MESSAGE = 3;
  XmCR_DROP_MESSAGE = 4;
  XmNO_DROP_SITE = 1;
  XmINVALID_DROP_SITE = 2;
  XmDROP_SITE_INVALID = XmINVALID_DROP_SITE;
  XmVALID_DROP_SITE = 3;
  XmDROP_SITE_VALID = XmVALID_DROP_SITE;

(*  begin fix for CR 5754  *)
(*  documented values are XmDROP_SITE_VALID and XmDROP_SITE_INVALID.
    However, we can't just throw out the incorrect Xm[IN]VALID_DROP_SITE
    now since people have probably started using them. Instead, we just
    define the correct values using the incorrect ones.
*)
  XmDRAG_UNDER_NONE = 0;
  XmDRAG_UNDER_PIXMAP = 1;
  XmDRAG_UNDER_SHADOW_IN = 2;
  XmDRAG_UNDER_SHADOW_OUT = 3;
  XmDRAG_UNDER_HIGHLIGHT = 4;

  XmDROP_SITE_SIMPLE = 0;
  XmDROP_SITE_COMPOSITE = 1;
  XmDROP_SITE_SIMPLE_CLIP_ONLY = 128;
  XmDROP_SITE_COMPOSITE_CLIP_ONLY = 129;

  XmABOVE = 0;
  XmBELOW = 1;

  XmDROP_SITE_ACTIVE = 0;
  XmDROP_SITE_INACTIVE = 1;

TYPE
  _XmDragProcCallbackStruct = RECORD
    reason        : SYSTEM.int;
    event         : Xlib.PtrXEvent;
    timeStamp     : X.Time;
    dragContext   : Xt.Widget;
    x             : Xt.Position;
    y             : Xt.Position;
    dropSiteStatus: SHORTCARD;
    operation     : SHORTCARD;
    operations    : SHORTCARD;
    animate       : Xt.Boolean;
  END;

  XmDragProcCallbackStruct = _XmDragProcCallbackStruct;

  XmDragProcCallback = POINTER TO _XmDragProcCallbackStruct;

  _XmDropProcCallbackStruct = RECORD
    reason        : SYSTEM.int;
    event         : Xlib.PtrXEvent;
    timeStamp     : X.Time;
    dragContext   : Xt.Widget;
    x             : Xt.Position;
    y             : Xt.Position;
    dropSiteStatus: SHORTCARD;
    operation     : SHORTCARD;
    operations    : SHORTCARD;
    dropAction    : SHORTCARD;
  END;

  XmDropProcCallbackStruct = _XmDropProcCallbackStruct;

  XmDropProcCallback = POINTER TO _XmDropProcCallbackStruct;

  _XmDropSiteVisualsRec = RECORD
    background        : Xt.Pixel;
    foreground        : Xt.Pixel;
    topShadowColor    : Xt.Pixel;
    topShadowPixmap   : X.Pixmap;
    bottomShadowColor : Xt.Pixel;
    bottomShadowPixmap: X.Pixmap;
    shadowThickness   : Xt.Dimension;
    highlightColor    : Xt.Pixel;
    highlightPixmap   : X.Pixmap;
    highlightThickness: Xt.Dimension;
    borderWidth       : Xt.Dimension;
  END;

  XmDropSiteVisualsRec = _XmDropSiteVisualsRec;

  XmDropSiteVisuals = POINTER TO _XmDropSiteVisualsRec;

(*  DropSite Widget  *)

  XmDropSiteManagerObjectClass = POINTER TO _XmDropSiteManagerClassRec;

  XmDropSiteManagerObject = POINTER TO _XmDropSiteManagerRec;

VAR
  xmDropSiteManagerObjectClass: Xt.WidgetClass;

(********    Public Function Declarations    ********)

PROCEDURE XmDropSiteRegister ( widget: Xt.Widget;
                               args: Xt.ArgList;
                               argCount: Xt.Cardinal );

PROCEDURE XmDropSiteUnregister ( widget: Xt.Widget );

PROCEDURE XmDropSiteStartUpdate ( refWidget: Xt.Widget );

PROCEDURE XmDropSiteUpdate ( enclosingWidget: Xt.Widget;
                             args: Xt.ArgList;
                             argCount: Xt.Cardinal );

PROCEDURE XmDropSiteEndUpdate ( refWidget: Xt.Widget );

PROCEDURE XmDropSiteRetrieve ( enclosingWidget: Xt.Widget;
                               args: Xt.ArgList;
                               argCount: Xt.Cardinal );

PROCEDURE XmDropSiteQueryStackingOrder ( widget: Xt.Widget;
                                         VAR parent_rtn: Xt.Widget;
                                         VAR children_rtn: Xt.WidgetList;
                                         VAR num_children_rtn: Xt.Cardinal ): SYSTEM.int;

PROCEDURE XmDropSiteConfigureStackingOrder ( widget: Xt.Widget;
                                             sibling: Xt.Widget;
                                             stack_mode: Xt.Cardinal );

PROCEDURE XmDropSiteGetActiveVisuals ( widget: Xt.Widget ): XmDropSiteVisuals;

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/DropSMgrP.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2.4
 *)

TYPE
  XmDSMCreateInfoProc = PROCEDURE ( XmDropSiteManagerObject,
                                    Xt.Widget,
                                    Xt.ArgList,
                                    Xt.Cardinal );

  XmDSMDestroyInfoProc = PROCEDURE ( XmDropSiteManagerObject,
                                     Xt.Widget );

  XmDSMStartUpdateProc = PROCEDURE ( XmDropSiteManagerObject,
                                     Xt.Widget );

  XmDSMRetrieveInfoProc = PROCEDURE ( XmDropSiteManagerObject,
                                      Xt.Widget,
                                      Xt.ArgList,
                                      Xt.Cardinal );

  XmDSMUpdateInfoProc = PROCEDURE ( XmDropSiteManagerObject,
                                    Xt.Widget,
                                    Xt.ArgList,
                                    Xt.Cardinal );

  XmDSMEndUpdateProc = PROCEDURE ( XmDropSiteManagerObject,
                                   Xt.Widget );

  XmDSMUpdateProc = PROCEDURE ( XmDropSiteManagerObject,
                                Xt.XtPointer,
                              	Xt.XtPointer );

  XmDSMProcessMotionProc = PROCEDURE ( XmDropSiteManagerObject,
                                       Xt.XtPointer,
                                       Xt.XtPointer );

  XmDSMProcessDropProc = PROCEDURE ( XmDropSiteManagerObject,
                                     Xt.XtPointer,
                                     Xt.XtPointer );

  XmDSMOperationChangedProc = PROCEDURE ( XmDropSiteManagerObject,
                                          Xt.XtPointer,
                                          Xt.XtPointer );

  XmDSMChangeRootProc = PROCEDURE ( XmDropSiteManagerObject,
                                    Xt.XtPointer,
                                    Xt.XtPointer );

  XmDSMInsertInfoProc = PROCEDURE ( XmDropSiteManagerObject,
                                    Xt.XtPointer,
                                    Xt.XtPointer );

  XmDSMRemoveInfoProc = PROCEDURE ( XmDropSiteManagerObject,
                                    Xt.XtPointer );

  XmDSMSyncTreeProc = PROCEDURE ( XmDropSiteManagerObject,
                                  Xt.Widget );

  XmDSMGetTreeFromDSMProc = PROCEDURE ( XmDropSiteManagerObject,
                                      	Xt.Widget,
                                        Xt.XtPointer ): SYSTEM.int;

  XmDSMCreateDSInfoTable = PROCEDURE ( XmDropSiteManagerObject );

  XmDSMDestroyDSInfoTable = PROCEDURE ( XmDropSiteManagerObject );

  XmDSMRegisterInfoProc = PROCEDURE ( XmDropSiteManagerObject,
                                      Xt.Widget,
                                      Xt.XtPointer );

  XmDSMWidgetToInfoProc = PROCEDURE ( XmDropSiteManagerObject,
                                      Xt.Widget ): Xt.XtPointer;

  XmDSMUnregisterInfoProc = PROCEDURE ( XmDropSiteManagerObject,
                                      	Xt.XtPointer );

  XmDropSiteManagerClassPart = RECORD
    createInfo      : XmDSMCreateInfoProc;
    destroyInfo     : XmDSMDestroyInfoProc;
    startUpdate     : XmDSMStartUpdateProc;
    retrieveInfo    : XmDSMRetrieveInfoProc;
    updateInfo      : XmDSMUpdateInfoProc;
    endUpdate       : XmDSMEndUpdateProc;
(*  Used by DragController Object  *)
    updateDSM       : XmDSMUpdateProc;
(*  Used by update proc  *)
    processMotion   : XmDSMProcessMotionProc;
    processDrop     : XmDSMProcessDropProc;
    operationChanged: XmDSMOperationChangedProc;
    changeRoot      : XmDSMChangeRootProc;
(*  Used to manage DropSites  *)
    insertInfo      : XmDSMInsertInfoProc;
(*  Need a get and a put function for update?  *)
    removeInfo      : XmDSMRemoveInfoProc;
(*  Used to manage the pre-register information  *)
    syncTree        : XmDSMSyncTreeProc;
    getTreeFromDSM  : XmDSMGetTreeFromDSMProc;
(*  Used to hash between widgets and info  *)
    createTable     : XmDSMCreateDSInfoTable;
    destroyTable    : XmDSMDestroyDSInfoTable;
    registerInfo    : XmDSMRegisterInfoProc;
    widgetToInfo    : XmDSMWidgetToInfoProc;
    unregisterInfo  : XmDSMUnregisterInfoProc;
    extension       : Xt.XtPointer;
  END;

(*   Full class record declaration for dropSite class   *)

  _XmDropSiteManagerClassRec = RECORD
    object_class     : Xt.ObjectClassPart;
    dropManager_class: XmDropSiteManagerClassPart;
  END;

  XmDropSiteManagerClassRec = _XmDropSiteManagerClassRec;

VAR
  xmDropSiteManagerClassRec: XmDropSiteManagerClassRec;

(*  Macros for calling methods  *)

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE DSMCreateInfo ( dsm, widget: Xt.Widget;
                          args: Xt.ArgList;
                          numArgs: Xt.Cardinal );
PROCEDURE DSMDestroyInfo ( dsm, widget: Xt.Widget );
PROCEDURE DSMStartUpdate ( dsm, widget: Xt.Widget );
PROCEDURE DSMRetrieveInfo ( dsm, widget: Xt.Widget;
                            args: Xt.ArgList;
                            numArgs: Xt.Cardinal );
PROCEDURE DSMUpdateInfo ( dsm, widget: Xt.Widget;
                          args: Xt.ArgList;
                          numArgs: Xt.Cardinal );
PROCEDURE DSMEndUpdate ( dsm, widget: Xt.Widget ): Xt.Boolean;
PROCEDURE DSMUpdate ( dsm: Xt.Widget;
                      clientData, callData: Xt.XtPointer );
PROCEDURE DSMProcessMotion ( dsm: Xt.Widget;
                             clientData, callData: Xt.XtPointer );
PROCEDURE DSMProcessDrop ( dsm: Xt.Widget;
                           clientData, callData: Xt.XtPointer );
PROCEDURE DSMOperationChanged ( dsm: Xt.Widget;
                                clientData, callData: Xt.XtPointer );
PROCEDURE DSMChangeRoot ( dsm: Xt.Widget;
                          clientData, callData: Xt.XtPointer );
PROCEDURE DSMInsertInfo ( dsm: Xt.Widget;
                          info, call_data: Xt.XtPointer );
PROCEDURE DSMRemoveInfo ( dsm: Xt.Widget;
                          info: Xt.XtPointer );
PROCEDURE DSMSyncTree ( dsm, shell: Xt.Widget );
PROCEDURE DSMGetTreeFromDSM ( dsm, shell: Xt.Widget;
                              dataPtr: Xt.XtPointer );
PROCEDURE DSMCreateTable ( dsm: Xt.Widget );
PROCEDURE DSMDestroyTable ( dsm: Xt.Widget );
PROCEDURE DSMRegisterInfo ( dsm, widget: Xt.Widget;
                            info: Xt.XtPointer );
PROCEDURE DSMWidgetToInfo ( dsm, widget: Xt.Widget );
PROCEDURE DSMUnregisterInfo ( dsm: Xt.Widget;
                              info: Xt.XtPointer );

<* ELSE *>

PROCEDURE  / DSMCreateInfo ( dsm, widget: Xt.Widget;
                             args: Xt.ArgList;
                             numArgs: Xt.Cardinal );
PROCEDURE  / DSMDestroyInfo ( dsm, widget: Xt.Widget ): Xt.Boolean;
PROCEDURE  / DSMStartUpdate ( dsm, widget: Xt.Widget ): Xt.Boolean;
PROCEDURE  / DSMRetrieveInfo ( dsm, widget: Xt.Widget;
                               args: Xt.ArgList;
                               numArgs: Xt.Cardinal );
PROCEDURE  / DSMUpdateInfo ( dsm, widget: Xt.Widget;
                             args: Xt.ArgList;
                             numArgs: Xt.Cardinal );
PROCEDURE  / DSMEndUpdate ( dsm, widget: Xt.Widget ): Xt.Boolean;
PROCEDURE  / DSMUpdate ( dsm: Xt.Widget;
                         clientData, callData: Xt.XtPointer );
PROCEDURE  / DSMProcessMotion ( dsm: Xt.Widget;
                                clientData, callData: Xt.XtPointer );
PROCEDURE  / DSMProcessDrop ( dsm: Xt.Widget;
                              clientData, callData: Xt.XtPointer );
PROCEDURE  / DSMOperationChanged ( dsm: Xt.Widget;
                                   clientData, callData: Xt.XtPointer );
PROCEDURE  / DSMChangeRoot ( dsm: Xt.Widget;
                             clientData, callData: Xt.XtPointer );
PROCEDURE  / DSMInsertInfo ( dsm: Xt.Widget;
                             info, call_data: Xt.XtPointer );
PROCEDURE  / DSMRemoveInfo ( dsm: Xt.Widget;
                             info: Xt.XtPointer );
PROCEDURE  / DSMSyncTree ( dsm, shell: Xt.Widget );
PROCEDURE  / DSMGetTreeFromDSM ( dsm, shell: Xt.Widget;
                                 dataPtr: Xt.XtPointer );
PROCEDURE  / DSMCreateTable ( dsm: Xt.Widget );
PROCEDURE  / DSMDestroyTable ( dsm: Xt.Widget );
PROCEDURE  / DSMRegisterInfo ( dsm, widget: Xt.Widget;
                               info: Xt.XtPointer );
PROCEDURE  / DSMWidgetToInfo ( dsm, widget: Xt.Widget );
PROCEDURE  / DSMUnregisterInfo ( dsm: Xt.Widget;
                                 info: Xt.XtPointer );

<* END *>

(*  Internal update struct  *)

TYPE
  _XmDropSiteUpdateInfo = POINTER TO __XmDropSiteUpdateInfoRec;

  __XmDropSiteUpdateInfoRec = RECORD
    dsm      : XmDropSiteManagerObject;
    refWidget: Xt.Widget;
    next     : _XmDropSiteUpdateInfo;
  END;

  _XmDropSiteUpdateInfoRec = __XmDropSiteUpdateInfoRec;

(*  DropSiteManager instance record  *)

  _XmDropSiteManagerPart = RECORD
    notifyProc           : Xt.XtCallbackProc;
    treeUpdateProc       : Xt.XtCallbackProc;
    client_data          : Xt.XtPointer;
    dragUnderData        : Xt.XtPointer;
    curInfo              : Xt.XtPointer;
    curTime              : X.Time;
    curX                 : Xt.Position;
    curY                 : Xt.Position;
    oldX                 : Xt.Position;
    oldY                 : Xt.Position;
    curDropSiteStatus    : SHORTCARD;
    curDragContext       : Xt.Widget;
    curAnimate           : Xt.Boolean;
    curOperations        : SHORTCARD;
    curOperation         : SHORTCARD;
    curAncestorClipRegion: XmRegion;
    newAncestorClipRegion: XmRegion;
    dsTable              : Xt.XtPointer;
    dsRoot               : Xt.XtPointer;
    rootX                : Xt.Position;
    rootY                : Xt.Position;
    rootW                : Xt.Dimension;
    rootH                : Xt.Dimension;
    clipperList          : Xt.XtPointer;
    updateInfo           : _XmDropSiteUpdateInfo;
  END;

  XmDropSiteManagerPart = _XmDropSiteManagerPart;

  XmDropSiteManagerPartPtr = POINTER TO _XmDropSiteManagerPart;

(*  Full instance record declaration  *)

  _XmDropSiteManagerRec = RECORD
    object     : Xt.ObjectPart;
    dropManager: XmDropSiteManagerPart;
  END;

  XmDropSiteManagerRec = _XmDropSiteManagerRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmDSMUpdate ( dsm: XmDropSiteManagerObject;
                         clientData: Xt.XtPointer;
                         callData: Xt.XtPointer );

PROCEDURE _XmDSMGetTreeFromDSM ( dsm: XmDropSiteManagerObject;
                                 shell: Xt.Widget;
                                 dataPtr: Xt.XtPointer ): SYSTEM.int;

PROCEDURE _XmDropSiteShell ( widget: Xt.Widget ): Xt.Boolean;

PROCEDURE _XmDropSiteWrapperCandidate ( widget: Xt.Widget ): Xt.Boolean;

PROCEDURE _XmGetActiveDropSite ( widget: Xt.Widget ): Xt.Widget;

PROCEDURE _XmSyncDropSiteTree ( shell: Xt.Widget );

PROCEDURE _XmIEndUpdate ( client_data: Xt.XtPointer;
                          VAR interval_id: Xt.XtIntervalId );

(********    End Private Function Declarations    ********)

(* --------------------------------------------------- *)
(*                     Xm/DragCP.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2.4
 *)

(***********************************************************************
 *
 * DragContext (RootWrapper) Widget Private Data
 *
 ***********************************************************************)

TYPE
  XmDragStartProc = PROCEDURE ( XmDragContext, Xt.Widget, Xlib.PtrXEvent );

  XmDragCancelProc = PROCEDURE ( XmDragContext );

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE _XmDragStart ( dc, srcW: Xt.Widget;
                         event: Xlib.PtrXEvent);
PROCEDURE _XmDragCancel ( dc: Xt.Widget );

<* ELSE *>

PROCEDURE / _XmDragStart ( dc, srcW: Xt.Widget;
                         event: Xlib.PtrXEvent);
PROCEDURE / _XmDragCancel ( dc: Xt.Widget );

<* END *>

TYPE
  _XmDragContextClassPart = RECORD
    start    : XmDragStartProc;
    cancel   : XmDragCancelProc;
    extension: Xt.XtPointer;
  END;

  XmDragContextClassPart = _XmDragContextClassPart;

  _XmDragContextClassRec = RECORD
    core_class: Xt.CoreClassPart;
    drag_class: XmDragContextClassPart;
  END;

  XmDragContextClassRec = _XmDragContextClassRec;

VAR
  xmDragContextClassRec: XmDragContextClassRec;

CONST
  XtDragByPoll = 0;
  XtDragByEvent = 1;

TYPE
  XmDragReceiverInfoStruct = RECORD
    frame            : X.Window;
    window           : X.Window;
    shell            : Xt.Widget;
    flags            : SHORTCARD;
    dragProtocolStyle: SHORTCARD;
    xOrigin          : SYSTEM.int;
    yOrigin          : SYSTEM.int;
    width            : CARDINAL;
    height           : CARDINAL;
    depth            : CARDINAL;
    iccInfo          : Xt.XtPointer;
  END;

  XmDragReceiverInfo = POINTER TO XmDragReceiverInfoStruct;

  _XmConvertSelectionRec = RECORD
    CASE : INTEGER OF
       0: sel_incr: Xt.XtConvertSelectionIncrProc;
      |1: sel     : Xt.XtConvertSelectionProc;
    END;
  END;

  XmConvertSelectionRec = _XmConvertSelectionRec;

<*- GENTYPEDEF *>

  PtrXmDragReceiverInfoStruct = POINTER TO XmDragReceiverInfoStruct;

<*+ GENTYPEDEF *>

  XmDragReceiverInfoStructList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF XmDragReceiverInfoStruct;

  _XmDragContextPart = RECORD
(****  resources ****)
    exportTargets           : XmKeySymTable;
    numExportTargets        : Xt.Cardinal;
    convertProc             : XmConvertSelectionRec;
    clientData              : Xt.XtPointer;
    sourceCursorIcon        : XmDragIconObject;
    stateCursorIcon         : XmDragIconObject;
    operationCursorIcon     : XmDragIconObject;
    sourcePixmapIcon        : XmDragIconObject;
    cursorBackground        : Xt.Pixel;
    cursorForeground        : Xt.Pixel;
    validCursorForeground   : Xt.Pixel;
    invalidCursorForeground : Xt.Pixel;
    noneCursorForeground    : Xt.Pixel;
    dragMotionCallback      : Xt.XtCallbackList;
    operationChangedCallback: Xt.XtCallbackList;
    siteEnterCallback       : Xt.XtCallbackList;
    siteLeaveCallback       : Xt.XtCallbackList;
    topLevelEnterCallback   : Xt.XtCallbackList;
    topLevelLeaveCallback   : Xt.XtCallbackList;
    dropStartCallback       : Xt.XtCallbackList;
    dropFinishCallback      : Xt.XtCallbackList;
    dragDropFinishCallback  : Xt.XtCallbackList;
    dragOperations          : SHORTCARD;
    incremental             : Xt.Boolean;
    blendModel              : SHORTCARD;
(*  private resources  *)
    srcWindow               : X.Window;
    dragStartTime           : X.Time;
    iccHandle               : X.Atom;
    sourceWidget            : Xt.Widget;
    sourceIsExternal        : Xt.Boolean;
(**** instance data ****)
    topWindowsFetched       : Xt.Boolean;
    commType                : SHORTCARD;
    animationType           : SHORTCARD;
    operation               : SHORTCARD;
    operations              : SHORTCARD;
    lastEventState          : CARDINAL;
    dragCompletionStatus    : SHORTCARD;
    dragDropCompletionStatus: SHORTCARD;
    forceIPC                : Xt.Boolean;
    serverGrabbed           : Xt.Boolean;
    useLocal                : Xt.Boolean;
    inDropSite              : Xt.Boolean;
    dragTimerId             : Xt.XtIntervalId;
    roundOffTime            : X.Time;
    lastChangeTime          : X.Time;
    crossingTime            : X.Time;
    dragFinishTime          : X.Time;
    dropFinishTime          : X.Time;
    dropSelection           : X.Atom;
    srcShell                : Xt.Widget;
    startX                  : Xt.Position;
    startY                  : Xt.Position;
    siteID                  : XmID;
    currScreen              : Xlib.PtrScreen;
    currWmRoot              : X.Window;
    curDragOver             : XmDragOverShellWidget;
    origDragOver            : XmDragOverShellWidget;
    currReceiverInfo        : PtrXmDragReceiverInfoStruct;
    rootReceiverInfo        : PtrXmDragReceiverInfoStruct;
    receiverInfos           : XmDragReceiverInfoStructList;
    numReceiverInfos        : Xt.Cardinal;
    maxReceiverInfos        : Xt.Cardinal;
    trackingMode            : SHORTCARD;
    activeProtocolStyle     : SHORTCARD;
    activeBlendModel        : SHORTCARD;
    dragDropCancelEffect    : Xt.Boolean;
  END;

  XmDragContextPart = _XmDragContextPart;

  _XmDragContextRec = RECORD
    core: Xt.CorePart;
    drag: XmDragContextPart;
  END;

  XmDragContextRec = _XmDragContextRec;

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE _XmDCtoDD ( dc: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / _XmDCtoDD ( dc: Xt.Widget ): Xt.Boolean;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmAllocReceiverInfo ( dc: XmDragContext ): XmDragReceiverInfo;

PROCEDURE _XmGetActiveProtocolStyle ( w: Xt.Widget ): SHORTCARD;

(********    End Private Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/DropTrans.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2
 *)

CONST
  XmTRANSFER_FAILURE = 0;
  XmTRANSFER_SUCCESS = 1;

VAR
  xmDropTransferObjectClass: Xt.WidgetClass;

TYPE
  XmDropTransferObjectClass = POINTER TO _XmDropTransferClassRec;

  XmDropTransferObject = POINTER TO _XmDropTransferRec;

  _XmDropTransferEntryRec = RECORD
    client_data: Xt.XtPointer;
    target     : X.Atom;
  END;

  XmDropTransferEntryRec = _XmDropTransferEntryRec;

  XmDropTransferEntry = POINTER TO _XmDropTransferEntryRec;

(********    Public Function Declarations    ********)

PROCEDURE XmDropTransferStart ( refWidget: Xt.Widget;
                                args: Xt.ArgList;
                                argCount: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmDropTransferAdd ( widget: Xt.Widget;
                              transfers: XmDropTransferEntry;
                              num_transfers: Xt.Cardinal );

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/DropTransP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*   DropTransfer class structure   *)

TYPE
  XmDropTransferStartTransferProc = PROCEDURE ( Xt.Widget,
                                              	Xt.ArgList,
                                              	Xt.Cardinal ):
                                              	Xt.Widget;

  XmDropTransferAddTransferProc = PROCEDURE ( Xt.Widget,
                                              XmDropTransferEntry,
                                              Xt.Cardinal );

  _XmDropTransferClassPart = RECORD
    start_drop_transfer: XmDropTransferStartTransferProc;
    add_drop_transfer  : XmDropTransferAddTransferProc;
    extension          : Xt.XtPointer;
  END;

  XmDropTransferClassPart = _XmDropTransferClassPart;

(*   Full class record declaration  *)

  _XmDropTransferClassRec = RECORD
    object_class      : Xt.ObjectClassPart;
    dropTransfer_class: XmDropTransferClassPart;
  END;

  XmDropTransferClassRec = _XmDropTransferClassRec;

  _XmDropTransferListRec = RECORD
    transfer_list: XmDropTransferEntry;
    num_transfers: Xt.Cardinal;
  END;

  XmDropTransferListRec = _XmDropTransferListRec;

  XmDropTransferList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF _XmDropTransferListRec;

(*   The DropTransfer instance record   *)

  _XmDropTransferPart = RECORD
    drop_transfers         : XmDropTransferEntry;
    num_drop_transfers     : Xt.Cardinal;
    selection              : X.Atom;
    dragContext            : Xt.Widget;
    timestamp              : X.Time;
    incremental            : Xt.Boolean;
    source_window          : X.Window;
    tag                    : CARDINAL;
    transfer_callback      : Xt.XtSelectionCallbackProc;
    transfer_status        : SHORTCARD;
    motif_drop_atom        : X.Atom;
    drop_transfer_lists    : XmDropTransferList;
    num_drop_transfer_lists: Xt.Cardinal;
    cur_drop_transfer_list : Xt.Cardinal;
    cur_xfer               : Xt.Cardinal;
    cur_targets            : X.PAAtom;
    cur_client_data        : Xt.XtPointerList;
  END;

  XmDropTransferPart = _XmDropTransferPart;

(*   Full instance record declaration   *)

  _XmDropTransferRec = RECORD
    object      : Xt.ObjectPart;
    dropTransfer: XmDropTransferPart;
  END;

  XmDropTransferRec = _XmDropTransferRec;

VAR
  xmDropTransferClassRec: XmDropTransferClassRec;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/Display.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

CONST
  XmDRAG_NONE = 0;
  XmDRAG_DROP_ONLY = 1;
  XmDRAG_PREFER_PREREGISTER = 2;
  XmDRAG_PREREGISTER = 3;
  XmDRAG_PREFER_DYNAMIC = 4;
  XmDRAG_DYNAMIC = 5;
  XmDRAG_PREFER_RECEIVER = 6;

(*  Class record constants  *)

TYPE
  XmDisplay = POINTER TO _XmDisplayRec;

  XmDisplayClass = POINTER TO _XmDisplayClassRec;

VAR
  xmDisplayClass: Xt.WidgetClass;

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE XmGetDisplay ( w: Xt.Widget ): Xt.Widget;

<* ELSE *>

PROCEDURE  / XmGetDisplay ( w: Xt.Widget ): Xt.Widget;

<* END *>

(********    Public Function Declarations    ********)

PROCEDURE XmGetDragContext ( w: Xt.Widget;
                             time: X.Time ): Xt.Widget;

PROCEDURE XmGetXmDisplay ( display: Xlib.PtrDisplay ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* --------------------------------------------------- *)
(*                     Xm/Screen.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*  Class record constants  *)

TYPE
  XmScreen = POINTER TO _XmScreenRec;

  XmScreenClass = POINTER TO _XmScreenClassRec;

VAR
  xmScreenClass: Xt.WidgetClass;

(********    Public Function Declarations    ********)

PROCEDURE XmGetXmScreen ( screen: Xlib.PtrScreen ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/ScreenP.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2.4
 *)

TYPE
  _XmScreenClassPart = RECORD
    extension: Xt.XtPointer;
  END;

  XmScreenClassPart = _XmScreenClassPart;

  XmScreenClassPartPtr = POINTER TO _XmScreenClassPart;

  _XmScreenClassRec = RECORD
    core_class   : Xt.CoreClassPart;
    desktop_class: XmDesktopClassPart;
    screen_class : XmScreenClassPart;
  END;

  XmScreenClassRec = _XmScreenClassRec;

  XmDragCursorPtr = POINTER TO XmDragCursorRec;

  _XmDragCursorRec = RECORD
    next      : XmDragCursorPtr;
    cursor    : X.Cursor;
    stateIcon : XmDragIconObject;
    opIcon    : XmDragIconObject;
    sourceIcon: XmDragIconObject;
    dirty     : Xt.Boolean;
  END;

  XmDragCursorRec = _XmDragCursorRec;

  XmDragCursorCache = POINTER TO _XmDragCursorRec;

  XmScratchPixmap = POINTER TO _XmScratchPixmapRec;

  _XmScratchPixmapRec = RECORD
    next  : XmScratchPixmap;
    pixmap: X.Pixmap;
    depth : Xt.Cardinal;
    width : Xt.Dimension;
    height: Xt.Dimension;
    inUse : Xt.Boolean;
  END;

  XmScratchPixmapRec = _XmScratchPixmapRec;

  _XmScreenPart = RECORD
    mwmPresent              : Xt.Boolean;
    numReparented           : SYSTEM.CARD16;
    darkThreshold           : SYSTEM.int;
    foregroundThreshold     : SYSTEM.int;
    lightThreshold          : SYSTEM.int;
    defaultNoneCursorIcon   : XmDragIconObject;
    defaultValidCursorIcon  : XmDragIconObject;
    defaultInvalidCursorIcon: XmDragIconObject;
    defaultMoveCursorIcon   : XmDragIconObject;
    defaultCopyCursorIcon   : XmDragIconObject;
    defaultLinkCursorIcon   : XmDragIconObject;
    defaultSourceCursorIcon : XmDragIconObject;
    nullCursor              : X.Cursor;
    cursorCache             : XmDragCursorCache;
    maxCursorWidth          : Xt.Cardinal;
    maxCursorHeight         : Xt.Cardinal;
    menuCursor              : X.Cursor;
    unpostBehavior          : SHORTCARD;
    font_struct             : Xlib.PtrXFontStruct;
    h_unit                  : SYSTEM.int;
    v_unit                  : SYSTEM.int;
    scratchPixmaps          : XmScratchPixmap;
    moveOpaque              : SHORTCARD;
   (* to save internally-created XmDragIcons *)
    xmStateCursorIcon       : XmDragIconObject;
    xmMoveCursorIcon        : XmDragIconObject;
    xmCopyCursorIcon        : XmDragIconObject;
    xmLinkCursorIcon        : XmDragIconObject;
    xmSourceCursorIcon      : XmDragIconObject;
    imageGC                 : Xlib.GC;           (*  ImageCache.c  *)
    imageGCDepth            : SYSTEM.int;
    imageForeground         : Xt.Pixel;
    imageBackground         : Xt.Pixel;
    screenInfo              : Xt.XtPointer;      (*  extension  *)
  END;

  XmScreenPart = _XmScreenPart;

  XmScreenPartPtr = POINTER TO _XmScreenPart;

  _XmScreenInfo = RECORD
   (* so much for information hiding *)
    menu_state          : Xt.XtPointer;   (*  MenuUtil.c  *)
    destroyCallbackAdded: Xt.Boolean;     (*  ImageCache.c  *)
  END;

  XmScreenInfo = _XmScreenInfo;

  _XmScreenRec = RECORD
    core   : Xt.CorePart;
    desktop: XmDesktopPart;
    screen : XmScreenPart;
  END;

  XmScreenRec = _XmScreenRec;

VAR
  xmScreenClassRec: XmScreenClassRec;

  _XmInvalidCursorIconQuark: Xrm.XrmQuark;
  _XmValidCursorIconQuark: Xrm.XrmQuark;
  _XmNoneCursorIconQuark: Xrm.XrmQuark;
  _XmDefaultDragIconQuark: Xrm.XrmQuark;
  _XmMoveCursorIconQuark: Xrm.XrmQuark;
  _XmCopyCursorIconQuark: Xrm.XrmQuark;
  _XmLinkCursorIconQuark: Xrm.XrmQuark;

(********    Private Function Declarations    ********)

PROCEDURE _XmScreenGetOperationIcon ( w: Xt.Widget;
                                      operation: SHORTCARD ): XmDragIconObject;

PROCEDURE _XmScreenGetStateIcon ( w: Xt.Widget;
                                  state: SHORTCARD ): XmDragIconObject;

PROCEDURE _XmScreenGetSourceIcon ( w: Xt.Widget ): XmDragIconObject;

PROCEDURE _XmAllocScratchPixmap ( xmScreen: XmScreen;
                                  depth: Xt.Cardinal;
                                  width: Xt.Dimension;
                                  height: Xt.Dimension ): X.Pixmap;

PROCEDURE _XmFreeScratchPixmap ( xmScreen: XmScreen; pixmap: X.Pixmap );

TYPE
  XmDragCursorCachePtr = POINTER TO XmDragCursorCache;

PROCEDURE _XmGetDragCursorCachePtr ( xmScreen: XmScreen ): XmDragCursorCachePtr;

PROCEDURE _XmGetMaxCursorSize ( w: Xt.Widget;
                                VAR width: Xt.Dimension;
                                VAR height: Xt.Dimension );

PROCEDURE _XmGetNullCursor ( w: Xt.Widget ): X.Cursor;

PROCEDURE _XmGetMenuCursorByScreen ( screen: Xlib.PtrScreen ): X.Cursor;

PROCEDURE _XmGetMoveOpaqueByScreen ( screen: Xlib.PtrScreen ): Xt.Boolean;

PROCEDURE _XmGetUnpostBehavior ( wid: Xt.Widget ): SHORTCARD;

PROCEDURE _XmGetFontUnit ( screen: Xlib.PtrScreen;
                           dimension: SYSTEM.int ): SYSTEM.int;

PROCEDURE _XmScreenRemoveFromCursorCache ( icon: XmDragIconObject );

(********    End Private Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/VirtKeys.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

CONST
  osfXK_BackSpace = 1004FF08H;
  osfXK_Insert = 1004FF63H;
  osfXK_Delete = 1004FFFFH;
  osfXK_Copy = 1004FF02H;
  osfXK_Cut = 1004FF03H;
  osfXK_Paste = 1004FF04H;
  osfXK_AddMode = 1004FF31H;
  osfXK_PrimaryPaste = 1004FF32H;
  osfXK_QuickPaste = 1004FF33H;
  osfXK_PageLeft = 1004FF40H;
  osfXK_PageUp = 1004FF41H;
  osfXK_PageDown = 1004FF42H;
  osfXK_PageRight = 1004FF43H;
  osfXK_EndLine = 1004FF57H;
  osfXK_BeginLine = 1004FF58H;
  osfXK_Activate = 1004FF44H;
  osfXK_MenuBar = 1004FF45H;
  osfXK_Clear = 1004FF0BH;
  osfXK_Cancel = 1004FF69H;
  osfXK_Help = 1004FF6AH;
  osfXK_Menu = 1004FF67H;
  osfXK_Select = 1004FF60H;
  osfXK_Undo = 1004FF65H;
  osfXK_Left = 1004FF51H;
  osfXK_Up = 1004FF52H;
  osfXK_Right = 1004FF53H;
  osfXK_Down = 1004FF54H;

(********    Public Function Declarations    ********)

PROCEDURE XmTranslateKey ( dpy: Xlib.PtrDisplay;
                           keycode: X.KeyCode;
                           modifiers: Xt.Modifiers;
                           VAR modifiers_return:Xt.Modifiers;
                           keysym_return: XmKeySymTable );

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/VirtKeysP.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2
 *)

CONST
  XmKEYCODE_TAG_SIZE = 32;

TYPE
  _XmDefaultBindingStringRec = RECORD
    vendorName: Xt.String;
    defaults  : Xt.String;
  END;

  XmDefaultBindingStringRec = _XmDefaultBindingStringRec;

  XmDefaultBindingString = POINTER TO _XmDefaultBindingStringRec;

  _XmKeyBindingRec = RECORD
    keysym   : X.KeySym;
    modifiers: CARDINAL;
  END;

  XmKeyBindingRec = _XmKeyBindingRec;

  XmKeyBinding = POINTER TO _XmKeyBindingRec;

  XmKeyBindingsList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF XmKeyBindingRec;

  _XmVirtualKeysymRec = RECORD
    name  : Xt.String;
    keysym: X.KeySym;
  END;

  XmVirtualKeysymRec = _XmVirtualKeysymRec;

  XmVirtualKeysym = POINTER TO _XmVirtualKeysymRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmVirtKeysInitialize ( widget: Xt.Widget );

PROCEDURE _XmVirtKeysDestroy ( widget: Xt.Widget );

PROCEDURE _XmVirtKeysHandler ( widget: Xt.Widget;
                               client_data: Xt.XtPointer;
                               VAR event: Xlib.XEvent;
                               VAR dontSwallow: Xt.Boolean );

PROCEDURE _XmVirtualToActualKeysym ( dpy: Xlib.PtrDisplay;
                                     virtKeysym: X.KeySym;
                                     VAR actualKeysymRtn: X.KeySym;
                                     VAR modifiersRtn: Xt.Modifiers );

PROCEDURE _XmVirtKeysStoreBindings ( shell: Xt.Widget;
                                     binding: Xt.String );

PROCEDURE _XmVirtKeysLoadFileBindings ( fileName: ARRAY OF CHAR;
                                        binding: Xt.StringList ): Xt.Boolean;

PROCEDURE _XmVirtKeysLoadFallbackBindings ( display: Xlib.PtrDisplay;
                                            binding: Xt.StringList ): SYSTEM.int;

(********    End Private Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/DisplayP.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

TYPE
  XmDisplayGetDisplayProc = PROCEDURE ( Xlib.PtrDisplay ): Xt.Widget;

  _XmDisplayClassPart = RECORD
    GetDisplay: XmDisplayGetDisplayProc;
    extension : Xt.XtPointer;
  END;

  XmDisplayClassPart = _XmDisplayClassPart;

(*
 * we make it a appShell subclass so it can have it's own instance
 * hierarchy
 *)

  _XmDisplayClassRec = RECORD
    core_class             : Xt.CoreClassPart;
    composite_class        : Xt.CompositeClassPart;
    shell_class            : ShellP.ShellClassPart;
    wm_shell_class         : ShellP.WMShellClassPart;
    vendor_shell_class     : ShellP.VendorShellClassPart;
    top_level_shell_class  : ShellP.TopLevelShellClassPart;
    application_shell_class: ShellP.ApplicationShellClassPart;
    display_class          : XmDisplayClassPart;
  END;

  XmDisplayClassRec = _XmDisplayClassRec;

  _XmModalDataRec = RECORD
    wid         : Xt.Widget;
    ve          : XmVendorShellExtObject;
    grabber     : XmVendorShellExtObject;
    exclusive   : Xt.Boolean;
    springLoaded: Xt.Boolean;
  END;

  XmModalDataRec = _XmModalDataRec;

  XmModalData = POINTER TO _XmModalDataRec;

  _XmKeycodeTag = ARRAY [0..XmKEYCODE_TAG_SIZE-1] OF SHORTCARD;

  _XmDisplayPart = RECORD
    dragInitiatorProtocolStyle: SHORTCARD;
    dragReceiverProtocolStyle : SHORTCARD;
    userGrabbed               : SHORTCARD;      (* flag for menu vs dnd *)
    dragContextClass          : Xt.WidgetClass;
    dropTransferClass         : Xt.WidgetClass;
    dropSiteManagerClass      : Xt.WidgetClass;
    activeDC                  : XmDragContext;
    dsm                       : XmDropSiteManagerObject;
    lastDragTime              : X.Time;
    proxyWindow               : X.Window;
    modals                    : XmModalData;
    numModals                 : Xt.Cardinal;
    maxModals                 : Xt.Cardinal;
    xmim_info                 : Xt.XtPointer;
    bindingsString            : Xt.String;
    bindings                  : XmKeyBindingsList;
    lastKeyEvent              : Xlib.XKeyPressedEvent;
    keycode_tag               : _XmKeycodeTag;
    shellCount                : SYSTEM.int;
    displayInfo               : Xt.XtPointer;   (* extension *)
  END;

  XmDisplayPart = _XmDisplayPart;

  XmDisplayPartPtr = POINTER TO _XmDisplayPart;

  _XmDisplayInfo = RECORD
   (* so much for information hiding *)
    SashCursor       : X.Cursor;     (*  Sash.c  *)
    destinationWidget: Xt.Widget;    (*  Dest.c  *)
    TearOffCursor    : X.Cursor;     (*  TearOff.c  *)
    UniqueStamp      : Xt.XtPointer; (*  UniqueEvnt.c  *)
  END;

  XmDisplayInfo = _XmDisplayInfo;

  _XmDisplayRec = RECORD
    core       : Xt.CorePart;
    composite  : Xt.CompositePart;
    shell      : ShellP.ShellPart;
    wm         : ShellP.WMShellPart;
    vendor     : ShellP.VendorShellPart;
    topLevel   : ShellP.TopLevelShellPart;
    application: ShellP.ApplicationShellPart;
    display    : XmDisplayPart;
  END;

  XmDisplayRec = _XmDisplayRec;

VAR
  xmDisplayClassRec: XmDisplayClassRec;
  _Xm_MOTIF_DRAG_AND_DROP_MESSAGE: Xt.String;

(********    Private Function Declarations    ********)

PROCEDURE _XmGetDropSiteManagerObject ( xmDisplay: XmDisplay ): XmDropSiteManagerObject;

PROCEDURE _XmGetDragProtocolStyle ( w: Xt.Widget ): SHORTCARD;

PROCEDURE _XmGetDragTrackingMode ( w: Xt.Widget ): SHORTCARD;

PROCEDURE _XmGetDragContextFromHandle ( w: Xt.Widget;
                                        iccHandle: X.Atom ): Xt.Widget;

PROCEDURE _XmGetXmDisplayClass (  ): Xt.WidgetClass;

PROCEDURE _XmSetXmDisplayClass ( wc: Xt.WidgetClass ): Xt.WidgetClass;

(********    End Private Function Declarations    ********)

(* -------------------------------------------------- *)
(*                     Xm/DrawP.h                     *)
(* -------------------------------------------------- *)

(*
 * Motif Release 1.2.2
 *)

(********    Private Function Declarations    ********)

PROCEDURE _XmDrawShadows ( display: Xlib.PtrDisplay;
                           d: X.Drawable;
                           top_gc: Xlib.GC;
                           bottom_gc: Xlib.GC;
                           x: Xt.Position;
                           y: Xt.Position;
                           width: Xt.Dimension;
                           height: Xt.Dimension;
                           shad_thick: Xt.Dimension;
                           shad_type: CARDINAL );

PROCEDURE _XmClearBorder ( display: Xlib.PtrDisplay;
                           w: X.Window;
                           x: Xt.Position;
                           y: Xt.Position;
                           width: Xt.Dimension;
                           height: Xt.Dimension;
                           shadow_thick: Xt.Dimension );

PROCEDURE _XmDrawSeparator ( display: Xlib.PtrDisplay;
                             d: X.Drawable;
                             top_gc: Xlib.GC;
                             bottom_gc: Xlib.GC;
                             separator_gc: Xlib.GC;
                             x: Xt.Position;
                             y: Xt.Position;
                             width: Xt.Dimension;
                             height: Xt.Dimension;
                             shadow_thick: Xt.Dimension;
                             margin: Xt.Dimension;
                             orientation: SHORTCARD;
                             separator_type: SHORTCARD );

PROCEDURE _XmDrawDiamond ( display: Xlib.PtrDisplay;
                           d: X.Drawable;
                           top_gc: Xlib.GC;
                           bottom_gc: Xlib.GC;
                           center_gc: Xlib.GC;
                           x: Xt.Position;
                           y: Xt.Position;
                           width: Xt.Dimension;
                           height: Xt.Dimension;
                           shadow_thick: Xt.Dimension;
                           fill: Xt.Dimension );

PROCEDURE _XmDrawSimpleHighlight ( display: Xlib.PtrDisplay;
                                   d: X.Drawable;
                                   gc: Xlib.GC;
                                   x: Xt.Position;
                                   y: Xt.Position;
                                   width: Xt.Dimension;
                                   height: Xt.Dimension;
                                   highlight_thick: Xt.Dimension );

PROCEDURE _XmDrawHighlight ( display: Xlib.PtrDisplay;
                             d: X.Drawable;
                             gc: Xlib.GC;
                             x: Xt.Position;
                             y: Xt.Position;
                             width: Xt.Dimension;
                             height: Xt.Dimension;
                             highlight_thick: Xt.Dimension;
                             line_style: SYSTEM.int );

PROCEDURE _XmDrawArrow ( display: Xlib.PtrDisplay;
                         d: X.Drawable;
                         top_gc: Xlib.GC;
                         bot_gc: Xlib.GC;
                         cent_gc: Xlib.GC;
                         x: Xt.Position;
                         y: Xt.Position;
                         width: Xt.Dimension;
                         height: Xt.Dimension;
                         shadow_thick: Xt.Dimension;
                         direction: SHORTCARD );

(********    End Private Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/DrawingA.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(*  Class record constants  *)

VAR
  xmDrawingAreaWidgetClass: Xt.WidgetClass;

TYPE
  XmDrawingAreaWidgetClass = POINTER TO _XmDrawingAreaClassRec;

  XmDrawingAreaWidget = POINTER TO _XmDrawingAreaRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateDrawingArea ( p: Xt.Widget;
                                name: ARRAY OF CHAR;
                                args: Xt.ArgList;
                                n: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/DrawingAP.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2.3
 *)

CONST
  XmRESIZE_SWINDOW = 10;

(*  Constraint part record for DrawingArea widget  *)

TYPE
  _XmDrawingAreaConstraintPart = RECORD
    unused: CHAR;
  END;

  XmDrawingAreaConstraintPart = _XmDrawingAreaConstraintPart;

  XmDrawingAreaConstraint = POINTER TO _XmDrawingAreaConstraintPart;

(*   New fields for the DrawingArea widget class record   *)

  _XmDrawingAreaClassPart = RECORD
    extension: Xt.XtPointer;   (*  Pointer to extension record  *)
  END;

  XmDrawingAreaClassPart = _XmDrawingAreaClassPart;

(*  Full class record declaration  *)

  _XmDrawingAreaClassRec = RECORD
    core_class        : Xt.CoreClassPart;
    composite_class   : Xt.CompositeClassPart;
    constraint_class  : Xt.ConstraintClassPart;
    manager_class     : XmManagerClassPart;
    drawing_area_class: XmDrawingAreaClassPart;
  END;

  XmDrawingAreaClassRec = _XmDrawingAreaClassRec;

(*  New fields for the DrawingArea widget record  *)

  _XmDrawingAreaPart = RECORD
    margin_width   : Xt.Dimension;
    margin_height  : Xt.Dimension;
    resize_callback: Xt.XtCallbackList;
    expose_callback: Xt.XtCallbackList;
    input_callback : Xt.XtCallbackList;
    resize_policy  : SHORTCARD;
  END;

  XmDrawingAreaPart = _XmDrawingAreaPart;

(****************************************************************
 *
 * Full instance record declaration
 *
 ****************************************************************)

  _XmDrawingAreaRec = RECORD
    core        : Xt.CorePart;
    composite   : Xt.CompositePart;
    constraint  : Xt.ConstraintPart;
    manager     : XmManagerPart;
    drawing_area: XmDrawingAreaPart;
  END;

  XmDrawingAreaRec = _XmDrawingAreaRec;

VAR
  xmDrawingAreaClassRec: XmDrawingAreaClassRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmDrawingAreaInput ( wid: Xt.Widget;
                                VAR event: Xlib.XEvent;
                                params: Xt.StringList;
                                VAR num_params: Xt.Cardinal );

(********    End Private Function Declarations    ********)

(* --------------------------------------------------- *)
(*                     Xm/DrawnB.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(***********************************************************************
 *
 * DrawnButton Widget
 *
 ***********************************************************************)

(*  DrawnButon Widget  *)

VAR
  xmDrawnButtonWidgetClass: Xt.WidgetClass;

TYPE
  XmDrawnButtonWidgetClass = POINTER TO _XmDrawnButtonClassRec;

  XmDrawnButtonWidget = POINTER TO _XmDrawnButtonRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateDrawnButton ( parent: Xt.Widget;
                                name: ARRAY OF CHAR;
                                arglist: Xt.ArgList;
                                argcount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/DrawnBP.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*  DrawnButton class structure  *)

TYPE
  _XmDrawnButtonClassPart = RECORD
    extension: Xt.XtPointer;   (* Pointer to extension record *)
  END;

  XmDrawnButtonClassPart = _XmDrawnButtonClassPart;

(*  Full class record declaration for DrawnButton class  *)

  _XmDrawnButtonClassRec = RECORD
    core_class          : Xt.CoreClassPart;
    primitive_class     : XmPrimitiveClassPart;
    label_class         : XmLabelClassPart;
    drawnbutton_class   : XmDrawnButtonClassPart;
  END;

  XmDrawnButtonClassRec = _XmDrawnButtonClassRec;

(*  DrawnButton instance record  *)

  _XmDrawnButtonPart = RECORD
    pushbutton_enabled     : Xt.Boolean;
    shadow_type            : SHORTCARD;
    activate_callback      : Xt.XtCallbackList;
    arm_callback           : Xt.XtCallbackList;
    disarm_callback        : Xt.XtCallbackList;
    expose_callback        : Xt.XtCallbackList;
    resize_callback        : Xt.XtCallbackList;
    armed                  : Xt.Boolean;
    old_width              : Xt.Dimension;
    old_height             : Xt.Dimension;
    old_shadow_thickness   : Xt.Dimension;
    old_highlight_thickness: Xt.Dimension;
    timer                  : Xt.XtIntervalId;
    multiClick             : SHORTCARD;          (* KEEP/DISCARD resource *)
    click_count            : SYSTEM.int;
    armTimeStamp           : X.Time;
  END;

  XmDrawnButtonPart = _XmDrawnButtonPart;

(*  Full instance record declaration  *)

  _XmDrawnButtonRec = RECORD
    core       : Xt.CorePart;
    primitive  : XmPrimitivePart;
    label      : XmLabelPart;
    drawnbutton: XmDrawnButtonPart;
  END;

  XmDrawnButtonRec = _XmDrawnButtonRec;

VAR
  xmDrawnButtonClassRec: XmDrawnButtonClassRec;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* --------------------------------------------------- *)
(*                     Xm/FileSB.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(*  Type definitions for FileSB resources:  *)

TYPE
  XmQualifyProc = PROCEDURE ( Xt.Widget,
                              Xt.XtPointer,
                              Xt.XtPointer );

  XmSearchProc = PROCEDURE ( Xt.Widget,
                             Xt.XtPointer );

  XmFileSelectionBoxWidgetClass = POINTER TO _XmFileSelectionBoxClassRec;

  XmFileSelectionBoxWidget = POINTER TO _XmFileSelectionBoxRec;

(*  Class record constants  *)

VAR
  xmFileSelectionBoxWidgetClass: Xt.WidgetClass;

(********    Public Function Declarations    ********)

PROCEDURE XmFileSelectionBoxGetChild ( fs: Xt.Widget;
                                       which: SHORTCARD ): Xt.Widget;

PROCEDURE XmFileSelectionDoSearch ( fs: Xt.Widget;
                                    dirmask: XmString );

PROCEDURE XmCreateFileSelectionBox ( p: Xt.Widget;
                                     name: ARRAY OF CHAR;
                                     args: Xt.ArgList;
                                     n: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateFileSelectionDialog ( ds_p: Xt.Widget;
                                        name: ARRAY OF CHAR;
                                        fsb_args: Xt.ArgList;
                                        fsb_n: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/FileSBP.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*  Defines for use in allocation geometry matrix.  *)

CONST
  XmFSB_MAX_WIDGETS_VERT = 10;

(*  Bit locations for the state_flags bit field.  *)

  XmFS_NO_MATCH = 1;
  XmFS_IN_FILE_SEARCH = 2;
  XmFS_DIR_SEARCH_PROC = 4;

(*  Constraint part record for FileSelectionBox widget  *)

TYPE
  _XmFileSelectionBoxConstraintPart = RECORD
    unused: CHAR;
  END;

  XmFileSelectionBoxConstraintPart = _XmFileSelectionBoxConstraintPart;

  XmFileSelectionBoxConstraint = POINTER TO _XmFileSelectionBoxConstraintPart;

(*   New fields for the FileSelectionBox widget class record   *)

  _XmFileSelectionBoxClassPart = RECORD
    extension: Xt.XtPointer;   (*  Pointer to extension record  *)
  END;

  XmFileSelectionBoxClassPart = _XmFileSelectionBoxClassPart;

(*  Full class record declaration  *)

  _XmFileSelectionBoxClassRec = RECORD
    core_class              : Xt.CoreClassPart;
    composite_class         : Xt.CompositeClassPart;
    constraint_class        : Xt.ConstraintClassPart;
    manager_class           : XmManagerClassPart;
    bulletin_board_class    : XmBulletinBoardClassPart;
    selection_box_class     : XmSelectionBoxClassPart;
    file_selection_box_class: XmCommandClassPart;
  END;

  XmFileSelectionBoxClassRec = _XmFileSelectionBoxClassRec;

(*  New fields for the FileSelectionBox widget record  *)

  _XmFileSelectionBoxPart = RECORD
    directory            : XmString;  (* directory specification *)
    pattern              : XmString;  (* file search pattern *)
    dir_list_label       : Xt.Widget; (* directory list Label *)
    dir_list_label_string: XmString;  (* directory list label text *)
    dir_list             : Xt.Widget; (* directory List *)
    dir_list_items       : XmStringTable;(* items in directory List*)
    dir_list_item_count  : SYSTEM.int;(* number of items in directory List *)
    dir_list_selected_item_position: SYSTEM.int;
    filter_label         : Xt.Widget; (* file search filter label *)
    filter_label_string  : XmString;  (* filter label text *)
    filter_text          : Xt.Widget; (* filter text entry field *)
    dir_mask             : XmString;  (* string in filter text entry field *)
    no_match_string      : XmString;  (* string in list when no file match *)
    qualify_search_data_proc: XmQualifyProc;(* directory and mask routine *)
    dir_search_proc      : XmSearchProc;(* change directory routine *)
    file_search_proc     : XmSearchProc;(* file search routine *)
    file_type_mask       : SHORTCARD; (* mask for type of files in file list *)
    list_updated         : Xt.Boolean;(* flag to indicate file list update *)
    directory_valid      : Xt.Boolean;(* flag to indicate valid new directory*)
    state_flags          : SHORTCARD; (* internal flags to indicate state. *)
  END;

  XmFileSelectionBoxPart = _XmFileSelectionBoxPart;

(****************************************************************
 *
 * Full instance record declaration
 *
 ****************************************************************)

  _XmFileSelectionBoxRec = RECORD
    core              : Xt.CorePart;
    composite         : Xt.CompositePart;
    constraint        : Xt.ConstraintPart;
    manager           : XmManagerPart;
    bulletin_board    : XmBulletinBoardPart;
    selection_box     : XmSelectionBoxPart;
    file_selection_box: XmFileSelectionBoxPart;
  END;

  XmFileSelectionBoxRec = _XmFileSelectionBoxRec;

VAR
  xmFileSelectionBoxClassRec: XmFileSelectionBoxClassRec;

(*  Access macros  *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE FS_Directory ( w: Xt.Widget ): XmString;
PROCEDURE FS_DirMask ( w: Xt.Widget ): XmString;
PROCEDURE FS_DirListLabel ( w: Xt.Widget ): Xt.Widget;
PROCEDURE FS_DirListLabelString ( w: Xt.Widget ): XmString;
PROCEDURE FS_DirList ( w: Xt.Widget ): Xt.Widget;
PROCEDURE FS_DirListItems ( w: Xt.Widget ): XmStringTable;
PROCEDURE FS_DirListItemCount ( w: Xt.Widget ): SYSTEM.int;
PROCEDURE FS_FilterLabel ( w: Xt.Widget ): Xt.Widget;
PROCEDURE FS_FilterLabelString ( w: Xt.Widget ): XmString;
PROCEDURE FS_FilterText ( w: Xt.Widget ): Xt.Widget;
PROCEDURE FS_Pattern ( w: Xt.Widget ): XmString;
PROCEDURE FS_NoMatchString ( w: Xt.Widget ): XmString;
PROCEDURE FS_QualifySearchDataProc ( w: Xt.Widget ): XmQualifyProc;
PROCEDURE FS_DirSearchProc ( w: Xt.Widget ): XmSearchProc;
PROCEDURE FS_FileSearchProc ( w: Xt.Widget ): XmSearchProc;
(* This field (such as real_default_button) doesn`t exists in structure
   Probably Motif Programmers Team BUG :)
PROCEDURE FS_RealDefaultButton ( w: Xt.Widget ): Xt.Widget; *)
PROCEDURE FS_FileTypeMask ( w: Xt.Widget ): SHORTCARD;
PROCEDURE FS_ListUpdated ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE FS_DirectoryValid ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE FS_StateFlags ( w: Xt.Widget ): SHORTCARD;
PROCEDURE FS_DirListSelectedItemPosition ( w: Xt.Widget ): SYSTEM.int;

<* ELSE *>

PROCEDURE  / FS_Directory ( w: Xt.Widget ): XmString;
PROCEDURE  / FS_DirMask ( w: Xt.Widget ): XmString;
PROCEDURE  / FS_DirListLabel ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / FS_DirListLabelString ( w: Xt.Widget ): XmString;
PROCEDURE  / FS_DirList ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / FS_DirListItems ( w: Xt.Widget ): XmStringTable;
PROCEDURE  / FS_DirListItemCount ( w: Xt.Widget ): SYSTEM.int;
PROCEDURE  / FS_FilterLabel ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / FS_FilterLabelString ( w: Xt.Widget ): XmString;
PROCEDURE  / FS_FilterText ( w: Xt.Widget ): Xt.Widget;
PROCEDURE  / FS_Pattern ( w: Xt.Widget ): XmString;
PROCEDURE  / FS_NoMatchString ( w: Xt.Widget ): XmString;
PROCEDURE  / FS_QualifySearchDataProc ( w: Xt.Widget ): XmQualifyProc;
PROCEDURE  / FS_DirSearchProc ( w: Xt.Widget ): XmSearchProc;
PROCEDURE  / FS_FileSearchProc ( w: Xt.Widget ): XmSearchProc;
(* This field (such as real_default_button) doesn`t exists in structure
   Probably Motif Programmers Team BUG :)
PROCEDURE  / FS_RealDefaultButton ( w: Xt.Widget ): Xt.Widget; *)
PROCEDURE  / FS_FileTypeMask ( w: Xt.Widget ): SHORTCARD;
PROCEDURE  / FS_ListUpdated ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / FS_DirectoryValid ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / FS_StateFlags ( w: Xt.Widget ): SHORTCARD;
PROCEDURE  / FS_DirListSelectedItemPosition ( w: Xt.Widget ): Xt.Boolean;

<* END *>

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* ------------------------------------------------- *)
(*                     Xm/Form.h                     *)
(* ------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(*   Form Widget   *)

VAR
  xmFormWidgetClass: Xt.WidgetClass;

TYPE
  XmFormWidgetClass = POINTER TO _XmFormClassRec;

  XmFormWidget = POINTER TO _XmFormRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateForm ( parent: Xt.Widget;
                         name: ARRAY OF CHAR;
                         arglist: Xt.ArgList;
                         argcount: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateFormDialog ( parent: Xt.Widget;
                               name: ARRAY OF CHAR;
                               arglist: Xt.ArgList;
                               argcount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* -------------------------------------------------- *)
(*                     Xm/FormP.h                     *)
(* -------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

TYPE
  _XmFormAttachmentRec = RECORD
    type     : SHORTCARD;
    w        : Xt.Widget;
    percent  : SYSTEM.int;
    offset   : SYSTEM.int;
    value    : SYSTEM.int;
    tempValue: SYSTEM.int;
  END;

  XmFormAttachmentRec = _XmFormAttachmentRec;

  XmFormAttachment = POINTER TO _XmFormAttachmentRec;

  _XmFormAttachments = ARRAY [0..3] OF XmFormAttachmentRec;

  _XmFormConstraintPart = RECORD
    att             : _XmFormAttachments;
    next_sibling    : Xt.Widget;
    sorted          : Xt.Boolean;
    resizable       : Xt.Boolean;
    preferred_width : Xt.Dimension;
    preferred_height: Xt.Dimension;
  END;

  XmFormConstraintPart = _XmFormConstraintPart;

  XmFormConstraint = POINTER TO _XmFormConstraintPart;

  _XmFormConstraintRec = RECORD
    manager: XmManagerConstraintPart;
    form   : XmFormConstraintPart;
  END;

  XmFormConstraintRec = _XmFormConstraintRec;

  XmFormConstraintPtr = POINTER TO _XmFormConstraintRec;

(*   Form class structure   *)

  _XmFormClassPart = RECORD
    extension: Xt.XtPointer;   (* Pointer to extension record *)
  END;

  XmFormClassPart = _XmFormClassPart;

(*   Full class record declaration for form class   *)

  _XmFormClassRec = RECORD
    core_class          : Xt.CoreClassPart;
    composite_class     : Xt.CompositeClassPart;
    constraint_class    : Xt.ConstraintClassPart;
    manager_class       : XmManagerClassPart;
    bulletin_board_class: XmBulletinBoardClassPart;
    form_class          : XmFormClassPart;
  END;

  XmFormClassRec = _XmFormClassRec;

(*   The Form instance record   *)

  _XmFormPart = RECORD
    horizontal_spacing    : Xt.Dimension;
    vertical_spacing      : Xt.Dimension;
    fraction_base         : SYSTEM.int;
    rubber_positioning    : Xt.Boolean;
    first_child           : Xt.Widget;
    initial_width         : Xt.Boolean;
    initial_height        : Xt.Boolean;
    processing_constraints: Xt.Boolean;
  END;

  XmFormPart = _XmFormPart;

(*   Full instance record declaration   *)

  _XmFormRec = RECORD
    core          : Xt.CorePart;
    composite     : Xt.CompositePart;
    constraint    : Xt.ConstraintPart;
    manager       : XmManagerPart;
    bulletin_board: XmBulletinBoardPart;
    form          : XmFormPart;
  END;

  XmFormRec = _XmFormRec;

VAR
  xmFormClassRec: XmFormClassRec;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* -------------------------------------------------- *)
(*                     Xm/Frame.h                     *)
(* -------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(*  Class record constants  *)

VAR
  xmFrameWidgetClass: Xt.WidgetClass;

TYPE
  XmFrameWidgetClass = POINTER TO _XmFrameClassRec;

  XmFrameWidget = POINTER TO _XmFrameRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateFrame ( parent: Xt.Widget;
                          name: ARRAY OF CHAR;
                          arglist: Xt.ArgList;
                          argcount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* --------------------------------------------------- *)
(*                     Xm/FrameP.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(* Full class records *)

TYPE
  _XmFrameClassPart = RECORD
    extension: Xt.XtPointer;
  END;

  XmFrameClassPart = _XmFrameClassPart;

  _XmFrameClassRec = RECORD
    core_class      : Xt.CoreClassPart;
    composite_class : Xt.CompositeClassPart;
    constraint_class: Xt.ConstraintClassPart;
    manager_class   : XmManagerClassPart;
    frame_class     : XmFrameClassPart;
  END;

  XmFrameClassRec = _XmFrameClassRec;

(* Frame instance records *)

  _XmFramePart = RECORD
    margin_width          : Xt.Dimension;
    margin_height         : Xt.Dimension;
    shadow_type           : SHORTCARD;
    old_width             : Xt.Dimension;
    old_height            : Xt.Dimension;
    old_shadow_thickness  : Xt.Dimension;
    old_shadow_x          : Xt.Position;
    old_shadow_y          : Xt.Position;
    work_area             : Xt.Widget;
    title_area            : Xt.Widget;
    processing_constraints: Xt.Boolean;
  END;

  XmFramePart = _XmFramePart;

  _XmFrameRec = RECORD
    core      : Xt.CorePart;
    composite : Xt.CompositePart;
    constraint: Xt.ConstraintPart;
    manager   : XmManagerPart;
    frame     : XmFramePart;
  END;

  XmFrameRec = _XmFrameRec;

(* Frame constraint records *)

  _XmFrameConstraintPart = RECORD
    unused           : SYSTEM.int;
    child_type       : SHORTCARD;
    child_h_alignment: SHORTCARD;
    child_h_spacing  : Xt.Dimension;
    child_v_alignment: SHORTCARD;
  END;

  XmFrameConstraintPart = _XmFrameConstraintPart;

  XmFrameConstraint = POINTER TO _XmFrameConstraintPart;

  _XmFrameConstraintRec = RECORD
    manager: XmManagerConstraintPart;
    frame  : XmFrameConstraintPart;
  END;

  XmFrameConstraintRec = _XmFrameConstraintRec;

  XmFrameConstraintPtr = POINTER TO _XmFrameConstraintRec;

VAR
  xmFrameClassRec: XmFrameClassRec;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* ------------------------------------------------- *)
(*                     Xm/List.h                     *)
(* ------------------------------------------------- *)

(*
 * Motif Release 1.2.2
 *)

VAR
  xmListWidgetClass: Xt.WidgetClass;

CONST
  XmINITIAL = 0;
  XmADDITION = 1;
  XmMODIFICATION = 2;

TYPE
  XmListWidgetClass = POINTER TO _XmListClassRec;

  XmListWidget = POINTER TO _XmListRec;

(********    Public Function Declarations    ********)

PROCEDURE XmListAddItem ( w: Xt.Widget;
                          item: XmString;
                          pos: SYSTEM.int );

PROCEDURE XmListAddItems ( w: Xt.Widget;
                           items: XmStringTable;
                           item_count: SYSTEM.int;
                           pos: SYSTEM.int );

PROCEDURE XmListAddItemsUnselected ( w: Xt.Widget;
                                     items: XmStringTable;
                                     item_count: SYSTEM.int;
                                     pos: SYSTEM.int );

PROCEDURE XmListAddItemUnselected ( w: Xt.Widget;
                                    item: XmString;
                                    pos: SYSTEM.int );

PROCEDURE XmListDeleteItem ( w: Xt.Widget;
                             item: XmString );

PROCEDURE XmListDeleteItems ( w: Xt.Widget;
                              items: XmStringTable;
                              item_count: SYSTEM.int );

PROCEDURE XmListDeletePositions ( w: Xt.Widget;
                                  position_list: Xlib.PASInt;
                                  position_count: SYSTEM.int );

PROCEDURE XmListDeletePos ( w: Xt.Widget;
                            pos: SYSTEM.int );

PROCEDURE XmListDeleteItemsPos ( w: Xt.Widget;
                                 item_count: SYSTEM.int;
                                 pos: SYSTEM.int );

PROCEDURE XmListDeleteAllItems ( w: Xt.Widget );

PROCEDURE XmListReplaceItems ( w: Xt.Widget;
                               old_items: XmStringTable;
                               item_count: SYSTEM.int;
                               new_items: XmStringTable );

PROCEDURE XmListReplaceItemsPos ( w: Xt.Widget;
                                  new_items: XmStringTable;
                                  item_count: SYSTEM.int;
                                  position: SYSTEM.int );

PROCEDURE XmListReplaceItemsUnselected ( w: Xt.Widget;
                                         old_items: XmStringTable;
                                         item_count: SYSTEM.int;
                                         new_items: XmStringTable );

PROCEDURE XmListReplaceItemsPosUnselected ( w: Xt.Widget;
                                            new_items: XmStringTable;
                                            item_count: SYSTEM.int;
                                            position: SYSTEM.int );

PROCEDURE XmListReplacePositions ( w: Xt.Widget;
                                   position_list: Xlib.PASInt;
                                   item_list: XmStringTable;
                                   item_count: SYSTEM.int );

PROCEDURE XmListSelectItem ( w: Xt.Widget;
                             item: XmString;
                             notify: Xt.Boolean );

PROCEDURE XmListSelectPos ( w: Xt.Widget;
                            pos: SYSTEM.int;
                            notify: Xt.Boolean );

PROCEDURE XmListDeselectItem ( w: Xt.Widget;
                               item: XmString );

PROCEDURE XmListDeselectPos ( w: Xt.Widget;
                              pos: SYSTEM.int );

PROCEDURE XmListDeselectAllItems ( w: Xt.Widget );

PROCEDURE XmListSetPos ( w: Xt.Widget;
                         pos: SYSTEM.int );

PROCEDURE XmListSetBottomPos ( w: Xt.Widget;
                               pos: SYSTEM.int );

PROCEDURE XmListSetItem ( w: Xt.Widget;
                          item: XmString );

PROCEDURE XmListSetBottomItem ( w: Xt.Widget;
                                item: XmString );

PROCEDURE XmListSetAddMode ( w: Xt.Widget;
                             add_mode: Xt.Boolean );

PROCEDURE XmListItemExists ( w: Xt.Widget;
                             item: XmString ): Xt.Boolean;

PROCEDURE XmListItemPos ( w: Xt.Widget;
                          item: XmString ): SYSTEM.int;

PROCEDURE XmListGetKbdItemPos ( w: Xt.Widget ): SYSTEM.int;

PROCEDURE XmListSetKbdItemPos ( w: Xt.Widget;
                                pos: SYSTEM.int ): Xt.Boolean;

PROCEDURE XmListYToPos ( w: Xt.Widget;
                         y: Xt.Position ): SYSTEM.int;

(*  NeedWidePrototypes ?????  Ego: Yeah! :) *)

PROCEDURE XmListPosToBounds ( w: Xt.Widget;
                              position: SYSTEM.int;
                              VAR x: Xt.Position;
			      VAR y: Xt.Position;
                              VAR width: Xt.Dimension;
                              VAR height: Xt.Dimension ): Xt.Boolean;

PROCEDURE XmListGetMatchPos ( w: Xt.Widget;
                              item: XmString;
                              VAR pos_list: Xlib.PASInt;
                              VAR pos_count: SYSTEM.int ): Xt.Boolean;

PROCEDURE XmListGetSelectedPos ( w: Xt.Widget;
                                 VAR pos_list: Xlib.PASInt;
                                 VAR pos_count: SYSTEM.int ): Xt.Boolean;

PROCEDURE XmListSetHorizPos ( w: Xt.Widget;
                              position: SYSTEM.int );

PROCEDURE XmListUpdateSelectedList ( w: Xt.Widget );

PROCEDURE XmListPosSelected ( w: Xt.Widget;
                              pos: SYSTEM.int ): Xt.Boolean;

PROCEDURE XmCreateList ( parent: Xt.Widget;
                         name: ARRAY OF CHAR;
                         args: Xt.ArgList;
                         argCount: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateScrolledList ( parent: Xt.Widget;
                                 name: ARRAY OF CHAR;
                                 args: Xt.ArgList;
                                 argCount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/ScrollBar.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2
 *)

(*   ScrollBar Widget   *)

VAR
  xmScrollBarWidgetClass: Xt.WidgetClass;

TYPE
  XmScrollBarWidgetClass = POINTER TO _XmScrollBarClassRec;

  XmScrollBarWidget = POINTER TO _XmScrollBarRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateScrollBar ( parent: Xt.Widget;
                              name: ARRAY OF CHAR;
                              arglist: Xt.ArgList;
                              argcount: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmScrollBarGetValues ( w: Xt.Widget;
                                 VAR value: SYSTEM.int;
                                 VAR slider_size: SYSTEM.int;
                                 VAR increment: SYSTEM.int;
                                 VAR page_increment: SYSTEM.int );

PROCEDURE XmScrollBarSetValues ( w: Xt.Widget;
                                 value: SYSTEM.int;
                                 slider_size: SYSTEM.int;
                                 increment: SYSTEM.int;
                                 page_increment: SYSTEM.int;
                                 notify: Xt.Boolean );

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/ScrollBarP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*   Minimum slider width or height   *)

CONST
  MIN_SLIDER_THICKNESS = 1;
  MIN_SLIDER_LENGTH = 6;

(*   ScrollBar class structure   *)

TYPE
  _XmScrollBarClassPart = RECORD
    extension: Xt.XtPointer;   (* Pointer to extension record *)
  END;

  XmScrollBarClassPart = _XmScrollBarClassPart;

(*   Full class record declaration for CheckBox class   *)

  _XmScrollBarClassRec = RECORD
    core_class     : Xt.CoreClassPart;
    primitive_class: XmPrimitiveClassPart;
    scrollBar_class: XmScrollBarClassPart;
  END;

  XmScrollBarClassRec = _XmScrollBarClassRec;

(*   The ScrollBar instance record   *)

  _XmScrollBarPart = RECORD
    value                  : SYSTEM.int;
    minimum                : SYSTEM.int;
    maximum                : SYSTEM.int;
    slider_size            : SYSTEM.int;
    orientation            : SHORTCARD;
    processing_direction   : SHORTCARD;
    show_arrows            : Xt.Boolean;
    increment              : SYSTEM.int;
    page_increment         : SYSTEM.int;
    initial_delay          : SYSTEM.int;
    repeat_delay           : SYSTEM.int;
    value_changed_callback : Xt.XtCallbackList;
    increment_callback     : Xt.XtCallbackList;
    decrement_callback     : Xt.XtCallbackList;
    page_increment_callback: Xt.XtCallbackList;
    page_decrement_callback: Xt.XtCallbackList;
    to_top_callback        : Xt.XtCallbackList;
    to_bottom_callback     : Xt.XtCallbackList;
    drag_callback          : Xt.XtCallbackList;
    (* obsolete *)
    unhighlight_GC         : Xlib.GC;
    (***********)
    foreground_GC          : Xlib.GC;
    trough_color           : Xt.Pixel;
    pixmap                 : X.Drawable;
    sliding_on             : Xt.Boolean;
    etched_slider          : Xt.Boolean;
    saved_value            : SYSTEM.int;
    flags                  : SHORTCARD;
    change_type            : SHORTCARD;
    timer                  : Xt.XtIntervalId;
    initial_x              : SYSTEM.INT16;
    initial_y              : SYSTEM.INT16;
    separation_x           : SYSTEM.INT16;
    separation_y           : SYSTEM.INT16;
    slider_x               : SYSTEM.INT16;
    slider_y               : SYSTEM.INT16;
    slider_width           : SYSTEM.INT16;
    slider_height          : SYSTEM.INT16;
    slider_area_x          : SYSTEM.INT16;
    slider_area_y          : SYSTEM.INT16;
    slider_area_width      : SYSTEM.INT16;
    slider_area_height     : SYSTEM.INT16;
    arrow1_x               : SYSTEM.INT16;
    arrow1_y               : SYSTEM.INT16;
    arrow1_orientation     : SHORTCARD;
    arrow1_selected        : Xt.Boolean;
    arrow2_x               : SYSTEM.INT16;
    arrow2_y               : SYSTEM.INT16;
    arrow2_orientation     : SHORTCARD;
    arrow2_selected        : Xt.Boolean;
    arrow_width            : SYSTEM.INT16;
    arrow_height           : SYSTEM.INT16;
    (* Obsolete fields *)
    arrow1_top_count       : SYSTEM.INT16;
    arrow1_cent_count      : SYSTEM.INT16;
    arrow1_bot_count       : SYSTEM.INT16;
    arrow1_top             : Xlib.PtrXRectangle;
    arrow1_cent            : Xlib.PtrXRectangle;
    arrow1_bot             : Xlib.PtrXRectangle;
    arrow2_top_count       : SYSTEM.INT16;
    arrow2_cent_count      : SYSTEM.INT16;
    arrow2_bot_count       : SYSTEM.INT16;
    arrow2_top             : Xlib.PtrXRectangle;
    arrow2_cent            : Xlib.PtrXRectangle;
    arrow2_bot             : Xlib.PtrXRectangle;
   (***************)
   (* new for 1.2 *)
    unavailable_GC         : Xlib.GC;
  END;

  XmScrollBarPart = _XmScrollBarPart;

(*   Full instance record declaration   *)

  _XmScrollBarRec = RECORD
    core     : Xt.CorePart;
    primitive: XmPrimitivePart;
    scrollBar: XmScrollBarPart;
  END;

  XmScrollBarRec = _XmScrollBarRec;

VAR
  xmScrollBarClassRec: XmScrollBarClassRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmSetEtchedSlider ( sbw: XmScrollBarWidget );

(********    End Private Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/ScrolledW.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2
 *)

VAR
  xmScrolledWindowWidgetClass: Xt.WidgetClass;

TYPE
  XmScrolledWindowWidgetClass = POINTER TO _XmScrolledWindowClassRec;

  XmScrolledWindowWidget = POINTER TO _XmScrolledWindowRec;

(********    Public Function Declarations    ********)

PROCEDURE XmScrolledWindowSetAreas ( w: Xt.Widget;
                                     hscroll: Xt.Widget;
                                     vscroll: Xt.Widget;
                                     wregion: Xt.Widget );

PROCEDURE XmCreateScrolledWindow ( parent: Xt.Widget;
                                   name: ARRAY OF CHAR;
                                   args: Xt.ArgList;
                                   argCount: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmScrollVisible ( scrw: Xt.Widget;
                            wid: Xt.Widget;
                            hor_margin: Xt.Dimension;
                            ver_margin: Xt.Dimension );

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/ScrolledWP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*  Constraint part record for ScrolledWindow widget  *)

TYPE
  _XmScrolledWindowConstraintPart = RECORD
    child_type: SHORTCARD;
  END;

  XmScrolledWindowConstraintPart = _XmScrolledWindowConstraintPart;

  XmScrolledWindowConstraint = POINTER TO _XmScrolledWindowConstraintPart;

(*  New fields for the ScrolledWindow widget class record  *)

  _XmScrolledWindowClassPart = RECORD
    extension: Xt.XtPointer;   (*  Pointer to extension record  *)
  END;

  XmScrolledWindowClassPart = _XmScrolledWindowClassPart;

(****************
 *
 * Class record declaration
 *
 ****************)

  _XmScrolledWindowClassRec = RECORD
    core_class      : Xt.CoreClassPart;
    composite_class : Xt.CompositeClassPart;
    constraint_class: Xt.ConstraintClassPart;
    manager_class   : XmManagerClassPart;
    swindow_class   : XmScrolledWindowClassPart;
  END;

  XmScrolledWindowClassRec = _XmScrolledWindowClassRec;

(****************
 *
 * Scrolled Window instance structure.
 *
 ****************)

  _XmScrolledWindowPart = RECORD
    vmin            : SYSTEM.int;   (* slider minimum coordiate position *)
    vmax            : SYSTEM.int;   (* slider maximum coordiate position *)
    vOrigin         : SYSTEM.int;   (* slider edge location *)
    vExtent         : SYSTEM.int;   (* slider size *)
    hmin            : SYSTEM.int;   (* Same as above for horizontal bar.*)
    hmax            : SYSTEM.int;
    hOrigin         : SYSTEM.int;
    hExtent         : SYSTEM.int;
    hsbX            : Xt.Position;
    hsbY            : Xt.Position;
    hsbWidth        : Xt.Dimension;
    hsbHeight       : Xt.Dimension; (* Dimensions for the horiz bar *)
    vsbX            : Xt.Position;
    vsbY            : Xt.Position;
    vsbWidth        : Xt.Dimension;
    vsbHeight       : Xt.Dimension; (* Dimensions for the vertical bar *)
    GivenHeight     : Xt.Dimension;
    GivenWidth      : Xt.Dimension;
    AreaWidth       : Xt.Dimension;
    AreaHeight      : Xt.Dimension;
    WidthPad        : Xt.Dimension;
    HeightPad       : Xt.Dimension;
    XOffset         : Xt.Position;
    YOffset         : Xt.Position;
    pad             : Xt.Dimension;
    hasHSB          : Xt.Boolean;
    hasVSB          : Xt.Boolean;
    InInit          : Xt.Boolean;
    FromResize      : Xt.Boolean;
    VisualPolicy    : SHORTCARD;
    ScrollPolicy    : SHORTCARD;
    ScrollBarPolicy : SHORTCARD;
    Placement       : SHORTCARD;
    hScrollBar      : XmScrollBarWidget;
    vScrollBar      : XmScrollBarWidget;
    ClipWindow      : XmDrawingAreaWidget;
    WorkWindow      : Xt.Widget;
    traverseObscuredCallback: Xt.XtCallbackList;
  END;

  XmScrolledWindowPart = _XmScrolledWindowPart;

(************************************************************************
 *									*
 * Full instance record declaration					*
 *									*
 ************************************************************************)

  _XmScrolledWindowRec = RECORD
    core      : Xt.CorePart;
    composite : Xt.CompositePart;
    constraint: Xt.ConstraintPart;
    manager   : XmManagerPart;
    swindow   : XmScrolledWindowPart;
  END;

  XmScrolledWindowRec = _XmScrolledWindowRec;

VAR
  xmScrolledWindowClassRec: XmScrolledWindowClassRec;

CONST
  DEFAULT_HEIGHT = 20;
  DEFAULT_WIDTH = 20;

(********    Private Function Declarations    ********)

PROCEDURE _XmGetRealXlations ( dpy: Xlib.PtrDisplay;
                               keys: _XmBuildVirtualKeyList;
                               num_keys: SYSTEM.int ): Xt.String;

PROCEDURE _XmInitializeScrollBars ( w: Xt.Widget );

(********    End Private Function Declarations    ********)

(* -------------------------------------------------- *)
(*                     Xm/ListP.h                     *)
(* -------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*   List struct passed to Convert proc for drag and drop  *)

TYPE
  _XmListDragConvertStruct = RECORD
    w          : Xt.Widget;
    strings    : XmStringTable;
    num_strings: SYSTEM.int;
  END;

  XmListDragConvertStruct = _XmListDragConvertStruct;

(*   List class structure   *)

  _XmListClassPart = RECORD
    extension: Xt.XtPointer;   (* Pointer to extension record *)
  END;

  XmListClassPart = _XmListClassPart;

(*   Full class record declaration for List class   *)

  _XmListClassRec = RECORD
    core_class     : Xt.CoreClassPart;
    primitive_class: XmPrimitiveClassPart;
    list_class     : XmListClassPart;
  END;

  XmListClassRec = _XmListClassRec;

(****************
 *
 * Internal form of the list elements.
 *
 ****************)

  Element = RECORD
    name         : _XmString;
    height       : Xt.Dimension;
    width        : Xt.Dimension;
    CumHeight    : Xt.Dimension;
    selected     : Xt.Boolean;
    last_selected: Xt.Boolean;
    LastTimeDrawn: Xt.Boolean;
    NumLines     : SYSTEM.CARD16;
    length       : SYSTEM.int;
  END;

  ElementPtr = POINTER TO Element;

  ElementList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF ElementPtr;

(*   The List instance record   *)

  _XmListPart = RECORD
    spacing               : Xt.Dimension;
    ItemSpacing           : SYSTEM.INT16;
    margin_width          : Xt.Dimension;
    margin_height         : Xt.Dimension;
    font                  : XmFontList;
    items                 : XmStringTable;
    itemCount             : SYSTEM.int;
    selectedItems         : XmStringTable;
    selectedIndices       : Xlib.PASInt;
    selectedItemCount     : SYSTEM.int;
    visibleItemCount      : SYSTEM.int;
    LastSetVizCount       : SYSTEM.int;
    SelectionPolicy       : SHORTCARD;
    ScrollBarDisplayPolicy: SHORTCARD;
    SizePolicy            : SHORTCARD;
    StrDir                : XmStringDirection;
    AutoSelect            : Xt.Boolean;
    DidSelection          : Xt.Boolean;
    FromSetSB             : Xt.Boolean;
    FromSetNewSize        : Xt.Boolean;
    AddMode               : Xt.Boolean;
    LeaveDir              : SHORTCARD;
    HighlightThickness    : SHORTCARD;
    ClickInterval         : SYSTEM.int;
    DragID                : Xt.XtIntervalId;
    SingleCallback        : Xt.XtCallbackList;
    MultipleCallback      : Xt.XtCallbackList;
    ExtendCallback        : Xt.XtCallbackList;
    BrowseCallback        : Xt.XtCallbackList;
    DefaultCallback       : Xt.XtCallbackList;
    NormalGC              : Xlib.GC;
    InverseGC             : Xlib.GC;
    HighlightGC           : Xlib.GC;
    DashTile              : X.Pixmap;
    InternalList          : ElementList;
    LastItem              : SYSTEM.int;
    FontHeight            : SYSTEM.int;
    top_position          : SYSTEM.int;
    Event                 : CHAR;
    LastHLItem            : SYSTEM.int;
    StartItem             : SYSTEM.int;
    OldStartItem          : SYSTEM.int;
    EndItem               : SYSTEM.int;
    OldEndItem            : SYSTEM.int;
    BaseX                 : Xt.Position;
    BaseY                 : Xt.Position;
    MouseMoved            : Xt.Boolean;
    AppendInProgress      : Xt.Boolean;
    Traversing            : Xt.Boolean;
    KbdSelection          : Xt.Boolean;
    DownCount             : SYSTEM.INT16;
    DownTime              : X.Time;
    CurrentKbdItem        : SYSTEM.int;
    SelectionType         : SHORTCARD;
    InsensitiveGC         : Xlib.GC;
    vmin                  : SYSTEM.int; (* slider minimum coordiate position *)
    vmax                  : SYSTEM.int; (* slider maximum coordiate position *)
    vOrigin               : SYSTEM.int; (* slider edge location *)
    vExtent               : SYSTEM.int; (* slider size *)
    hmin                  : SYSTEM.int; (* Same as above for horizontal bar. *)
    hmax                  : SYSTEM.int;
    hOrigin               : SYSTEM.int;
    hExtent               : SYSTEM.int;
    MaxWidth              : Xt.Dimension;
    CharWidth             : Xt.Dimension;
    XOrigin               : Xt.Position;
    hScrollBar            : XmScrollBarWidget;
    vScrollBar            : XmScrollBarWidget;
    Mom                   : XmScrolledWindowWidget;
    MaxItemHeight         : Xt.Dimension;
  END;

  XmListPart = _XmListPart;

(*   Full instance record declaration   *)

  _XmListRec = RECORD
    core     : Xt.CorePart;
    primitive: XmPrimitivePart;
    list     : XmListPart;
  END;

  XmListRec = _XmListRec;

VAR
  xmListClassRec: XmListClassRec;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/SeparatoG.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2
 *)

(*   Separator Gadget   *)

VAR
  xmSeparatorGadgetClass: Xt.WidgetClass;

TYPE
  XmSeparatorGadgetClass = POINTER TO _XmSeparatorGadgetClassRec;

  XmSeparatorGadget = POINTER TO _XmSeparatorGadgetRec;

  XmSeparatorGCacheObject = POINTER TO _XmSeparatorGCacheObjRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateSeparatorGadget ( parent: Xt.Widget;
                                    name: ARRAY OF CHAR;
                                    arglist: Xt.ArgList;
                                    argcount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/SeparatoGP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2.1
 *)

(*****************************************************************)
(*  The Separator Gadget Cache Object's class and instance records *)
(*****************************************************************)

TYPE
  _XmSeparatorGCacheObjClassPart = RECORD
    foo: SYSTEM.int;
  END;

  XmSeparatorGCacheObjClassPart = _XmSeparatorGCacheObjClassPart;

(*  separator cache class record  *)

  _XmSeparatorGCacheObjClassRec = RECORD
    object_class         : Xt.ObjectClassPart;
    ext_class            : XmExtClassPart;
    separator_class_cache: XmSeparatorGCacheObjClassPart;
  END;

  XmSeparatorGCacheObjClassRec = _XmSeparatorGCacheObjClassRec;

(*   The Separator Gadget Cache instance record   *)

  _XmSeparatorGCacheObjPart = RECORD
    margin        : Xt.Dimension;
    orientation   : SHORTCARD;
    separator_type: SHORTCARD;
    separator_GC  : Xlib.GC;
  END;

  XmSeparatorGCacheObjPart = _XmSeparatorGCacheObjPart;

  XmSeparatorGCache = POINTER TO XmSeparatorGCacheObjPart;

  _XmSeparatorGCacheObjRec = RECORD
    object         : Xt.ObjectPart;
    ext            : XmExtPart;
    separator_cache: XmSeparatorGCacheObjPart;
  END;

  XmSeparatorGCacheObjRec = _XmSeparatorGCacheObjRec;

(*****************************************************)
(*   The Separator Widget Class and instance records   *)
(*****************************************************)

  _XmSeparatorGadgetClassPart = RECORD
    extension: Xt.XtPointer;
  END;

  XmSeparatorGadgetClassPart = _XmSeparatorGadgetClassPart;

(*   Full class record declaration for Separator class   *)

  _XmSeparatorGadgetClassRec = RECORD
    rect_class     : Xt.RectObjClassPart;
    gadget_class   : XmGadgetClassPart;
    separator_class: XmSeparatorGadgetClassPart;
  END;

  XmSeparatorGadgetClassRec = _XmSeparatorGadgetClassRec;

  XmSeparatorGadgetPart = RECORD
    cache: XmSeparatorGCache;
  END;

  _XmSeparatorGadgetPart = XmSeparatorGadgetPart;

(*   Full instance record declaration   *)

  _XmSeparatorGadgetRec = RECORD
    object   : Xt.ObjectPart;
    rectangle: Xt.RectObjPart;
    gadget   : XmGadgetPart;
    separator: XmSeparatorGadgetPart;
  END;

  XmSeparatorGadgetRec = _XmSeparatorGadgetRec;

VAR
  xmSeparatorGCacheObjClassRec: XmSeparatorGCacheObjClassRec;
  xmSeparatorGadgetClassRec: XmSeparatorGadgetClassRec;

(*  MACROS for accessing instance fields *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE SEPG_Margin ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE SEPG_Orientation ( w: Xt.Widget ): SHORTCARD;
PROCEDURE SEPG_SeparatorType ( w: Xt.Widget ): SHORTCARD;
PROCEDURE SEPG_SeparatorGC ( w: Xt.Widget ): Xlib.GC;

<* ELSE *>

PROCEDURE  / SEPG_Margin ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / SEPG_Orientation ( w: Xt.Widget ): SHORTCARD;
PROCEDURE  / SEPG_SeparatorType ( w: Xt.Widget ): SHORTCARD;
PROCEDURE  / SEPG_SeparatorGC ( w: Xt.Widget ): Xlib.GC;

<* END *>

(*  Convenience Macros  *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE SEPG_Cache ( w: Xt.Widget ): XmSeparatorGCache;
PROCEDURE SEPG_ClassCachePart ( w: Xt.WidgetClass ): XmCacheClassPartPtr;

<* ELSE *>

PROCEDURE  / SEPG_Cache ( w: Xt.Widget ): XmSeparatorGCache;
PROCEDURE  / SEPG_ClassCachePart ( w: Xt.WidgetClass ): XmCacheClassPartPtr;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmSeparatorCacheCompare ( A: Xt.XtPointer;
                                     B: Xt.XtPointer ): SYSTEM.int;

(********    End Private Function Declarations    ********)
(* -------------------------------------------------- *)
(*                     Xm/MainW.h                     *)
(* -------------------------------------------------- *)

(*
 * Motif Release 1.2.2
 *)

VAR
  xmMainWindowWidgetClass: Xt.WidgetClass;

TYPE
  XmMainWindowWidgetClass = POINTER TO _XmMainWindowClassRec;

  XmMainWindowWidget = POINTER TO _XmMainWindowRec;

(********    Public Function Declarations    ********)

PROCEDURE XmMainWindowSetAreas ( w: Xt.Widget;
                                 menu: Xt.Widget;
                                 command: Xt.Widget;
                                 hscroll: Xt.Widget;
                                 vscroll: Xt.Widget;
                                 wregion: Xt.Widget );

PROCEDURE XmMainWindowSep1 ( w: Xt.Widget ): Xt.Widget;

PROCEDURE XmMainWindowSep2 ( w: Xt.Widget ): Xt.Widget;

PROCEDURE XmMainWindowSep3 ( w: Xt.Widget ): Xt.Widget;

PROCEDURE XmCreateMainWindow ( parent: Xt.Widget;
                               name: ARRAY OF CHAR;
                               args: Xt.ArgList;
                               argCount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* --------------------------------------------------- *)
(*                     Xm/MainWP.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*  Constraint part record for MainWindow widget  *)

TYPE
  _XmMainWindowConstraintPart = RECORD
    unused: CHAR;
  END;

  XmMainWindowConstraintPart = _XmMainWindowConstraintPart;

  XmMainWindowConstraint = POINTER TO _XmMainWindowConstraintPart;

(*  New fields for the MainWindow widget class record  *)

  _XmMainWindowClassPart = RECORD
    extension: Xt.XtPointer;   (*  Pointer to extension record  *)
  END;

  XmMainWindowClassPart = _XmMainWindowClassPart;

(****************
 *
 * Class record declaration
 *
 ****************)

  _XmMainWindowClassRec = RECORD
    core_class      : Xt.CoreClassPart;
    composite_class : Xt.CompositeClassPart;
    constraint_class: Xt.ConstraintClassPart;
    manager_class   : XmManagerClassPart;
    swindow_class   : XmScrolledWindowClassPart;
    mwindow_class   : XmMainWindowClassPart;
  END;

  XmMainWindowClassRec = _XmMainWindowClassRec;

(****************
 *
 * Main Window instance structure.
 *
 ****************)

  _XmMainWindowPart = RECORD
    AreaWidth    : Xt.Dimension;
    AreaHeight   : Xt.Dimension;
    margin_width : Xt.Dimension;
    margin_height: Xt.Dimension;
    CommandWindow: Xt.Widget;
    MenuBar      : Xt.Widget;
    Message      : Xt.Widget;
    CommandLoc   : SHORTCARD;
    Sep1         : XmSeparatorGadget;
    Sep2         : XmSeparatorGadget;
    Sep3         : XmSeparatorGadget;
    ManagingSep  : Xt.Boolean;
    ShowSep      : Xt.Boolean;
  END;

  XmMainWindowPart = _XmMainWindowPart;

(************************************************************************
 *									*
 * Full instance record declaration					*
 *									*
 ************************************************************************)

  _XmMainWindowRec = RECORD
    core      : Xt.CorePart;
    composite : Xt.CompositePart;
    constraint: Xt.ConstraintPart;
    manager   : XmManagerPart;
    swindow   : XmScrolledWindowPart;
    mwindow   : XmMainWindowPart;
  END;

  XmMainWindowRec = _XmMainWindowRec;

VAR
  xmMainWindowClassRec: XmMainWindowClassRec;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/MenuShell.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2
 *)

VAR
  xmMenuShellWidgetClass: Xt.WidgetClass;

TYPE
  XmMenuShellWidgetClass = POINTER TO _XmMenuShellClassRec;

  XmMenuShellWidget = POINTER TO _XmMenuShellWidgetRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateMenuShell ( parent: Xt.Widget;
                              name: ARRAY OF CHAR;
                              al: Xt.ArgList;
                              ac: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/MenuShellP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(*  The MenuShell instance record  *)

TYPE
  _XmMenuShellPart = RECORD
    focus_policy     : SHORTCARD;
    focus_data       : XmFocusData;
    private_shell    : Xt.Boolean;
    default_font_list: XmFontList;
    button_font_list : XmFontList;
    label_font_list  : XmFontList;
  END;

  XmMenuShellPart = _XmMenuShellPart;

(*  Full instance record declaration  *)

  _XmMenuShellRec = RECORD
    core      : Xt.CorePart;
    composite : Xt.CompositePart;
    shell     : ShellP.ShellPart;
    override  : ShellP.OverrideShellPart;
    menu_shell: XmMenuShellPart;
  END;

  XmMenuShellRec = _XmMenuShellRec;

(*  OBSOLETE (for compatibility only). *)

  _XmMenuShellWidgetRec = RECORD
    core      : Xt.CorePart;
    composite : Xt.CompositePart;
    shell     : ShellP.ShellPart;
    override  : ShellP.OverrideShellPart;
    menu_shell: XmMenuShellPart;
  END;

  XmMenuShellWidgetRec = _XmMenuShellWidgetRec;

(*  MenuShell class structure  *)

  _XmMenuShellClassPart = RECORD
    popdownOne     : Xt.XtActionProc;(* fnct to unpost portion or all of menu*)
    popdownEveryone: Xt.XtActionProc;(* fnct to unpost portion of menu *)
    popdownDone    : Xt.XtActionProc;(* fnct to unpost all menus *)
    popupSharedMenupane: XmMenuPopupProc;(* fnct to post shared menus *)
    (* Really should be popupSharedMenuShell *)
    extension      : Xt.XtPointer;   (* Pointer to extension record *)
  END;

  XmMenuShellClassPart = _XmMenuShellClassPart;

(*  Full class record declaration  *)

  _XmMenuShellClassRec = RECORD
    core_class          : Xt.CoreClassPart;
    composite_class     : Xt.CompositeClassPart;
    shell_class         : ShellP.ShellClassPart;
    override_shell_class: ShellP.OverrideShellClassPart;
    menu_shell_class    : XmMenuShellClassPart;
  END;

  XmMenuShellClassRec = _XmMenuShellClassRec;

VAR
  xmMenuShellClassRec: XmMenuShellClassRec;

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE MS_FocusPolicy ( m: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / MS_FocusPolicy ( m: Xt.Widget ): Xt.Boolean;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmEnterRowColumn ( widget: Xt.Widget;
                              closure: Xt.XtPointer;
                              VAR event: Xlib.XEvent;
                              VAR cont: Xt.Boolean );

PROCEDURE _XmClearTraversal ( wid: Xt.Widget;
                              VAR event: Xlib.XEvent;
                              params: Xt.StringList;
                              VAR num_params: Xt.Cardinal );

PROCEDURE _XmSetLastManagedMenuTime ( wid: Xt.Widget;
                                      newTime: X.Time );

(********    End Private Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/RowColumn.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2
 *)

VAR
  xmRowColumnWidgetClass: Xt.WidgetClass;

TYPE
  XmRowColumnWidgetClass = POINTER TO _XmRowColumnClassRec;

  XmRowColumnWidget = POINTER TO _XmRowColumnRec;

(********    Public Function Declarations    ********)

PROCEDURE XmMenuPosition ( p: Xt.Widget;
                           VAR event: Xlib.XKeyPressedEvent );

PROCEDURE XmCreateRowColumn ( p: Xt.Widget;
                              name: ARRAY OF CHAR;
                              al: Xt.ArgList;
                              ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateWorkArea ( p: Xt.Widget;
                             name: ARRAY OF CHAR;
                             al: Xt.ArgList;
                             ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateRadioBox ( p: Xt.Widget;
                             name: ARRAY OF CHAR;
                             al: Xt.ArgList;
                             ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateOptionMenu ( p: Xt.Widget;
                               name: ARRAY OF CHAR;
                               al: Xt.ArgList;
                               ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmOptionLabelGadget ( m: Xt.Widget ): Xt.Widget;

PROCEDURE XmOptionButtonGadget ( m: Xt.Widget ): Xt.Widget;

PROCEDURE XmCreateMenuBar ( p: Xt.Widget;
                            name: ARRAY OF CHAR;
                            al: Xt.ArgList;
                            ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreatePopupMenu ( p: Xt.Widget;
                              name: ARRAY OF CHAR;
                              al: Xt.ArgList;
                              ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreatePulldownMenu ( p: Xt.Widget;
                                 name: ARRAY OF CHAR;
                                 al: Xt.ArgList;
                                 ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmAddToPostFromList ( menu_wid: Xt.Widget;
                                widget: Xt.Widget );

PROCEDURE XmRemoveFromPostFromList ( menu_wid: Xt.Widget;
                                     widget: Xt.Widget );

PROCEDURE XmGetPostedFromWidget ( menu: Xt.Widget ): Xt.Widget;

PROCEDURE XmGetTearOffControl ( menu: Xt.Widget ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/RowColumnP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*  Button Event Status Record for popup verification at manage time  *)

TYPE
  _XmButtonEventStatusRec = RECORD
    time                 : X.Time;
    verified             : Xt.Boolean;
    waiting_to_be_managed: Xt.Boolean;
    event                : Xlib.XButtonEvent;
  END;

  XmButtonEventStatusRec = _XmButtonEventStatusRec;

(*  replay info rec - last menu that was posted before event replay  *)

  _XmReplayInfoRec = RECORD
    time         : X.Time;
    toplevel_menu: Xt.Widget;
  END;

  XmReplayInfoRec = _XmReplayInfoRec;

  _XmMenuFocusRec = RECORD
    oldWidget: Xt.Widget;
    oldFocus : X.Window;
    oldRevert: SYSTEM.int;
  END;

  XmMenuFocusRec = _XmMenuFocusRec;

(*  Menu State is per screen  *)

  _XmMenuStateRec = RECORD
    RC_LastSelectToplevel                           : Xt.Widget;
    RC_ButtonEventStatus                            : XmButtonEventStatusRec;
    RC_ReplayInfo                                   : XmReplayInfoRec;
    (* needed for funky menubar mode so that the traversal can be restored
     * to the correct highlighted item when we are done.
     *)
    RC_activeItem                                   : Xt.Widget;
    RC_menuFocus                                    : XmMenuFocusRec;
    (* A workaround is provided to allow applications to get insensitive
     * menu items.  This is useful for context "sensitive-shared-tear off-
     * accelerated" menu items.  Accessed via internal (for now) function,
     * _XmAllowAcceleratedInsensitiveUmanagedMenuItems().
     *)
    RC_allowAcceleratedInsensitiveUnmanagedMenuItems: Xt.Boolean;
    MS_LastManagedMenuTime                          : X.Time;
    MU_InDragMode                                   : Xt.Boolean;
    MU_CurrentMenuChild                             : Xt.Widget;
    MU_InPMMode                                     : Xt.Boolean;
  END;

  XmMenuStateRec = _XmMenuStateRec;

  XmMenuState = POINTER TO _XmMenuStateRec;

  _XmRCKidGeometryRec = RECORD
    kid          : Xt.Widget;
    box          : Xt.XtWidgetGeometry;
    margin_top   : Xt.Dimension;
    margin_bottom: Xt.Dimension;
    baseline     : Xt.Dimension;
  END;

  XmRCKidGeometryRec = _XmRCKidGeometryRec;

  XmRCKidGeometry = POINTER TO _XmRCKidGeometryRec;

(*  The RowColumn instance record  *)

  _XmRowColumnPart = RECORD
    margin_height    : Xt.Dimension;     (* margin around inside of widget *)
    margin_width     : Xt.Dimension;
    spacing          : Xt.Dimension;     (* pixels between entries *)
    entry_border     : Xt.Dimension;     (* size of entry borders
      	      	      	      	      	  * next only used w/ menubars *)
    help_pushbutton  : Xt.Widget;        (* ptr to help pushbutton widget *)
    cascadeBtn       : Xt.Widget;        (* if this menu is pulled down by a
                      	      	      	  * pulldown widget this will point
                                          * at the pulldown.  needed to go
                                          * up the cascade
                                          * next two only used w/ option menus
                                          * they are really only temporary
                                          * since the data is passed off to
                                          * the pulldown widget which is
                                          * automatically built *)
    option_label     : XmString;         (* label for option menu pulldown *)
    option_submenu   : Xt.Widget;        (* which submenu to pulldown *)
    boxes            : XmRCKidGeometry;  (* when doing menu layouts is an
                      	      	      	  * array of geo req's to make it easy
                                          *)
    entry_class      : Xt.WidgetClass;   (* if homogeneous, what class *)
    entry_callback   : Xt.XtCallbackList;(* a child fired off *)
    map_callback     : Xt.XtCallbackList;(* about to be mapped call back *)
    unmap_callback   : Xt.XtCallbackList;(* about to be unmapped call back *)
    memory_subwidget : Xt.Widget;        (* id of last subwidget that
      	      	      	      	      	  * fired off.  Recorded by the
                                          * entry_fired proc, can be set too
                                          * this causes mouse/muscle memory
                                          * to also be reset *)
    num_columns      : SYSTEM.INT16;     (* if columnar packing this is how
      	      	      	      	      	  * many columns to use *)
    menuPost         : Xt.String;        (* a translation for posting popups *)
    postButton       : CARDINAL;         (* active mouse button *)
    postEventType    : SYSTEM.int;       (* active mouse event type *)
    postModifiers    : CARDINAL;         (* active mouse modifier *)
    menu_accelerator : Xt.String;
    mnemonic         : X.KeySym;
    mnemonicCharSet  : XmStringCharSet;
    entry_alignment  : SHORTCARD;        (* type of label alignment
      	      	      	      	      	  * our children should have
                                          * next two are layout, Tight is the
                                          * standard menubar packing.  Columns
                                          * is radio box style, orientation
                                          * determines if it is column or row
                                          * major, Vert = column major *)
    packing          : SHORTCARD;        (* entry packing (layout) style *)
    type             : SHORTCARD;        (* temporary: diff between menu/bar *)
    orientation      : SHORTCARD;        (* horizontal or vertical
      	      	      	      	      	  * next two indicate how the widget
                                          * responds to size changes if there
                                          * is no geo mgr.  If true then the
                                          * dimension is never changed.  Set
                                          * to true if dimension is spec'd
                                          * at create time *)
    armed            : Xt.Boolean;       (* controls whether pulldowns work
                                          * or not, button down in any part of
                                          * the menubar arms it, this is a bit
                                          * field used for other internal
                                          * flags, see macros next is only
                                          * valid for popup menus *)
    adjust_margin    : Xt.Boolean;       (* T/F, indicating if we should force
                                          * all subwidgets to have similar
                                          * margins *)
    adjust_last      : Xt.Boolean;       (* Indicates whether or not the last
      	      	      	      	      	  * row or column should be stretched
                                          * to the edge of the row_column
                                          * widget. *)
    do_alignment     : Xt.Boolean;       (* T/F, do we force alignment on all
                                          * our children *)
    radio            : Xt.Boolean;       (* T/F, do we do the toggle button
                                          * 'only-one-down' enforcement *)
    radio_one        : Xt.Boolean;       (* T/F, must have one radio button
                                          * set to on *)
    homogeneous      : Xt.Boolean;       (* T/F, do we only allow a single
                                          * class of children *)
    resize_width     : Xt.Boolean;
    resize_height    : Xt.Boolean;
    popup_enabled    : Xt.Boolean;
    old_width        : Xt.Dimension;     (* save the old width, etc to use *)
    old_height       : Xt.Dimension;     (* at resize time since it now has *)
    old_shadow_thickness: Xt.Dimension;  (* NW gravity *)
    postFromList     : Xt.WidgetList;    (* list for sharing menupanes *)
    postFromCount    : SYSTEM.int;       (* count of the list *)
    postFromListSize : SYSTEM.int;       (* size of the malloc'ed list *)
    lastSelectToplevel: Xt.Widget;       (* returned in XmGetPostedFromWidget*)
    popupPosted      : Xt.Widget;        (* popup submenu currently posted *)
    oldFocusPolicy   : SHORTCARD;        (* save when menus begin traversal *)
(***************** 1.2 ***************)
    TearOffModel     : SHORTCARD;        (* enable/disable flag *)
    ParentShell      : Xt.Widget;        (* Save the parent shell when torn *)
    tear_off_control : Xt.Widget;
    to_state         : Xt.Boolean;       (* tear off state *)
    (* tear off activate/deactivate callbacks *)
    tear_off_activated_callback  : Xt.XtCallbackList;
    tear_off_deactivated_callback: Xt.XtCallbackList;
    tear_off_lastSelectToplevel  : Xt.Widget;
    tear_off_focus_item          : Xt.Widget; (* when tear off is inactive *)
    entry_vertical_alignment     : SHORTCARD;
    popup_menu_click             : SHORTCARD;
    popup_timeout_timer          : Xt.XtIntervalId;
  END;

  XmRowColumnPart = _XmRowColumnPart;

(*  Full instance record declaration  *)

  _XmRowColumnRec = RECORD
    core      : Xt.CorePart;
    composite : Xt.CompositePart;
    constraint: Xt.ConstraintPart;
    manager   : XmManagerPart;
    row_column: XmRowColumnPart;
  END;

  XmRowColumnRec = _XmRowColumnRec;

(*  OBSOLETE (for compatibility only). *)

  _XmRowColumnWidgetRec = RECORD
    core      : Xt.CorePart;
    composite : Xt.CompositePart;
    constraint: Xt.ConstraintPart;
    manager   : XmManagerPart;
    row_column: XmRowColumnPart;
  END;

  XmRowColumnWidgetRec = _XmRowColumnWidgetRec;

(*  RowColumn class structure  *)

  XmRowColumnClassPart = RECORD
    menuProcedures  : XmMenuProc;     (* proc to interface with menu widgets *)
    armAndActivate  : Xt.XtActionProc;(* proc triggered by acclerator *)
    traversalHandler: XmMenuTraversalProc;(* proc to handle menu traversal *)
    extension       : Xt.XtPointer;   (* Pointer to extension record *)
  END;

  _XmRowColumnClassPart = XmRowColumnClassPart;

  _XmRowColumnClassRec = RECORD
    core_class      : Xt.CoreClassPart;
    composite_class : Xt.CompositeClassPart;
    constraint_class: Xt.ConstraintClassPart;
    manager_class   : XmManagerClassPart;
    row_column_class: XmRowColumnClassPart;
  END;

  XmRowColumnClassRec = _XmRowColumnClassRec;

(*  Constraint Definition  *)
(*  No constraint resources  *)

  _XmRowColumnConstraintPart = RECORD
    was_managed   : Xt.Boolean;
    margin_top    : Xt.Dimension;
    margin_bottom : Xt.Dimension;
    baseline      : Xt.Dimension;
    position_index: SYSTEM.INT16;
  END;

  XmRowColumnConstraintPart = _XmRowColumnConstraintPart;

  _XmRowColumnConstraintRec = RECORD
    manager   : XmManagerConstraintPart;
    row_column: XmRowColumnConstraintPart;
  END;

  XmRowColumnConstraintRec = _XmRowColumnConstraintRec;

VAR
  xmRowColumnClassRec: XmRowColumnClassRec;

CONST
  XmRC_ARMED_BIT        = SET8{0};
  XmRC_BEING_ARMED_BIT  = SET8{1}; (* bits in menu's armed byte *)
  XmRC_EXPOSE_BIT       = SET8{2}; (* used in both menu and *)
  XmRC_WINDOW_MOVED_BIT = SET8{3}; (* popup menu, careful *)
  XmRC_WIDGET_MOVED_BIT = SET8{4};
  XmRC_POPPING_DOWN_BIT = SET8{5};
  XmRC_FROM_RESIZE_BIT  = SET8{6};

(*  Access Macros  *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE RC_IsArmed ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_BeingArmed ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_DoExpose ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_WidgetHasMoved ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_WindowHasMoved ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_PoppingDown ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_FromResize ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_SetBit ( byte: Xt.Boolean;
                      bit: SET8;
                      v: BOOLEAN );
PROCEDURE RC_SetArmed ( m: Xt.Widget;
                        v: BOOLEAN );
PROCEDURE RC_SetBeingArmed ( m: Xt.Widget;
                             v: BOOLEAN );
PROCEDURE RC_SetExpose ( m: Xt.Widget;
                         v: BOOLEAN );
PROCEDURE RC_SetWidgetMoved ( m: Xt.Widget;
                              v: BOOLEAN );
PROCEDURE RC_SetWindowMoved ( m: Xt.Widget;
                              v: BOOLEAN );
PROCEDURE RC_SetPoppingDown ( m: Xt.Widget;
                              v: BOOLEAN );
PROCEDURE RC_SetFromResize ( m: Xt.Widget;
                             v: BOOLEAN );
PROCEDURE RC_MarginW ( m: Xt.Widget ): Xt.Dimension;
PROCEDURE RC_MarginH ( m: Xt.Widget ): Xt.Dimension;
PROCEDURE RC_Entry_cb ( m: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE RC_Map_cb ( m: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE RC_Unmap_cb ( m: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE RC_Orientation ( m: Xt.Widget ): SHORTCARD;
PROCEDURE RC_Spacing ( m: Xt.Widget ): Xt.Dimension;
PROCEDURE RC_EntryBorder ( m: Xt.Widget ): Xt.Dimension;
PROCEDURE RC_HelpPb ( m: Xt.Widget ): Xt.Widget;
PROCEDURE RC_DoMarginAdjust ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_EntryAlignment ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_EntryVerticalAlignment ( m: Xt.Widget ): SHORTCARD;
PROCEDURE RC_Packing ( m: Xt.Widget ): SHORTCARD;
PROCEDURE RC_NCol ( m: Xt.Widget ): SYSTEM.INT16;
PROCEDURE RC_AdjLast ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_AdjMargin ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_MemWidget ( m: Xt.Widget ): Xt.Widget;
PROCEDURE RC_CascadeBtn ( m: Xt.Widget ): Xt.Widget;
PROCEDURE RC_OptionLabel ( m: Xt.Widget ): XmString;
PROCEDURE RC_OptionSubMenu ( m: Xt.Widget ): Xt.Widget;
PROCEDURE RC_RadioBehavior ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_RadioAlwaysOne ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_PopupPosted ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_ResizeHeight ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_ResizeWidth ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_Type ( m: Xt.Widget ): SHORTCARD;
PROCEDURE RC_EntryClass ( m: Xt.Widget ): Xt.WidgetClass;
PROCEDURE RC_IsHomogeneous ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_Boxes ( m: Xt.Widget ): XmRCKidGeometry;
PROCEDURE RC_PopupEnabled ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_MenuAccelerator ( m: Xt.Widget ): Xt.String;
PROCEDURE RC_Mnemonic ( m: Xt.Widget ): Xt.String;
PROCEDURE RC_MnemonicCharSet ( m: Xt.Widget ): XmStringCharSet;
PROCEDURE RC_MenuPost ( m: Xt.Widget ): Xt.String;
PROCEDURE RC_PostButton ( m: Xt.Widget ): CARDINAL;
PROCEDURE RC_PostModifiers ( m: Xt.Widget ): CARDINAL;
PROCEDURE RC_PostEventType ( m: Xt.Widget ): SYSTEM.int;
PROCEDURE RC_OldFocusPolicy ( m: Xt.Widget ): SHORTCARD;
PROCEDURE RC_ParentShell ( m: Xt.Widget ): Xt.Widget;
PROCEDURE RC_TearOffControl ( m: Xt.Widget ): Xt.Widget;
PROCEDURE RC_TearOffModel ( m: Xt.Widget ): SHORTCARD;
PROCEDURE RC_popupMenuClick ( m: Xt.Widget ): SHORTCARD;

<* ELSE *>

PROCEDURE  / RC_IsArmed ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_BeingArmed ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_DoExpose ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_WidgetHasMoved ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_WindowHasMoved ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_PoppingDown ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_FromResize ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_SetBit ( VAR byte: Xt.Boolean;
                         bit: SET8;
                         v: BOOLEAN );
PROCEDURE  / RC_SetArmed ( m: Xt.Widget;
                           v: BOOLEAN );
PROCEDURE  / RC_SetBeingArmed ( m: Xt.Widget;
                                v: BOOLEAN );
PROCEDURE  / RC_SetExpose ( m: Xt.Widget;
                            v: BOOLEAN );
PROCEDURE  / RC_SetWidgetMoved ( m: Xt.Widget;
                                 v: BOOLEAN );
PROCEDURE  / RC_SetWindowMoved ( m: Xt.Widget;
                                 v: BOOLEAN );
PROCEDURE  / RC_SetPoppingDown ( m: Xt.Widget;
                                 v: BOOLEAN );
PROCEDURE  / RC_SetFromResize ( m: Xt.Widget;
                                v: BOOLEAN );
PROCEDURE  / RC_MarginW ( m: Xt.Widget ): Xt.Dimension;
PROCEDURE  / RC_MarginH ( m: Xt.Widget ): Xt.Dimension;
PROCEDURE  / RC_Entry_cb ( m: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / RC_Map_cb ( m: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / RC_Unmap_cb ( m: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / RC_Orientation ( m: Xt.Widget ): SHORTCARD;
PROCEDURE  / RC_Spacing ( m: Xt.Widget ): Xt.Dimension;
PROCEDURE  / RC_EntryBorder ( m: Xt.Widget ): Xt.Dimension;
PROCEDURE  / RC_HelpPb ( m: Xt.Widget ): Xt.Widget;
PROCEDURE  / RC_DoMarginAdjust ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_EntryAlignment ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_EntryVerticalAlignment ( m: Xt.Widget ): SHORTCARD;
PROCEDURE  / RC_Packing ( m: Xt.Widget ): SHORTCARD;
PROCEDURE  / RC_NCol ( m: Xt.Widget ): SYSTEM.INT16;
PROCEDURE  / RC_AdjLast ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_AdjMargin ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_MemWidget ( m: Xt.Widget ): Xt.Widget;
PROCEDURE  / RC_CascadeBtn ( m: Xt.Widget ): Xt.Widget;
PROCEDURE  / RC_OptionLabel ( m: Xt.Widget ): XmString;
PROCEDURE  / RC_OptionSubMenu ( m: Xt.Widget ): Xt.Widget;
PROCEDURE  / RC_RadioBehavior ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_RadioAlwaysOne ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_PopupPosted ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_ResizeHeight ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_ResizeWidth ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_Type ( m: Xt.Widget ): SHORTCARD;
PROCEDURE  / RC_EntryClass ( m: Xt.Widget ): Xt.WidgetClass;
PROCEDURE  / RC_IsHomogeneous ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_Boxes ( m: Xt.Widget ): XmRCKidGeometry;
PROCEDURE  / RC_PopupEnabled ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_MenuAccelerator ( m: Xt.Widget ): Xt.String;
PROCEDURE  / RC_Mnemonic ( m: Xt.Widget ): Xt.String;
PROCEDURE  / RC_MnemonicCharSet ( m: Xt.Widget ): XmStringCharSet;
PROCEDURE  / RC_MenuPost ( m: Xt.Widget ): Xt.String;
PROCEDURE  / RC_PostButton ( m: Xt.Widget ): CARDINAL;
PROCEDURE  / RC_PostModifiers ( m: Xt.Widget ): CARDINAL;
PROCEDURE  / RC_PostEventType ( m: Xt.Widget ): SYSTEM.int;
PROCEDURE  / RC_OldFocusPolicy ( m: Xt.Widget ): SHORTCARD;
PROCEDURE  / RC_ParentShell ( m: Xt.Widget ): Xt.Widget;
PROCEDURE  / RC_TearOffControl ( m: Xt.Widget ): Xt.Widget;
PROCEDURE  / RC_TearOffModel ( m: Xt.Widget ): SHORTCARD;
PROCEDURE  / RC_popupMenuClick ( m: Xt.Widget ): SHORTCARD;

<* END *>

(*  Tear Off State  *)

CONST
  XmTO_TORN_OFF_BIT     = SET8{0};
  XmTO_FROM_INIT_BIT    = SET8{1};
  XmTO_VISUAL_DIRTY_BIT = SET8{2};
  XmTO_ACTIVE_BIT       = SET8{3};

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE RC_SetTornOff ( m: Xt.Widget;
                          v: BOOLEAN );
PROCEDURE RC_TornOff ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_SetFromInit ( m: Xt.Widget;
                           v: BOOLEAN );
PROCEDURE RC_FromInit ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_SetTearOffDirty ( m: Xt.Widget;
                               v: BOOLEAN );
PROCEDURE RC_TearOffDirty ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_TearOffActive ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE RC_SetTearOffActive ( m: Xt.Widget;
                                v: BOOLEAN );

<* ELSE *>

PROCEDURE  / RC_SetTornOff ( m: Xt.Widget;
                             v: BOOLEAN );
PROCEDURE  / RC_TornOff ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_SetFromInit ( m: Xt.Widget;
                              v: BOOLEAN );
PROCEDURE  / RC_FromInit ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_SetTearOffDirty ( m: Xt.Widget;
                                  v: BOOLEAN );
PROCEDURE  / RC_TearOffDirty ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_TearOffActive ( m: Xt.Widget ): Xt.Boolean;
PROCEDURE  / RC_SetTearOffActive ( m: Xt.Widget;
                                   v: BOOLEAN );

<* END *>

CONST
  initial_value = 0;

(*  Defines used when calling _XmProcessMenuTree()  *)
  XmADD = 0;
  XmDELETE = 1;
  XmREPLACE = 2;

(*  Defines used when calling _XmMenuIsAccessible()  *)
  XmWEAK_CHECK = 1;
  XmMEDIUM_CHECK = 2;
  XmSTRONG_CHECK = 3;
  XmMENU_BEGIN = 0;
  XmMENU_MIDDLE = 1;
  XmMENU_END = 2;

(*  Defines used when calling find_first_managed_child()  *)
  ANY_CHILD = 0;
  FIRST_BUTTON = 1;

(********    Private Function Declarations    ********)

PROCEDURE _XmPostPopupMenu ( wid: Xt.Widget;
                             VAR event: Xlib.XEvent );

PROCEDURE _XmSetPopupMenuClick ( wid: Xt.Widget;
                                 popupMenuClick: Xt.Boolean );

PROCEDURE _XmGetPopupMenuClick ( wid: Xt.Widget ): Xt.Boolean;

PROCEDURE _XmAllowAcceleratedInsensitiveUnmanagedMenuItems ( wid: Xt.Widget;
                                                             allowed: Xt.Boolean );

PROCEDURE _XmSetSwallowEventHandler ( widget: Xt.Widget;
                                      add_handler: Xt.Boolean );

PROCEDURE _XmMenuFocus ( w: Xt.Widget;
                         operation: SYSTEM.int;
                         _time: X.Time );

PROCEDURE _XmGetActiveTopLevelMenu ( wid: Xt.Widget;
                                     VAR rwid: Xt.Widget );

PROCEDURE _XmMatchBSelectEvent ( wid: Xt.Widget;
                                 VAR event: Xlib.XEvent ): Xt.Boolean;

PROCEDURE _XmMatchBDragEvent ( wid: Xt.Widget;
                               VAR event: Xlib.XEvent ): Xt.Boolean;

PROCEDURE _XmHandleMenuButtonPress ( wid: Xt.Widget;
                                     VAR event: Xlib.XEvent );

PROCEDURE _XmMenuBtnDown ( wid: Xt.Widget;
                           VAR event: Xlib.XEvent;
                           params: Xt.StringList;
                           VAR num_params: Xt.Cardinal );

PROCEDURE _XmMenuBtnUp ( wid: Xt.Widget;
                         VAR event: Xlib.XEvent;
                         params: Xt.StringList;
                         VAR num_params: Xt.Cardinal );

PROCEDURE _XmCallRowColumnMapCallback ( wid: Xt.Widget;
                                        VAR event: Xlib.XEvent );

PROCEDURE _XmCallRowColumnUnmapCallback ( wid: Xt.Widget;
                                          VAR event: Xlib.XEvent );

PROCEDURE _XmMenuPopDown ( w: Xt.Widget;
                           VAR event: Xlib.XEvent;
                           VAR popped_up: Xt.Boolean );

PROCEDURE _XmIsActiveTearOff ( w: Xt.Widget ): Xt.Boolean;

PROCEDURE _XmMenuHelp ( wid: Xt.Widget;
                        VAR event: Xlib.XEvent;
                        params: Xt.StringList;
                        VAR num_params: Xt.Cardinal );

(********    End Private Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/MenuUtilP.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2.1
 *)

TYPE
  _XmTranslPtr = POINTER TO _XmTranslRec;

  _XmTranslRec = RECORD
    translations: Xt.XtTranslations;
    next        : _XmTranslPtr;
  END;

(********    Private Function Declarations    ********)
(*  extern Boolean _XmIsActiveTearOff (  *)
(*                        Widget w) ;    *)

PROCEDURE _XmGetRC_PopupPosted ( wid: Xt.Widget ): Xt.Widget;

PROCEDURE _XmGetInDragMode ( widget: Xt.Widget ): Xt.Boolean;

PROCEDURE _XmSetInDragMode ( widget: Xt.Widget;
                             mode: Xt.Boolean );

PROCEDURE _XmSaveMenuProcContext ( address: Xt.XtPointer );

PROCEDURE _XmGetMenuProcContext (  ): Xt.XtPointer;

PROCEDURE _XmGrabPointer ( widget: Xt.Widget;
                           owner_events: SYSTEM.int;
                           event_mask: CARDINAL;
                           pointer_mode: SYSTEM.int;
                           keyboard_mode: SYSTEM.int;
                           confine_to: X.Window;
                           cursor: X.Cursor;
                           time: X.Time ): SYSTEM.int;

PROCEDURE _XmGrabKeyboard ( widget: Xt.Widget;
                            owner_events: SYSTEM.int;
                            pointer_mode: SYSTEM.int;
                            keyboard_mode: SYSTEM.int;
                            time: X.Time ): SYSTEM.int;

PROCEDURE _XmMenuSetInPMMode ( wid: Xt.Widget;
                               flag: Xt.Boolean );

PROCEDURE _XmSetMenuTraversal ( wid: Xt.Widget;
                                traversalOn: Xt.Boolean );

PROCEDURE _XmLeafPaneFocusOut ( wid: Xt.Widget );

PROCEDURE _XmMenuTraverseLeft ( wid: Xt.Widget;
                                VAR event: Xlib.XEvent;
                                VAR param: Xt.StringList;
                                VAR num_param: Xt.Cardinal );

PROCEDURE _XmMenuTraverseRight ( wid: Xt.Widget;
                                 VAR event: Xlib.XEvent;
                                 VAR param: Xt.StringList;
                                 VAR num_param: Xt.Cardinal );

PROCEDURE _XmMenuTraverseUp ( wid: Xt.Widget;
                              VAR event: Xlib.XEvent;
                              VAR param: Xt.StringList;
                              VAR num_param: Xt.Cardinal );

PROCEDURE _XmMenuTraverseDown ( wid: Xt.Widget;
                                VAR event: Xlib.XEvent;
                                VAR param: Xt.StringList;
                                VAR num_param: Xt.Cardinal );

PROCEDURE _XmMenuEscape ( w: Xt.Widget;
                          VAR event: Xlib.XEvent;
                          params: Xt.StringList;
                          VAR num_params: Xt.Cardinal );

PROCEDURE _XmRC_GadgetTraverseDown ( wid: Xt.Widget;
                                     VAR event: Xlib.XEvent;
                                     VAR param: Xt.StringList;
                                     VAR num_param: Xt.Cardinal );

PROCEDURE _XmRC_GadgetTraverseUp ( wid: Xt.Widget;
                                   VAR event: Xlib.XEvent;
                                   VAR param: Xt.StringList;
                                   VAR num_param: Xt.Cardinal );

PROCEDURE _XmRC_GadgetTraverseLeft ( wid: Xt.Widget;
                                     VAR event: Xlib.XEvent;
                                     VAR param: Xt.StringList;
                                     VAR num_param: Xt.Cardinal );

PROCEDURE _XmRC_GadgetTraverseRight ( wid: Xt.Widget;
                                      VAR event: Xlib.XEvent;
                                      VAR param: Xt.StringList;
                                      VAR num_param: Xt.Cardinal );

PROCEDURE _XmMenuTraversalHandler ( w: Xt.Widget;
                                    pw: Xt.Widget;
                                    direction: XmTraversalDirection );

PROCEDURE _XmSaveCoreClassTranslations ( widget: Xt.Widget );

PROCEDURE _XmRestoreCoreClassTranslations ( widget: Xt.Widget );

PROCEDURE _XmGetMenuState ( widget: Xt.Widget ): XmMenuState;

(********    End Private Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/MessageB.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(*  Class record constants  *)

VAR
  xmMessageBoxWidgetClass: Xt.WidgetClass;

TYPE
  XmMessageBoxWidgetClass = POINTER TO _XmMessageBoxClassRec;

  XmMessageBoxWidget = POINTER TO _XmMessageBoxRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateMessageBox ( parent: Xt.Widget;
                               name: ARRAY OF CHAR;
                               al: Xt.ArgList;
                               ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateMessageDialog ( parent: Xt.Widget;
                                  name: ARRAY OF CHAR;
                                  al: Xt.ArgList;
                                  ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateErrorDialog ( parent: Xt.Widget;
                                name: ARRAY OF CHAR;
                                al: Xt.ArgList;
                                ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateInformationDialog ( parent: Xt.Widget;
                                      name: ARRAY OF CHAR;
                                      al: Xt.ArgList;
                                      ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateQuestionDialog ( parent: Xt.Widget;
                                   name: ARRAY OF CHAR;
                                   al: Xt.ArgList;
                                   ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateWarningDialog ( parent: Xt.Widget;
                                  name: ARRAY OF CHAR;
                                  al: Xt.ArgList;
                                  ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateWorkingDialog ( parent: Xt.Widget;
                                  name: ARRAY OF CHAR;
                                  al: Xt.ArgList;
                                  ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateTemplateDialog ( parent: Xt.Widget;
                                   name: ARRAY OF CHAR;
                                   al: Xt.ArgList;
                                   ac: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmMessageBoxGetChild ( widget: Xt.Widget;
                                 child: SHORTCARD ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/MessageBP.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2.3
 *)

(*  Constraint part record for MessageBox widget  *)

TYPE
  _XmMessageBoxConstraintPart = RECORD
    unused: CHAR;
  END;

  XmMessageBoxConstraintPart = _XmMessageBoxConstraintPart;

  XmMessageBoxConstraint = POINTER TO _XmMessageBoxConstraintPart;

(*   New fields for the MessageBox widget class record   *)

  _XmMessageBoxClassPart = RECORD
    extension: Xt.XtPointer;   (*  Pointer to extension record  *)
  END;

  XmMessageBoxClassPart = _XmMessageBoxClassPart;

(*  Full class record declaration  *)

  _XmMessageBoxClassRec = RECORD
    core_class          : Xt.CoreClassPart;
    composite_class     : Xt.CompositeClassPart;
    constraint_class    : Xt.ConstraintClassPart;
    manager_class       : XmManagerClassPart;
    bulletin_board_class: XmBulletinBoardClassPart;
    message_box_class   : XmFormClassPart;
  END;

  XmMessageBoxClassRec = _XmMessageBoxClassRec;

(*  New fields for the MessageBox widget record  *)

  _XmMessageBoxPart = RECORD
    dialog_type        : SHORTCARD;
    default_type       : SHORTCARD;
    internal_pixmap    : Xt.Boolean;
    minimize_buttons   : Xt.Boolean;
    message_alignment  : SHORTCARD;
    message_string     : XmString;
    message_wid        : Xt.Widget;
    symbol_pixmap      : X.Pixmap;
    symbol_wid         : Xt.Widget;
    ok_label_string    : XmString;
    ok_callback        : Xt.XtCallbackList;
    ok_button          : Xt.Widget;
    cancel_label_string: XmString;
    cancel_callback    : Xt.XtCallbackList;
    help_label_string  : XmString;
    help_button        : Xt.Widget;
    separator          : Xt.Widget;
  END;

  XmMessageBoxPart = _XmMessageBoxPart;

(****************************************************************
 *
 * Full instance record declaration
 *
 ****************************************************************)

  _XmMessageBoxRec = RECORD
    core          : Xt.CorePart;
    composite     : Xt.CompositePart;
    constraint    : Xt.ConstraintPart;
    manager       : XmManagerPart;
    bulletin_board: XmBulletinBoardPart;
    message_box   : XmMessageBoxPart;
  END;

  XmMessageBoxRec = _XmMessageBoxRec;

VAR
  xmMessageBoxClassRec: XmMessageBoxClassRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmMessageBoxGeoMatrixCreate ( wid: Xt.Widget;
                                         instigator: Xt.Widget;
                                         VAR desired: Xt.XtWidgetGeometry ): XmGeoMatrix;

PROCEDURE _XmMessageBoxNoGeoRequest ( geoSpec: XmGeoMatrix ): Xt.Boolean;

(********    End Private Function Declarations    ********)

(* --------------------------------------------------- *)
(*                     Xm/PanedW.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(****************************************************************
 *
 * Vertical Paned Widget (SubClass of CompositeClass)
 *
 ****************************************************************)

(*  Class record constant  *)

VAR
  xmPanedWindowWidgetClass: Xt.WidgetClass;

TYPE
  XmPanedWindowWidgetClass = POINTER TO _XmPanedWindowClassRec;

  XmPanedWindowWidget = POINTER TO _XmPanedWindowRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreatePanedWindow ( parent: Xt.Widget;
                                name: ARRAY OF CHAR;
                                args: Xt.ArgList;
                                argCount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/PanedWP.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2.2
 *)

(*********************************************************************
 *
 * XmPanedWindowWidget Private Data
 *
 *********************************************************************)

TYPE
(*  New fields for the PanedWindow widget class record  *)

  _XmPanedWindowClassPart = RECORD
    extension: Xt.XtPointer;
  END;

  XmPanedWindowClassPart = _XmPanedWindowClassPart;

(*  Full Class record declaration  *)

  _XmPanedWindowClassRec = RECORD
    core_class        : Xt.CoreClassPart;
    composite_class   : Xt.CompositeClassPart;
    constraint_class  : Xt.ConstraintClassPart;
    manager_class     : XmManagerClassPart;
    paned_window_class: XmFrameClassPart;
  END;

  XmPanedWindowClassRec = _XmPanedWindowClassRec;

(*  PanedWindow constraint record  *)

  _XmPanedWindowConstraintPart = RECORD
    position      : SYSTEM.int;   (* position location in PanedWindow *)
    dheight       : SYSTEM.int;   (* Desired size *)
    dy            : Xt.Position;  (* Desired Location *)
    olddy         : Xt.Position;  (* The last value of dy. *)
    min           : Xt.Dimension; (* Minimum height *)
    max           : Xt.Dimension; (* Maximum height *)
    isPane        : Xt.Boolean;   (* true if constraint of pane, false if
                                   * constraint of sash *)
    allow_resize  : Xt.Boolean;   (* TRUE iff child resize requests are ok *)
    skip_adjust   : Xt.Boolean;   (* TRUE iff child's height should not be
                                   * changed without explicit user action. *)
    sash          : Xt.Widget;    (* The sash for this child  *)
    separator     : Xt.Widget;    (* The separator for this child  *)
    position_index: SYSTEM.INT16; (* new 1.2 positionIndex resource  *)
  END;

  XmPanedWindowConstraintPart = _XmPanedWindowConstraintPart;

  _XmPanedWindowConstraintRec = RECORD
    manager: XmManagerConstraintPart;
    panedw : XmPanedWindowConstraintPart;
  END;

  XmPanedWindowConstraintRec = _XmPanedWindowConstraintRec;

  XmPanedWindowConstraintPtr = POINTER TO _XmPanedWindowConstraintRec;

(*  New Fields for the PanedWindow widget record  *)

  _XmPanedWindowPart = RECORD
    (* resources *)
    refiguremode   : Xt.Boolean;  (* Whether to refigure changes right now *)
    separator_on   : Xt.Boolean;  (* make separator visible *)
    margin_width   : Xt.Dimension;(* space between right and left edges of
                                   * PanedWindow window and it's children *)
    margin_height  : Xt.Dimension;(* space between top and bottom edges of
                                   * PanedWindow window and it's children *)
    spacing        : Xt.Dimension;(* whitespace between panes
                                   * around window, else leave none *)
    (* sash modifying resources *)
    sash_width     : Xt.Dimension;(* Modify sash width  *)
    sash_height    : Xt.Dimension;(* Modify sash height  *)
    sash_shadow_thickness: Xt.Dimension;(* Modify sash shadow_thickness *)
    sash_indent    : Xt.Position;       (* Location of sashs (offset
                                         * from right margin) *)
    (* private *)
    starty         : SYSTEM.int;      (* mouse origin when adjusting *)
    increment_count: SYSTEM.INT16;    (* Sash increment count  *)
    pane_count     : SYSTEM.INT16;    (* number of managed panes  *)
    num_slots      : SYSTEM.INT16;    (* number of avail.slots for children *)
    num_managed_children:SYSTEM.INT16;(* holds number of managed children  *)
    recursively_called: Xt.Boolean;   (* For change_managed AND creation of
                                       * private sash and separator
                                       * children *)
    resize_at_realize : Xt.Boolean;   (* For realize if GeometryNo condition *)
    top_pane   : XmPanedWindowConstraintPtr;(* pane closest to 0 index *)
    bottom_pane: XmPanedWindowConstraintPtr;(* pane farthest away from 0 index *)
    flipgc     : Xlib.GC;              (* GC to use when animating borders  *)
    managed_children: Xt.WidgetList;   (* keep track of managed children  *)
  END;

  XmPanedWindowPart = _XmPanedWindowPart;

(**************************************************************************
 *
 * Full instance record declaration
 *
 **************************************************************************)

  _XmPanedWindowRec = RECORD
    core        : Xt.CorePart;
    composite   : Xt.CompositePart;
    constraint  : Xt.ConstraintPart;
    manager     : XmManagerPart;
    paned_window: XmPanedWindowPart;
  END;

  XmPanedWindowRec = _XmPanedWindowRec;

VAR
  xmPanedWindowClassRec: XmPanedWindowClassRec;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/Protocols.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2.3
 *)

(*  should be in Xm.h  *)

CONST
  XmCR_WM_PROTOCOLS = 6666;

(*  define the XM_PROTOCOLS atom for use in  routines  *)

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE XM_WM_PROTOCOL_ATOM ( shell: Xt.Widget ): X.Atom;
PROCEDURE XmAddWMProtocols ( shell: Xt.Widget;
                             protocols: X.PAAtom;
                             num_protocols: Xt.Cardinal );
PROCEDURE XmRemoveWMProtocols ( shell: Xt.Widget;
                                protocols: X.PAAtom;
                                num_protocols: Xt.Cardinal );
PROCEDURE XmAddWMProtocolCallback ( shell: Xt.Widget;
                                    protocol: X.Atom;
                                    callback: Xt.XtCallbackProc;
                                    closure: Xt.XtPointer );
PROCEDURE XmRemoveWMProtocolCallback ( shell: Xt.Widget;
                                       protocol: X.Atom;
                                       callback: Xt.XtCallbackProc;
                                       closure: Xt.XtPointer );
PROCEDURE XmActivateWMProtocol ( shell: Xt.Widget;
                                 protocol: X.Atom );
PROCEDURE XmDeactivateWMProtocol ( shell: Xt.Widget;
                                   protocol: X.Atom );
PROCEDURE XmSetWMProtocolHooks ( shell: Xt.Widget;
                                 protocol: X.Atom;
                                 pre_h: Xt.XtCallbackProc;
                                 pre_c: Xt.XtPointer;
                                 post_h: Xt.XtCallbackProc;
                                 post_c: Xt.XtPointer );

<* ELSE *>

PROCEDURE  / XM_WM_PROTOCOL_ATOM ( shell: Xt.Widget ): X.Atom;
PROCEDURE  / XmAddWMProtocols ( shell: Xt.Widget;
                                protocols: X.PAAtom;
                                num_protocols: Xt.Cardinal );
PROCEDURE  / XmRemoveWMProtocols ( shell: Xt.Widget;
                                   protocols: X.PAAtom;
                                   num_protocols: Xt.Cardinal );
PROCEDURE  / XmAddWMProtocolCallback ( shell: Xt.Widget;
                                       protocol: X.Atom;
                                       callback: Xt.XtCallbackProc;
                                       closure: Xt.XtPointer );
PROCEDURE  / XmRemoveWMProtocolCallback ( shell: Xt.Widget;
                                          protocol: X.Atom;
                                          callback: Xt.XtCallbackProc;
                                          closure: Xt.XtPointer );
PROCEDURE  / XmActivateWMProtocol ( shell: Xt.Widget;
                                    protocol: X.Atom );
PROCEDURE  / XmDeactivateWMProtocol ( shell: Xt.Widget;
                                      protocol: X.Atom );
PROCEDURE  / XmSetWMProtocolHooks ( shell: Xt.Widget;
                                    protocol: X.Atom;
                                    pre_h: Xt.XtCallbackProc;
                                    pre_c: Xt.XtPointer;
                                    post_h: Xt.XtCallbackProc;
                                    post_c: Xt.XtPointer );

<* END *>

(********    Public Function Declarations    ********)

PROCEDURE XmAddProtocols ( shell: Xt.Widget;
                           property: X.Atom;
                           protocols: X.PAAtom;
                           num_protocols: Xt.Cardinal );

PROCEDURE XmRemoveProtocols ( shell: Xt.Widget;
                              property: X.Atom;
                              protocols: X.PAAtom;
                              num_protocols: Xt.Cardinal );

PROCEDURE XmAddProtocolCallback ( shell: Xt.Widget;
                                  property: X.Atom;
                                  proto_atom: X.Atom;
                                  callback: Xt.XtCallbackProc;
                                  closure: Xt.XtPointer );

PROCEDURE XmRemoveProtocolCallback ( shell: Xt.Widget;
                                     property: X.Atom;
                                     proto_atom: X.Atom;
                                     callback: Xt.XtCallbackProc;
                                     closure: Xt.XtPointer );

PROCEDURE XmActivateProtocol ( shell: Xt.Widget;
                               property: X.Atom;
                               proto_atom: X.Atom );

PROCEDURE XmDeactivateProtocol ( shell: Xt.Widget;
                                 property: X.Atom;
                                 proto_atom: X.Atom );

PROCEDURE XmSetProtocolHooks ( shell: Xt.Widget;
                               property: X.Atom;
                               proto_atom: X.Atom;
                               pre_hook: Xt.XtCallbackProc;
                               pre_closure: Xt.XtPointer;
                               post_hook: Xt.XtCallbackProc;
                               post_closure: Xt.XtPointer );

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/ProtocolsP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

TYPE
  _XmProtocolClassPart = RECORD
    extension: Xt.XtPointer;
  END;

  XmProtocolClassPart = _XmProtocolClassPart;

  _XmProtocolClassRec = RECORD
    object_class  : Xt.ObjectClassPart;
    ext_class     : XmExtClassPart;
    protocol_class: XmProtocolClassPart;
  END;

  XmProtocolClassRec = _XmProtocolClassRec;

  XmProtocolObjectClass = POINTER TO _XmProtocolClassRec;

  _XmProtocolPart = RECORD
    pre_hook : Xt.XtCallbackRec;
    post_hook: Xt.XtCallbackRec;
    callbacks: Xt.XtCallbackList;
    atom     : X.Atom;
    active   : Xt.Boolean;
  END;

  XmProtocolPart = _XmProtocolPart;

  XmProtocolPartPtr = POINTER TO _XmProtocolPart;

  _XmProtocolRec = RECORD
    object  : Xt.ObjectPart;
    ext     : XmExtPart;
    protocol: XmProtocolPart;
  END;

  XmProtocolRec = _XmProtocolRec;

  XmProtocol = POINTER TO _XmProtocolRec;

  XmProtocolList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF XmProtocol;

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE XmIsProtocol ( w: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / XmIsProtocol ( w: Xt.Widget ): Xt.Boolean;

<* END *>

(*  Class record constants  *)

VAR
  xmProtocolClassRec: XmProtocolClassRec;
  xmProtocolObjectClass: Xt.WidgetClass;

TYPE
  _XmProtocolMgrRec = RECORD
    property     : X.Atom;
    protocols    : XmProtocolList;
    num_protocols: Xt.Cardinal;
    max_protocols: Xt.Cardinal;
  END;

  XmProtocolMgrRec = _XmProtocolMgrRec;

  XmProtocolMgr = POINTER TO _XmProtocolMgrRec;

  XmProtocolMgrList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF XmProtocolMgr;

  _XmAllProtocolsMgrRec = RECORD
    protocol_mgrs    : XmProtocolMgrList;
    num_protocol_mgrs: Xt.Cardinal;
    max_protocol_mgrs: Xt.Cardinal;
    shell            : Xt.Widget;
  END;

  XmAllProtocolsMgrRec = _XmAllProtocolsMgrRec;

  XmAllProtocolsMgr = POINTER TO _XmAllProtocolsMgrRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmInstallProtocols ( w: Xt.Widget );

(********    End Private Function Declarations    ********)

(* -------------------------------------------------- *)
(*                     Xm/PushB.h                     *)
(* -------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(***********************************************************************
 *
 * PushButton Widget
 *
 ***********************************************************************)

(*  PushButton Widget  *)

VAR
  xmPushButtonWidgetClass: Xt.WidgetClass;

TYPE
  XmPushButtonWidgetClass = POINTER TO _XmPushButtonClassRec;

  XmPushButtonWidget = POINTER TO _XmPushButtonRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreatePushButton ( parent: Xt.Widget;
                               name: ARRAY OF CHAR;
                               arglist: Xt.ArgList;
                               argcount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* --------------------------------------------------- *)
(*                     Xm/PushBP.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*  PushButton class structure  *)

TYPE
  _XmPushButtonClassPart = RECORD
    extension: Xt.XtPointer;   (* Pointer to extension record *)
  END;

  XmPushButtonClassPart = _XmPushButtonClassPart;

(*  Full class record declaration for PushButton class  *)

  _XmPushButtonClassRec = RECORD
    core_class          : Xt.CoreClassPart;
    primitive_class     : XmPrimitiveClassPart;
    label_class         : XmLabelClassPart;
    pushbutton_class    : XmPushButtonClassPart;
  END;

  XmPushButtonClassRec = _XmPushButtonClassRec;

(*  PushButton instance record  *)

  _XmPushButtonPart = RECORD
    fill_on_arm      : Xt.Boolean;
    show_as_default  : Xt.Dimension;
    arm_color        : Xt.Pixel;
    arm_pixmap       : X.Pixmap;
    activate_callback: Xt.XtCallbackList;
    arm_callback     : Xt.XtCallbackList;
    disarm_callback  : Xt.XtCallbackList;
    armed            : Xt.Boolean;
    unarm_pixmap     : X.Pixmap;
    fill_gc          : Xlib.GC;
    background_gc    : Xlib.GC;
    timer            : Xt.XtIntervalId;
    multiClick       : SHORTCARD; (* KEEP/DISCARD resource *)
    click_count      : SYSTEM.int;
    armTimeStamp     : X.Time;
    compatible       : Xt.Boolean;(* if false it is Motif 1.1 else Motif 1.0 *)
    default_button_shadow_thickness: Xt.Dimension;
    (* New resource - always add it
     * to widgets dimension. *)
  END;

  XmPushButtonPart = _XmPushButtonPart;

(*  Full instance record declaration  *)

  _XmPushButtonRec = RECORD
    core      : Xt.CorePart;
    primitive : XmPrimitivePart;
    label     : XmLabelPart;
    pushbutton: XmPushButtonPart;
  END;

  XmPushButtonRec = _XmPushButtonRec;

VAR
  xmPushButtonClassRec: XmPushButtonClassRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmClearBCompatibility ( pb: Xt.Widget );

(********    End Private Function Declarations    ********)

(* --------------------------------------------------- *)
(*                     Xm/PushBG.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(***********************************************************************
 *
 * PushButton Widget
 *
 ***********************************************************************)

VAR
  xmPushButtonGadgetClass: Xt.WidgetClass;

TYPE
  XmPushButtonGadgetClass = POINTER TO _XmPushButtonGadgetClassRec;

  XmPushButtonGadget = POINTER TO _XmPushButtonGadgetRec;

  XmPushButtonGCacheObject = POINTER TO _XmPushButtonGCacheObjRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreatePushButtonGadget ( parent: Xt.Widget;
                                     name: ARRAY OF CHAR;
                                     arglist: Xt.ArgList;
                                     argcount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/PushBGP.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2.4
 *)

(*******************************************************************
 * The PushButton Gadget Cache Object's class and instance records *
 *******************************************************************)

TYPE
  _XmPushButtonGCacheObjClassPart = RECORD
    foo: SYSTEM.int;
  END;

  XmPushButtonGCacheObjClassPart = _XmPushButtonGCacheObjClassPart;

  _XmPushButtonGCacheObjClassRec = RECORD
    object_class          : Xt.ObjectClassPart;
    ext_class             : XmExtClassPart;
    label_class_cache     : XmLabelGCacheObjClassPart;
    pushbutton_class_cache: XmCascadeButtonGCacheObjClassPart;
  END;

  XmPushButtonGCacheObjClassRec = _XmPushButtonGCacheObjClassRec;

  _XmPushButtonGCacheObjPart = RECORD
    fill_on_arm                    : Xt.Boolean;
    arm_color                      : Xt.Pixel;
    arm_pixmap                     : X.Pixmap;
    unarm_pixmap                   : X.Pixmap;
    multiClick                     : SHORTCARD; (* KEEP/DISCARD resource *)
    default_button_shadow_thickness: Xt.Dimension;
 (* New resource - always add it to gadget's dimension. *)
    fill_gc                        : Xlib.GC;
    background_gc                  : Xlib.GC;
    timer                          : Xt.XtIntervalId;
  END;

  XmPushButtonGCacheObjPart = _XmPushButtonGCacheObjPart;

  XmPushButtonGCache = POINTER TO _XmPushButtonGCacheObjPart;

  _XmPushButtonGCacheObjRec = RECORD
    object          : Xt.ObjectPart;
    ext             : XmExtPart;
    label_cache     : XmLabelGCacheObjPart;
    pushbutton_cache: XmPushButtonGCacheObjPart;
  END;

  XmPushButtonGCacheObjRec = _XmPushButtonGCacheObjRec;

(*  PushButton class structure  *)

  _XmPushButtonGadgetClassPart = RECORD
    extension: Xt.XtPointer;   (* Pointer to extension record *)
  END;

  XmPushButtonGadgetClassPart = _XmPushButtonGadgetClassPart;

(*  Full class record declaration for PushButton class  *)

  _XmPushButtonGadgetClassRec = RECORD
    rect_class      : Xt.RectObjClassPart;
    gadget_class    : XmGadgetClassPart;
    label_class     : XmLabelGadgetClassPart;
    pushbutton_class: XmCascadeButtonGadgetClassPart;
  END;

  XmPushButtonGadgetClassRec = _XmPushButtonGadgetClassRec;

(*  PushButton instance record  *)

  _XmPushButtonGadgetPart = RECORD
    activate_callback: Xt.XtCallbackList;
    arm_callback     : Xt.XtCallbackList;
    disarm_callback  : Xt.XtCallbackList;
    show_as_default  : Xt.Dimension;
    armed            : Xt.Boolean;
    click_count      : SYSTEM.int;
    compatible: Xt.Boolean;         (* if false it is Motif 1.1 else Motif 1.0
                                     * not cached for performance reasons *)
    cache     : XmPushButtonGCache; (* Replace cache instance fields
                                     * with a pointer *)
  END;

  XmPushButtonGadgetPart = _XmPushButtonGadgetPart;

(*  Full instance record declaration  *)

  _XmPushButtonGadgetRec = RECORD
    object    : Xt.ObjectPart;
    rectangle : Xt.RectObjPart;
    gadget    : XmGadgetPart;
    label     : XmLabelGadgetPart;
    pushbutton: XmPushButtonGadgetPart;
  END;

  XmPushButtonGadgetRec = _XmPushButtonGadgetRec;

VAR
  xmPushButtonGadgetClassRec: XmPushButtonGadgetClassRec;
  xmPushButtonGCacheObjClassRec: XmPushButtonGCacheObjClassRec;

(* MACROS *)
(**********)

(*  Macros for cached instance fields  *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE PBG_FillOnArm ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE PBG_ArmColor ( w: Xt.Widget ): Xt.Pixel;
PROCEDURE PBG_FillGc ( w: Xt.Widget ): Xlib.GC;
PROCEDURE PBG_BackgroundGc ( w: Xt.Widget ): Xlib.GC;
PROCEDURE PBG_Timer ( w: Xt.Widget ): Xt.XtIntervalId;
PROCEDURE PBG_ArmPixmap ( w: Xt.Widget ): X.Pixmap;
PROCEDURE PBG_UnarmPixmap ( w: Xt.Widget ): X.Pixmap;
PROCEDURE PBG_MultiClick ( w: Xt.Widget ): SHORTCARD;
PROCEDURE PBG_DefaultButtonShadowThickness ( w: Xt.Widget ): Xt.Dimension;

<* ELSE *>

PROCEDURE  / PBG_FillOnArm ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / PBG_ArmColor ( w: Xt.Widget ): Xt.Pixel;
PROCEDURE  / PBG_FillGc ( w: Xt.Widget ): Xlib.GC;
PROCEDURE  / PBG_BackgroundGc ( w: Xt.Widget ): Xlib.GC;
PROCEDURE  / PBG_Timer ( w: Xt.Widget ): Xt.XtIntervalId;
PROCEDURE  / PBG_ArmPixmap ( w: Xt.Widget ): X.Pixmap;
PROCEDURE  / PBG_UnarmPixmap ( w: Xt.Widget ): X.Pixmap;
PROCEDURE  / PBG_MultiClick ( w: Xt.Widget ): SHORTCARD;
PROCEDURE  / PBG_DefaultButtonShadowThickness ( w: Xt.Widget ): Xt.Dimension;

<* END *>

(*  Macros for uncached instance fields  *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE PBG_ActivateCallback ( w: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE PBG_ArmCallback ( w: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE PBG_DisarmCallback ( w: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE PBG_Armed ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE PBG_ClickCount ( w: Xt.Widget ): SYSTEM.int;
PROCEDURE PBG_Compatible ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE PBG_ShowAsDefault ( w: Xt.Widget ): Xt.Dimension;

<* ELSE *>

PROCEDURE  / PBG_ActivateCallback ( w: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / PBG_ArmCallback ( w: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / PBG_DisarmCallback ( w: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / PBG_Armed ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / PBG_ClickCount ( w: Xt.Widget ): SYSTEM.int;
PROCEDURE  / PBG_Compatible ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / PBG_ShowAsDefault ( w: Xt.Widget ): Xt.Dimension;

<* END *>

(******************************)
(*  Convenience Macros        *)
(******************************)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE PBG_Cache ( w: Xt.Widget ): XmPushButtonGCache;
PROCEDURE PBG_ClassCachePart ( w: Xt.Widget ): XmCacheClassPartPtr;

<* ELSE *>

PROCEDURE  / PBG_Cache ( w: Xt.Widget ): XmPushButtonGCache;
PROCEDURE  / PBG_ClassCachePart ( w: Xt.Widget ): XmCacheClassPartPtr;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmClearBGCompatibility ( pbg: Xt.Widget );

(********    End Private Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/RepType.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

CONST
  XmREP_TYPE_INVALID = 1FFFH;

TYPE
  XmRepTypeId = SYSTEM.CARD16;

  _XmRepTypeEntryValue = SHORTCARD;

  _XmRepTypeEntryValueList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF SHORTCARD;

  XmRepTypeEntryRec = RECORD
    rep_type_name    : Xt.String;
    value_names      : Xt.StringList;
    values           : _XmRepTypeEntryValueList;
    num_values       : SHORTCARD;
    reverse_installed: Xt.Boolean;
    rep_type_id      : XmRepTypeId;
  END;

  XmRepTypeEntry = POINTER TO XmRepTypeEntryRec;

  XmRepTypeListRec = RECORD
    rep_type_name    : Xt.String;
    value_names      : Xt.StringList;
    values           : _XmRepTypeEntryValueList;
    num_values       : SHORTCARD;
    reverse_installed: Xt.Boolean;
    rep_type_id      : XmRepTypeId;
  END;

  XmRepTypeList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF XmRepTypeListRec;

(********    Public Function Declarations    ********)

PROCEDURE XmRepTypeRegister ( rep_type: Xt.String;
                              value_names: Xt.StringList;
                              values: _XmRepTypeEntryValueList;
                              num_values: SHORTCARD ): XmRepTypeId;

PROCEDURE XmRepTypeAddReverse ( rep_type_id: XmRepTypeId );

PROCEDURE XmRepTypeValidValue ( rep_type_id: XmRepTypeId;
                                test_value: _XmRepTypeEntryValue;
                                enable_default_warning: Xt.Widget ): Xt.Boolean;

PROCEDURE XmRepTypeGetRegistered (  ): XmRepTypeList;

PROCEDURE XmRepTypeGetRecord ( rep_type_id: XmRepTypeId ): XmRepTypeEntry;

PROCEDURE XmRepTypeGetId ( rep_type: Xt.String ): XmRepTypeId;

PROCEDURE XmRepTypeGetNameList ( rep_type_id: XmRepTypeId;
                                 use_uppercase_format: Xt.Boolean ): Xt.StringList;

PROCEDURE XmRepTypeInstallTearOffModelConverter (  );

(********    End Public Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/RCUtilsP.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(********    Private Function Declarations    ********)

PROCEDURE _XmRCGetKidGeo ( wid: Xt.Widget;
                           instigator: Xt.Widget;
                           VAR request: Xt.XtWidgetGeometry;
                           uniform_border: SYSTEM.int;
                           border: Xt.Dimension;
                           uniform_width_margins: SYSTEM.int;
                           uniform_height_margins: SYSTEM.int;
                           help: Xt.Widget; toc: Xt.Widget;
                           geo_type: SYSTEM.int ): XmRCKidGeometry;

PROCEDURE _XmRCSetKidGeo ( kg: XmRCKidGeometry; instigator: Xt.Widget );

(********    End Private Function Declarations    ********)

(* -------------------------------------------------- *)
(*                     Xm/SashP.h                     *)
(* -------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*
 *  SashP.def - Private definitions for Sash widget (Used by VPane Widget)
 *)

(*****************************************************************************
 *
 * Sash Widget Private Data
 *
 *****************************************************************************)

(*  New fields for the Sash widget class record  *)

TYPE
  XmSashClassPart = RECORD
    extension: Xt.XtPointer;   (*  Pointer to extension record  *)
  END;

(*  Full Class record declaration  *)

  _XmSashClassRec = RECORD
    core_class     : Xt.CoreClassPart;
    primitive_class: XmPrimitiveClassPart;
    sash_class     : XmSashClassPart;
  END;

  XmSashClassRec = _XmSashClassRec;

  XmSashWidgetClass = POINTER TO _XmSashClassRec;

(*  New fields for the Sash widget record  *)

  _XmSashPart = RECORD
    sash_action: Xt.XtCallbackList;
    has_focus  : Xt.Boolean;
  END;

  XmSashPart = _XmSashPart;

(*****************************************************************************
 *
 * Full instance record declaration
 *
 *****************************************************************************)

  _XmSashRec = RECORD
    core     : Xt.CorePart;
    primitive: XmPrimitivePart;
    sash     : XmSashPart;
  END;

  XmSashRec = _XmSashRec;

  XmSashWidget = POINTER TO _XmSashRec;

  _SashCallDataRec = RECORD
    event     : Xlib.PtrXEvent; (* the event causing the SashAction *)
    params    : Xt.StringList;    (* the TranslationTable params *)
    num_params: Xt.Cardinal;    (* count of params *)
  END;

  SashCallDataRec = _SashCallDataRec;

  SashCallData = POINTER TO _SashCallDataRec;

(*  Class Record Constant  *)

VAR
  xmSashClassRec: XmSashClassRec;
  xmSashWidgetClass: Xt.WidgetClass;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* -------------------------------------------------- *)
(*                     Xm/Scale.h                     *)
(* -------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(*  Class record constants  *)

VAR
  xmScaleWidgetClass: Xt.WidgetClass;

TYPE
  XmScaleWidgetClass = POINTER TO _XmScaleClassRec;

  XmScaleWidget = POINTER TO _XmScaleRec;

(********    Public Function Declarations    ********)

PROCEDURE XmScaleSetValue ( w: Xt.Widget;
                            value: SYSTEM.int );

PROCEDURE XmScaleGetValue ( w: Xt.Widget;
                            VAR value: SYSTEM.int );

PROCEDURE XmCreateScale ( parent: Xt.Widget;
                          name: ARRAY OF CHAR;
                          arglist: Xt.ArgList;
                          argcount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* --------------------------------------------------- *)
(*                     Xm/ScaleP.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*  Constraint part record for Scale widget  *)

TYPE
  _XmScaleConstraintPart = RECORD
    unused: CHAR;
  END;

  XmScaleConstraintPart = _XmScaleConstraintPart;

  XmScaleConstraint = POINTER TO _XmScaleConstraintPart;

(*  New fields for the Scale widget class record   *)

  _XmScaleClassPart = RECORD
    extension: Xt.XtPointer;   (*  Pointer to extension record  *)
  END;

  XmScaleClassPart = _XmScaleClassPart;

(*  Full class record declaration  *)

  _XmScaleClassRec = RECORD
    core_class      : Xt.CoreClassPart;
    composite_class : Xt.CompositeClassPart;
    constraint_class: Xt.ConstraintClassPart;
    manager_class   : XmManagerClassPart;
    scale_class     : XmScaleClassPart;
  END;

  XmScaleClassRec = _XmScaleClassRec;

(*  New fields for the Scale widget record  *)

  _XmScalePart = RECORD
    value                 : SYSTEM.int;
    maximum               : SYSTEM.int;
    minimum               : SYSTEM.int;
    orientation           : SHORTCARD;
    processing_direction  : SHORTCARD;
    title                 : XmString;
    font_list             : XmFontList;
    font_struct           : Xlib.PtrXFontStruct;
    show_value            : Xt.Boolean;
    decimal_points        : SYSTEM.INT16;
    scale_width           : Xt.Dimension;
    scale_height          : Xt.Dimension;
    highlight_thickness   : Xt.Dimension;
    highlight_on_enter    : Xt.Boolean;
    drag_callback         : Xt.XtCallbackList;
    value_changed_callback: Xt.XtCallbackList;
    last_value            : SYSTEM.int;
    slider_size           : SYSTEM.int;
    foreground_GC         : Xlib.GC;
    show_value_x          : SYSTEM.int;
    show_value_y          : SYSTEM.int;
    show_value_width      : SYSTEM.int;
    show_value_height     : SYSTEM.int;
    scale_multiple        : SYSTEM.int;
  END;

  XmScalePart = _XmScalePart;

(****************************************************************
 *
 * Full instance record declaration
 *
 ****************************************************************)

  _XmScaleRec = RECORD
    core      : Xt.CorePart;
    composite : Xt.CompositePart;
    constraint: Xt.ConstraintPart;
    manager   : XmManagerPart;
    scale     : XmScalePart;
  END;

  XmScaleRec = _XmScaleRec;

VAR
  xmScaleClassRec: XmScaleClassRec;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/Separator.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2
 *)

(*   Separator Widget   *)

VAR
  xmSeparatorWidgetClass: Xt.WidgetClass;

TYPE
  XmSeparatorWidgetClass = POINTER TO _XmSeparatorClassRec;

  XmSeparatorWidget = POINTER TO _XmSeparatorRec;

(********    Public Function Declarations    ********)

PROCEDURE XmCreateSeparator ( parent: Xt.Widget;
                              name: ARRAY OF CHAR;
                              arglist: Xt.ArgList;
                              argcount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/SeparatorP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(*  Separator class structure  *)

TYPE
  _XmSeparatorClassPart = RECORD
    extension: Xt.XtPointer;   (* Pointer to extension record *)
  END;

  XmSeparatorClassPart = _XmSeparatorClassPart;

(*  Full class record declaration for Separator class  *)

  _XmSeparatorClassRec = RECORD
    core_class     : Xt.CoreClassPart;
    primitive_class: XmPrimitiveClassPart;
    separator_class: XmScrollBarClassPart;
  END;

  XmSeparatorClassRec = _XmSeparatorClassRec;

(*  The Separator instance record  *)

  XmSeparatorPart = RECORD
    margin        : Xt.Dimension;
    orientation   : SHORTCARD;
    separator_type: SHORTCARD;
    separator_GC  : Xlib.GC;
  END;

  _XmSeparatorPart = XmSeparatorGCacheObjPart;

(*  Full instance record declaration  *)

  _XmSeparatorRec = RECORD
    core     : Xt.CorePart;
    primitive: XmPrimitivePart;
    separator: XmSeparatorPart;
  END;

  XmSeparatorRec = _XmSeparatorRec;

VAR
  xmSeparatorClassRec: XmSeparatorClassRec;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* ------------------------------------------------- *)
(*                     Xm/Text.h                     *)
(* ------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(* -------------- *
 *   type defines *
 * -------------- *)

TYPE
  XmTextSource = POINTER TO _XmTextSourceRec;

  XmTextWidgetClass = POINTER TO _XmTextClassRec;

  XmTextWidget = POINTER TO _XmTextRec;

(* -------------- *
 * extern class   *
 * -------------- *)

VAR
  xmTextWidgetClass: Xt.WidgetClass;

(* ----------------------------------- *
 *   text widget public functions      *
 * ----------------------------------- *)

(********    Public Function Declarations    ********)

PROCEDURE XmTextSetHighlight ( w: Xt.Widget;
                               left: XmTextPosition;
                               right: XmTextPosition;
                               mode: XmHighlightMode );

PROCEDURE XmCreateScrolledText ( parent: Xt.Widget;
                                 name: ARRAY OF CHAR;
                                 arglist: Xt.ArgList;
                                 argcount: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmCreateText ( parent: Xt.Widget;
                         name: ARRAY OF CHAR;
                         arglist: Xt.ArgList;
                         argcount: Xt.Cardinal ): Xt.Widget;

PROCEDURE XmTextGetSubstring ( widget: Xt.Widget;
                               start: XmTextPosition;
                               num_chars: SYSTEM.int;
                               buf_size: SYSTEM.int;
                               buffer: Xt.String ): SYSTEM.int;

PROCEDURE XmTextGetSubstringWcs ( widget: Xt.Widget;
                                  start: XmTextPosition;
                                  num_chars: SYSTEM.int;
                                  buf_size: SYSTEM.int;
                                  buffer: Xlib.Ptrwchar_t ): SYSTEM.int;

PROCEDURE XmTextGetString ( widget: Xt.Widget ): Xt.String;

PROCEDURE XmTextGetStringWcs ( widget: Xt.Widget ): Xlib.Ptrwchar_t;

PROCEDURE XmTextGetLastPosition ( widget: Xt.Widget ): XmTextPosition;

PROCEDURE XmTextSetString ( widget: Xt.Widget; value: ARRAY OF CHAR );

PROCEDURE XmTextSetStringWcs ( widget: Xt.Widget;
                               wc_value: Xlib.Ptrwchar_t );

PROCEDURE XmTextReplace ( widget: Xt.Widget;
                          frompos: XmTextPosition;
                          topos: XmTextPosition;
                          value: ARRAY OF CHAR );

PROCEDURE XmTextReplaceWcs ( widget: Xt.Widget;
                             frompos: XmTextPosition;
                             topos: XmTextPosition;
                             value: Xlib.Ptrwchar_t );

PROCEDURE XmTextInsert ( widget: Xt.Widget;
                         position: XmTextPosition;
                         value: ARRAY OF CHAR );

PROCEDURE XmTextInsertWcs ( widget: Xt.Widget;
                            position: XmTextPosition;
                            wc_value: Xlib.Ptrwchar_t );

PROCEDURE XmTextSetAddMode ( widget: Xt.Widget;
                             state: Xt.Boolean );

PROCEDURE XmTextGetAddMode ( widget: Xt.Widget ): Xt.Boolean;

PROCEDURE XmTextGetEditable ( widget: Xt.Widget ): Xt.Boolean;

PROCEDURE XmTextSetEditable ( widget: Xt.Widget;
                              editable: Xt.Boolean );

PROCEDURE XmTextGetMaxLength ( widget: Xt.Widget ): SYSTEM.int;

PROCEDURE XmTextSetMaxLength ( widget: Xt.Widget;
                               max_length: SYSTEM.int );

PROCEDURE XmTextGetTopCharacter ( widget: Xt.Widget ): XmTextPosition;

CONST
  XmTextGetTopPosition = XmTextGetTopCharacter;

PROCEDURE XmTextSetTopCharacter ( widget: Xt.Widget;
                                  top_character: XmTextPosition );

CONST
  XmTextSetTopPosition = XmTextSetTopCharacter;

PROCEDURE XmTextGetCursorPosition ( widget: Xt.Widget ): XmTextPosition;

PROCEDURE XmTextGetInsertionPosition ( widget: Xt.Widget ): XmTextPosition;

PROCEDURE XmTextSetInsertionPosition ( widget: Xt.Widget;
                                       position: XmTextPosition );

PROCEDURE XmTextSetCursorPosition ( widget: Xt.Widget;
                                    position: XmTextPosition );

PROCEDURE XmTextRemove ( widget: Xt.Widget ): Xt.Boolean;

PROCEDURE XmTextCopy ( widget: Xt.Widget;
                       copy_time: X.Time ): Xt.Boolean;

PROCEDURE XmTextCut ( widget: Xt.Widget;
                      cut_time: X.Time ): Xt.Boolean;

PROCEDURE XmTextPaste ( widget: Xt.Widget ): Xt.Boolean;

PROCEDURE XmTextGetSelection ( widget: Xt.Widget ): Xt.String;

PROCEDURE XmTextGetSelectionWcs ( widget: Xt.Widget ): Xlib.Ptrwchar_t;

PROCEDURE XmTextSetSelection ( widget: Xt.Widget;
                               first: XmTextPosition;
                               last: XmTextPosition;
                               set_time: X.Time );

PROCEDURE XmTextClearSelection ( widget: Xt.Widget;
                                 clear_time: X.Time );

PROCEDURE XmTextGetSelectionPosition ( widget: Xt.Widget;
                                       VAR left: XmTextPosition;
                                       VAR right:XmTextPosition ): Xt.Boolean;

PROCEDURE XmTextXYToPos ( widget: Xt.Widget;
                          x: Xt.Position;
                          y: Xt.Position ): XmTextPosition;

PROCEDURE XmTextPosToXY ( widget: Xt.Widget;
                          position: XmTextPosition;
                          VAR x: SYSTEM.INT16;
                          VAR y: SYSTEM.INT16 ): Xt.Boolean;

PROCEDURE XmTextGetSource ( widget: Xt.Widget ): XmTextSource;

PROCEDURE XmTextSetSource ( widget: Xt.Widget;
                            source: XmTextSource;
                            top_character: XmTextPosition;
                            cursor_position: XmTextPosition );

PROCEDURE XmTextShowPosition ( widget: Xt.Widget;
                               position: XmTextPosition );

PROCEDURE XmTextScroll ( widget: Xt.Widget; n: SYSTEM.int );

PROCEDURE XmTextGetBaseline ( widget: Xt.Widget ): SYSTEM.int;

PROCEDURE XmTextDisableRedisplay ( widget: Xt.Widget );

PROCEDURE XmTextEnableRedisplay ( widget: Xt.Widget );

PROCEDURE XmTextFindString ( w: Xt.Widget;
                             start: XmTextPosition;
                             search_string: ARRAY OF CHAR;
                             direction: XmTextDirection;
                             VAR position: XmTextPosition ): Xt.Boolean;

PROCEDURE XmTextFindStringWcs ( w: Xt.Widget;
                                start: XmTextPosition;
                                wc_string: Xlib.Ptrwchar_t;
                                direction: XmTextDirection;
                                VAR position: XmTextPosition ): Xt.Boolean;

(********    End Public Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/TextOutP.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2.2
 *)

(****************************************************************
 *
 * Definitions for modules implementing and using text output routines.
 *
 ****************************************************************)

TYPE
  _LineTableExtraRec = RECORD
    width        : Xt.Dimension;
    wrappedbychar: Xt.Boolean;
  END;

  LineTableExtraRec = _LineTableExtraRec;

  LineTableExtra = POINTER TO _LineTableExtraRec;

  LineTableExtrasList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF LineTableExtra;

(*
 * output.c  (part of stext)
 *)

  LineNum = CARDINAL;

(*  For when Booleans aren't obvious enough.  *)

CONST
  on = 0;
  off = 1;

TYPE
  OnOrOff = SYSTEM.int;

(*
 * Return the line number containing the given position.  If text currently
 * knows of no line containing that position, returns NOLINE.
 *)

CONST
  NOLINE = 30000;

(*
 * These next define the types of the routines that output is required
 * to export for use by text and by input.
 *)

TYPE
  _OutputDataRec = RECORD
    fontlist         : XmFontList; (* Fontlist for text. *)
    blinkrate        : CARDINAL;
    wordwrap         : Xt.Boolean; (* Whether to wordwrap. *)
    cursor_position_visible: Xt.Boolean;
    autoshowinsertpoint: Xt.Boolean;
    hasfocus         : Xt.Boolean;
    has_rect         : Xt.Boolean;
    handlingexposures: Xt.Boolean; (* TRUE if in the midst of expose events. *)
    exposevscroll    : Xt.Boolean; (* Non-zero if we expect expose events to be
                                    * off vertically. *)
    exposehscroll    : Xt.Boolean; (* Non-zero if we expect expose events to be
                                    * off horizontally. *)
    resizewidth      : Xt.Boolean;
    resizeheight     : Xt.Boolean;
    scrollvertical   : Xt.Boolean;
    scrollhorizontal : Xt.Boolean;
    scrollleftside   : Xt.Boolean;
    scrolltopside    : Xt.Boolean;
    ignorevbar       : Xt.Boolean; (* Whether to ignore callbacks from vbar. *)
    ignorehbar       : Xt.Boolean; (* Whether to ignore callbacks from hbar. *)
    cursor_on        :SYSTEM.INT16;(* Whether IBeam cursor is visible. *)
    refresh_ibeam_off: Xt.Boolean; (* Indicates whether area under IBeam needs
                                    * to be re-captured *)
    suspend_hoffset  : Xt.Boolean;(* temporarily suspend horizontal scrolling*)
    use_fontset      : Xt.Boolean; (* True if font to be used is fontset (and
                                    * thus need X11R5 Xmb* routines to draw *)
    have_inverted_image_gc:Xt.Boolean;(* fg/bg of image gc have been swapped;
                                       * on == True, off == False *)
    blinkstate       : OnOrOff;
    insertx          : Xt.Position;
    inserty          : Xt.Position;
    number_lines     : SYSTEM.int; (* Number of lines that fit in the window.*)
    leftmargin       : SYSTEM.int;
    rightmargin      : SYSTEM.int;
    topmargin        : SYSTEM.int;
    bottommargin     : SYSTEM.int;
    scrollwidth      : SYSTEM.int; (* Total width of text we have to display.*)
    vsliderSize      : SYSTEM.int; (* How big the thumb is in the vbar. *)
    hoffset          : SYSTEM.int; (* How much we've scrolled off the left. *)
    averagecharwidth : SYSTEM.int; (* Number of pixels for an "average" char.*)
    tabwidth         : SYSTEM.int; (* Number of pixels for a tab. *)
    columns          : SYSTEM.INT16;
    rows             : SYSTEM.INT16;
    lineheight       : Xt.Dimension;(* Number of pixels per line. *)
    minwidth         : Xt.Dimension;
    minheight        : Xt.Dimension;
    prevW            : Xt.Dimension;
    prevH            : Xt.Dimension;
    cursorwidth      : Xt.Dimension;
    cursorheight     : Xt.Dimension;
    font_ascent      : Xt.Dimension;(* ascent of the font[set] *)
    font_descent     : Xt.Dimension;(* descent of the font[set] *)
    timerid          : Xt.XtIntervalId;
    cursor           : X.Pixmap;   (* Pixmap for IBeam cursor stencil. *)
    add_mode_cursor  : X.Pixmap;   (* Pixmap to use for add mode cursor. *)
    ibeam_off        : X.Pixmap;   (* Pixmap for area under the IBeam. *)
    stipple_tile     : X.Pixmap;   (* stiiple for add mode cursor. *)
    gc               : Xlib.GC;
    imagegc          : Xlib.GC;
    vbar             : Xt.Widget;
    hbar             : Xt.Widget;
    font             : Xlib.PtrXFontStruct;(*font used when NULL font is set.*)
 (* New for 1.2 *)
    save_gc          : Xlib.GC;    (* GC for saving/resotring under IBeam *)
    columns_set      : SYSTEM.INT16;
    rows_set         : SYSTEM.INT16;(* history of previously set dimensions *)
  END;

  OutputDataRec = _OutputDataRec;

  OutputData = POINTER TO _OutputDataRec;

(*
 * Create a new instance of an output object.  This is expected to fill in
 * info about innerwidget and output in the widget record.
 *)

  OutputCreateProc = PROCEDURE ( Xt.Widget,
                                 Xt.ArgList,
                               	 Xt.Cardinal );

(*
 * Given an (x,y) coordinate, return the closest corresponding position. (For
 * use by input; text shouldn't ever need to know.)
 *)
  XYToPosProc = PROCEDURE ( XmTextWidget,
                            Xt.Position,    (* These are relative to the *)
                            Xt.Position ):
                            XmTextPosition; (* innerwindow returned above. *)
(*
 * Return the (x,y) coordinate corresponing to the given position.  If this
 * returns FALSE, then the given position isn't being displayed.
 *)

  PosToXYProc = PROCEDURE ( XmTextWidget,
                            XmTextPosition,
                            VAR SYSTEM.INT16, (* These are relative to the *)
                            VAR SYSTEM.INT16 ):
                            Xt.Boolean;       (* innerwindow returned above. *)

(*
 * Measures the extent of a line.  Given the line number and starting position
 * of a line, returns the starting position of the next line.  Also returns
 * any extra information that the output module may want to associate with
 * this line for future reference.  (In particular, it will want to associate
 * a vertical coordinate for this line.)  This routine should return FALSE if
 * it decides that this line will not fit in the window.  FALSE should never
 * be returned if the line number is zero.  Output may assume that the line
 * table for all preceeding lines have already been set.  In particular, when
 * this routine will return FALSE, then output knows that the entire linetable
 * has been calculated; that is a good time for it to look over the linetable
 * and decide if it wants to do something obnoxious like resize the window.
 *
 * A possible value to put in nextpos is PASTENDPOS.  This indicates that the
 * current line contains the end of the text in the source.
 *
 * nextpos may be NULL.  If it is, then this indicates that we only want to
 * know if the line will fit on the window.  The caller already has its own
 * idea where the next line will start if it does fit.  (If nextpos is NULL,
 * then no extra information should be generated, and the 'extra' parameter
 * should be ignored.)
 *)

CONST
  PASTENDPOS = 2147483647; (* Biggest number that can fit in long *)

TYPE
  MeasureLineProc = PROCEDURE ( XmTextWidget,
                                LineNum,
                                XmTextPosition,
                                VAR XmTextPosition,
                                LineTableExtrasList ): Xt.Boolean;

(*
 * Draw some text within a line.  The output finds out information about the
 * line by calling the line table routines.
 *
 * %%% Document special cases (like lines containing PASTENDPOS).
 *)

  DrawProc = PROCEDURE ( XmTextWidget,
                         LineNum,
                         XmTextPosition,
                         XmTextPosition,
                         XmHighlightMode );

(*
 * Output should draw or erase an insertion point at the given position.
 *)

  DrawInsertionPointProc = PROCEDURE ( XmTextWidget,
                                       XmTextPosition,
                                       OnOrOff );

(*
 * Output should ensure that the given position is visible (e.g., not scrolled
 * off horizontally).
 *)

  MakePositionVisibleProc = PROCEDURE ( XmTextWidget,
                                        XmTextPosition );

(* Text would like to move some lines around on the screen.  It would like to
 * move lines fromline through toline (inclusive) to now start at line
 * destline.  If output can perform this move by means of a XCopyArea or
 * similar simple call, it does so and returns TRUE; otherwise, it will return
 * FALSE.  If TRUE, output should modify affected values in the
 * "extra" entries in the linetable, because after returning text will go ahead
 * and move linetable entries around.
 *)

  MoveLinesProc = PROCEDURE ( XmTextWidget,
                              LineNum,
                              LineNum,
                              LineNum ): Xt.Boolean;

(*
 * Inform output of invalidated positions.
 *)

  InvalidateProc = PROCEDURE ( XmTextWidget,
                               XmTextPosition,
                               XmTextPosition,
                               LONGINT );
(*
 * Get preferred size of text widget based on the row and column
 * resources multiplied by font attributes as well as adding the
 * margin resource values to the computed size.
 *)

  GetPreferredSizeProc = PROCEDURE ( Xt.Widget,
                                     VAR Xt.Dimension,
                                     VAR Xt.Dimension );

(*
 * Get values out of the output object.
 *)

  GetValuesProc = PROCEDURE ( Xt.Widget,
                              Xt.ArgList,
                              Xt.Cardinal );

(*
 * Set values in the output object.
 *)

  SetValuesProc = PROCEDURE ( Xt.Widget,
                              Xt.Widget,
                              Xt.Widget,
                              Xt.ArgList,
                              VAR Xt.Cardinal ): Xt.Boolean;

  _OutputRec = RECORD
    data               : OutputData; (* Output-specific data; opaque type. *)
    XYToPos            : XYToPosProc;
    PosToXY            : PosToXYProc;
    MeasureLine        : MeasureLineProc;
    Draw               : DrawProc;
    DrawInsertionPoint : DrawInsertionPointProc;
    MakePositionVisible: MakePositionVisibleProc;
    MoveLines          : MoveLinesProc;
    Invalidate         : InvalidateProc;
    GetPreferredSize   : GetPreferredSizeProc;
    GetValues          : GetValuesProc;
    SetValues          : SetValuesProc;
    realize            : XmRealizeOutProc;
    destroy            : Xt.XtWidgetProc;
    resize             : XmResizeFlagProc;
    expose             : Xt.XtExposeProc;
  END;

  OutputRec = _OutputRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmTextFreeContextData ( w: Xt.Widget;
                                   clientData: Xt.XtPointer;
                                   callData: Xt.XtPointer );

PROCEDURE _XmTextResetClipOrigin ( tw: XmTextWidget;
                                   position: XmTextPosition;
                                   clip_mask_reset: Xt.Boolean );

PROCEDURE _XmTextAdjustGC ( tw: XmTextWidget );

PROCEDURE _XmTextShouldWordWrap ( widget: XmTextWidget ): Xt.Boolean;

PROCEDURE _XmTextScrollable ( widget: XmTextWidget ): Xt.Boolean;

PROCEDURE _XmTextFindLineEnd ( widget: XmTextWidget;
                               position: XmTextPosition;
                               VAR extra: LineTableExtra ): XmTextPosition;

PROCEDURE _XmTextOutputGetSecResData ( VAR secResDataRtn: XmSecondaryResourceData );

PROCEDURE _XmTextGetNumberLines ( widget: XmTextWidget ): SYSTEM.int;

PROCEDURE _XmTextMovingCursorPosition ( tw: XmTextWidget;
                                        position: XmTextPosition );

PROCEDURE _XmTextDrawDestination ( widget: XmTextWidget );

PROCEDURE _XmTextClearDestination ( widget: XmTextWidget;
                                    ignore_sens: Xt.Boolean );

PROCEDURE _XmTextDestinationVisible ( w: Xt.Widget;
                                      turn_on: Xt.Boolean );

PROCEDURE _XmTextChangeBlinkBehavior ( widget: XmTextWidget;
                                       newvalue: Xt.Boolean );

PROCEDURE _XmTextOutputCreate ( wid: Xt.Widget;
                                args: Xt.ArgList;
                                num_args: Xt.Cardinal );

PROCEDURE _XmTextGetBaselines ( widget: Xt.Widget;
                                baselines: Xt.DimensionList;
                                VAR line_count: SYSTEM.int ): Xt.Boolean;

PROCEDURE _XmTextGetDisplayRect ( w: Xt.Widget;
                                  VAR display_rect: Xlib.XRectangle ): Xt.Boolean;

PROCEDURE _XmTextMarginsProc ( w: Xt.Widget;
                               VAR margins_rec: XmBaselineMargins );

PROCEDURE _XmTextChangeHOffset ( widget: XmTextWidget;
                                 length: SYSTEM.int );

PROCEDURE _XmTextToggleCursorGC ( widget: Xt.Widget );

(********    End Private Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/TextStrSoP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(****************************************************************
 *
 * Definitions for use by sources and source users.
 *
 ****************************************************************)

CONST
  EditDone = 0;
  EditError = 1;
  EditReject = 2;

TYPE
  XmTextStatus = SYSTEM.int;

CONST
  XmsdLeft = 0;
  XmsdRight = 1;

TYPE
  XmTextScanDirection = SYSTEM.int;

  XmTextWidgetList = POINTER TO ARRAY [0..X.MAX_STUP_ARR] OF XmTextWidget;

  _XmSourceDataRec = RECORD
    source    : XmTextSource;    (* Backpointer to source record. *)
    widgets   : XmTextWidgetList;(* Array of widgets displaying this source.*)
    left      : XmTextPosition;
    right     : XmTextPosition;  (* Left and right extents of selection. *)
    ptr       : Xt.String;       (* Actual string data. *)
    value     : Xt.String;       (* Value of the string data. *)
    gap_start : Xt.String;       (* Gapped buffer start pointer *)
    gap_end   : Xt.String;       (* Gapped buffer end pointer *)
    PSWC_NWLN : Xt.String;       (* Holder for char*,short*,int* rep of NWLN *)
    length    : SYSTEM.int;      (* Number of chars of data. *)
    maxlength : SYSTEM.int;      (* Space allocated. *)
    old_length: SYSTEM.int;      (* Space allocated for value pointer. *)
    numwidgets: SYSTEM.int;      (* Number of entries in above. *)
    maxallowed: SYSTEM.int;      (* The user is not allowed to grow source
      	      	      	      	  * to a size greater than this. *)
    prim_time : X.Time;          (* time of primary selection *)
    hasselection: Xt.Boolean;    (* Whether we own the selection. *)
    editable  : Xt.Boolean;      (* Whether we allow any edits. *)
  END;

  XmSourceDataRec = _XmSourceDataRec;

  XmSourceData = POINTER TO _XmSourceDataRec;

  AddWidgetProc = PROCEDURE ( XmTextSource,
                              XmTextWidget );

  CountLinesProc = PROCEDURE ( XmTextSource,
                               XmTextPosition,
                               LONGCARD ): SYSTEM.int;

  RemoveWidgetProc = PROCEDURE ( XmTextSource,
                                 XmTextWidget );

  ReadProc = PROCEDURE ( XmTextSource,
                         XmTextPosition, (* starting position  *)
                       	 XmTextPosition, (* The last position we're interested
                                            in. Don't return info about
                                            any later positions. *)
			 XmTextBlock ): XmTextPosition;

(*  RETURN: text read in  *)

  ReplaceProc = PROCEDURE ( XmTextWidget,
                            VAR Xlib.XEvent,
                            VAR XmTextPosition,
                            VAR XmTextPosition,
                            XmTextBlock,
                            Xt.Boolean ): XmTextStatus;

  ScanProc = PROCEDURE ( XmTextSource,
                         XmTextPosition,
                         XmTextScanType,
                       	 XmTextScanDirection,(* Either XmsdLeft or XmsdRight *)
                       	 SYSTEM.int,
                         Xt.Boolean ): XmTextPosition;

  GetSelectionProc = PROCEDURE ( XmTextSource,
                                 VAR XmTextPosition,
                                 VAR XmTextPosition ): Xt.Boolean;

  SetSelectionProc = PROCEDURE ( XmTextSource,
                                 XmTextPosition,
                                 XmTextPosition,
                               	 X.Time );

  _XmTextSourceRec = RECORD
    data        : XmSourceData;   (*  Source-defined data (opaque type).  *)
    AddWidget   : AddWidgetProc;
    CountLines  : CountLinesProc;
    RemoveWidget: RemoveWidgetProc;
    ReadSource  : ReadProc;
    Replace     : ReplaceProc;
    Scan        : ScanProc;
    GetSelection: GetSelectionProc;
    SetSelection: SetSelectionProc;
  END;

  XmTextSourceRec = _XmTextSourceRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmStringSourceGetString ( tw: XmTextWidget;
                                     from: XmTextPosition;
                                     to: XmTextPosition;
                                     want_wchar: Xt.Boolean ): Xt.String;

PROCEDURE _XmTextFindStringBackwards ( w: Xt.Widget;
                                       start: XmTextPosition;
                                       search_string: ARRAY OF CHAR;
                                       VAR position: XmTextPosition ): Xt.Boolean;

PROCEDURE _XmTextFindStringForwards ( w: Xt.Widget;
                                      start: XmTextPosition;
                                      search_string: ARRAY OF CHAR;
                                      VAR position: XmTextPosition ): Xt.Boolean;

PROCEDURE _XmStringSourceFindString ( w: Xt.Widget;
                                      start: XmTextPosition;
                                      string: ARRAY OF CHAR;
                                      VAR position: XmTextPosition ): Xt.Boolean;

PROCEDURE _XmStringSourceSetGappedBuffer ( data: XmSourceData;
                                           position: XmTextPosition );

PROCEDURE _XmTextModifyVerify ( initiator: XmTextWidget;
                                VAR event: Xlib.XEvent;
                                VAR start: XmTextPosition;
                                VAR end: XmTextPosition;
                                VAR cursorPos: XmTextPosition;
                                block: XmTextBlock;
                                newblock: XmTextBlock;
                                freeBlock: Xt.String ): Xt.Boolean;

PROCEDURE _XmStringSourceCreate ( value: ARRAY OF CHAR;
                                  is_wchar: Xt.Boolean ): XmTextSource;

PROCEDURE _XmStringSourceDestroy ( source: XmTextSource );

PROCEDURE _XmStringSourceGetValue ( source: XmTextSource;
                                    want_wchar: Xt.Boolean ): Xt.String;

PROCEDURE _XmStringSourceSetValue ( widget: XmTextWidget;
                                    value: ARRAY OF CHAR );

PROCEDURE _XmStringSourceHasSelection ( source: XmTextSource ): Xt.Boolean;

PROCEDURE _XmStringSourceGetEditable ( source: XmTextSource ): Xt.Boolean;

PROCEDURE _XmStringSourceSetEditable ( source: XmTextSource;
                                       editable: Xt.Boolean );

PROCEDURE _XmStringSourceGetMaxLength ( source: XmTextSource ): SYSTEM.int;

PROCEDURE _XmStringSourceSetMaxLength ( source: XmTextSource;
                                        max: SYSTEM.int );

PROCEDURE _XmTextValueChanged ( initiator: XmTextWidget;
                                VAR event: Xlib.XEvent );

(********    End Private Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/TextInP.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(****************************************************************
 *
 * Definitions for modules implementing text input modules.
 *
 ****************************************************************)

TYPE
  SelectionHint = RECORD
    x: SYSTEM.int;
    y: SYSTEM.int;
  END;

  _InputDataRec = RECORD
    widget : XmTextWidget;       (* Back-pointer to widget record. *)
    sarray : XmTextScanTypeList; (* Description of what to cycle through on
      	      	      	      	  * selections. *)
    sarraycount : SYSTEM.int;    (* Number of elements in above. *)
    new_sel_length : SYSTEM.int; (* New selection length for selection moves.*)
    threshold   : SYSTEM.int;    (* number of pixels crossed -> drag *)
    selectionHint: SelectionHint;(* saved coords of button down *)
    Sel2Hint    : SelectionHint; (* saved the coords of button down *)
    select_id   : Xt.XtIntervalId;
    stype       : XmTextScanType;(* Current selection type. *)
    extendDir   : XmTextScanDirection;
    Sel2ExtendDir  : XmTextScanDirection;
    origLeft    : XmTextPosition;
    origRight   : XmTextPosition;
    Sel2OrigLeft: XmTextPosition;
    Sel2OrigRight  : XmTextPosition;
    stuffpos    : XmTextPosition;
    sel2Left    : XmTextPosition;
    sel2Right   : XmTextPosition;(* secondary selection *)
    anchor      : XmTextPosition;(* anchor point of the primary selection *)
    select_pos_x: Xt.Position;   (* x position for timer-based scrolling *)
    select_pos_y: Xt.Position;   (* y position for timer-based scrolling *)
    pendingdelete  : Xt.Boolean; (* TRUE if we're implementing pending delete*)
    syncing     : Xt.Boolean;    (* If TRUE, then we've multiple keystrokes *)
    extending   : Xt.Boolean;    (* true if we are extending *)
    Sel2Extending  : Xt.Boolean; (* true if we are extending *)
    hasSel2     : Xt.Boolean;    (* has secondary selection *)
    has_destination: Xt.Boolean; (* has destination selection *)
    selectionMove: Xt.Boolean;   (* delete selection after stuff *)
    cancel      : Xt.Boolean;    (* indicates that cancel was pressed *)
    overstrike  : Xt.Boolean;    (* overstrike *)
    sel_start   : Xt.Boolean;    (* indicates that a btn2 was pressed *)
    dest_time   : X.Time;        (* time of destination selection ownership *)
    sec_time    : X.Time;        (* time of secondary selection ownership *)
    lasttime    : X.Time;        (* Time of last event. *)
  END;

  InputDataRec = _InputDataRec;

  InputData = POINTER TO _InputDataRec;

(*
 * Create a new instance of an input object.  By the time this is called,
 * the widget context has been saved.
 *)

  InputCreateProc = PROCEDURE ( Xt.Widget,
                                Xt.ArgList,
                                Xt.Cardinal);

(*
 * Get values out of the input object.
 *)

  InputGetValuesProc = PROCEDURE ( Xt.Widget, Xt.ArgList,
                                 Xt.Cardinal );

(*
 * Set values in the input object.
 *)

  InputSetValuesProc = PROCEDURE ( Xt.Widget,
                                   Xt.Widget,
                                   Xt.Widget,
                                   Xt.ArgList,
                                   Xt.Cardinal );

(*
 * Inform input of invalidated positions.
 *)

  InputInvalidateProc = PROCEDURE ( XmTextWidget,
                                    XmTextPosition,
                                    XmTextPosition,
                                    LONGINT );

(*
 * Get secondary resources.
 *)

  InputGetSecResProc = PROCEDURE ( VAR XmSecondaryResourceData );

  _InputRec = RECORD
    data         : InputData; (* Input-specific data; opaque type. *)
    Invalidate   : InputInvalidateProc;
    GetValues    : InputGetValuesProc;
    SetValues    : InputSetValuesProc;
    destroy      : Xt.XtWidgetProc;
    GetSecResData: InputGetSecResProc;
  END;

  InputRec = _InputRec;

VAR
  _XmdefaultTextActionsTable: Xt.XtPointer;
  _XmdefaultTextActionsTableSize: Xt.Cardinal;

(********    Private Function Declarations    ********)

PROCEDURE _XmTextGetDropReciever ( w: Xt.Widget ): Xt.Widget;

PROCEDURE _XmTextHasDestination ( w: Xt.Widget ): Xt.Boolean;

PROCEDURE _XmTextSetDestinationSelection ( w: Xt.Widget;
                                           position: XmTextPosition;
                                           disown: Xt.Boolean;
                                           set_time: X.Time ): Xt.Boolean;

PROCEDURE _XmTextSetSel2 ( tw: XmTextWidget;
                           left: XmTextPosition;
                           right: XmTextPosition;
                           set_time: X.Time ): Xt.Boolean;

PROCEDURE _XmTextGetSel2 ( tw: XmTextWidget;
                           VAR left: XmTextPosition;
                           VAR right: XmTextPosition ): Xt.Boolean;

PROCEDURE _XmTextInputGetSecResData ( VAR secResDataRtn: XmSecondaryResourceData );

PROCEDURE _XmTextGetAnchor ( tw: XmTextWidget ): XmTextPosition;

PROCEDURE _XmTextInputCreate ( wid: Xt.Widget;
                               args: Xt.ArgList;
                               num_args: Xt.Cardinal );

(********    End Private Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/TextSelP.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(********    Private Function Declarations    ********)

PROCEDURE _XmTextConvert ( w: Xt.Widget;
                           VAR selection: X.Atom;
                           VAR target: X.Atom;
                           VAR type: X.Atom;
                           VAR value: Xt.XtPointer;
                           VAR length: Xt.Cardinal;
                           VAR format: SYSTEM.int ): Xt.Boolean;

PROCEDURE _XmTextLoseSelection ( w: Xt.Widget;
                                 VAR selection: X.Atom );

(********    End Private Function Declarations    ********)

(* -------------------------------------------------- *)
(*                     Xm/TextP.h                     *)
(* -------------------------------------------------- *)

(*
 * Motif Release 1.2.4
 *)

TYPE
  Output = POINTER TO _OutputRec;

  Input = POINTER TO _InputRec;

CONST
  TEXTWIDGETCLASS = 'Text';    (*  Resource class for the text widget.  *)

TYPE
  _XmTextClassPart = RECORD
    extension: Xt.XtPointer;   (*  Pointer to extension record  *)
  END;

  XmTextClassPart = _XmTextClassPart;

  _XmTextClassRec = RECORD
    core_class     : Xt.CoreClassPart;
    primitive_class: XmPrimitiveClassPart;
    text_class     : XmTextClassPart;
  END;

  XmTextClassRec = _XmTextClassRec;

  _LineRec = RECORD
    start    : XmTextPosition; (* First position in this line. *)
    changed  : Xt.Boolean;     (* TRUE if something in this line changed.  *)
    changed_position: XmTextPosition; (* First position within the line that
                                         has changed, if any. *)
    past_end : Xt.Boolean;     (* TRUE if this line is past the end of any
      	      	      	      	  line actually on the screen. *)
    extra    : LineTableExtra; (* Extra info the output module keeps. *)
  END;

  LineRec = _LineRec;

  Line = POINTER TO _LineRec;

  _XmTextLineTableRec = RECORD
<* IF __GEN_C__ THEN *>
    start_pos: CARDINAL;       (* H2D: bit field. start_pos:31 *)
    virt_line: CARDINAL;       (* H2D: bit field. virt_line:1 *)
<* ELSE *>
    start_pos: PACKEDSET OF [0..31]; (* H2D: bit fields:
                                               start_pos:31,
                                               virt_line:1. *)
<* END *>
  END;

  XmTextLineTableRec = _XmTextLineTableRec;

  XmTextLineTable = POINTER TO _XmTextLineTableRec;

  _RangeRec = RECORD
    from: XmTextPosition;
    to  : XmTextPosition;   (*  Information on one range to repaint.  *)
  END;

  RangeRec = _RangeRec;

  Range = POINTER TO _RangeRec;

  Ranges = RECORD
    number : Xt.Cardinal;   (* Number of ranges defined. *)
    maximum: Xt.Cardinal;   (* Number of ranges we have space for. *)
    range  : Range;   (* Pointer to array of ranges. *)
  END;

(*
 * Structure for main text info.
 *)

  _XmTextPart = RECORD
    source                : XmTextSource;      (* The source for this widget.*)
    activate_callback     : Xt.XtCallbackList; (* command activate callback. *)
    focus_callback        : Xt.XtCallbackList; (* Focus callback. *)
    losing_focus_callback : Xt.XtCallbackList; (* Losing focus callback. *)
    value_changed_callback: Xt.XtCallbackList; (* Value changed callback. *)
    modify_verify_callback: Xt.XtCallbackList; (* Verify value to change callback. *)
    wcs_modify_verify_callback:Xt.XtCallbackList;(* Verify value to change
                                                    callback. *)
    motion_verify_callback: Xt.XtCallbackList; (* Insert cursor position
                                                * change callback. *)
    gain_primary_callback : Xt.XtCallbackList; (* Gained ownership of Primary
                                                * Selection *)
    lose_primary_callback : Xt.XtCallbackList; (* Lost ownership of Primary
                                                * Selection *)
    value           : Xt.String;     (* The sring value in the widget *)
    wc_value        : XmKeySymTable; (* Pointer for wchar_t value set by app *)
    margin_height   : Xt.Dimension;  (* height between text borders and text *)
    margin_width    : Xt.Dimension;  (* width between text borders and text *)
    cursor_position_x:Xt.Position;   (* x pixel location of cursor *)
    output_create  :OutputCreateProc;(* Routine to create the output portion.*)
    input_create   :InputCreateProc; (* Routine to create the input portion. *)
 (* The naming incongruity amongst the next three items was introduced
    due to a collision with top_position as used as a Form constraint;
    It has no other implications. *)
    top_character    : XmTextPosition; (* First position to display.  *)
    bottom_position  : XmTextPosition; (* Last position to display.  *)
    cursor_position  : XmTextPosition; (* Location of the insertion point.  *)
    max_length       : SYSTEM.int;     (* Sets the max. length of string  *)
    edit_mode        : SYSTEM.int;     (* Sets the line editing mode
                                        * (i.e. sinlge_line,multi_line,...) *)
    auto_show_cursor_position:Xt.Boolean;(* If true, automatically try to show
                                            the cursor position whenever it
                                            changes. *)
    editable       : Xt.Boolean; (* Determines if text is editable *)
    verify_bell    : Xt.Boolean; (* Determines if bell is sounded when verify
                                  * callback returns doit - False *)
    add_mode       : Xt.Boolean; (* Determines the state of add moder  *)
    traversed      : Xt.Boolean; (* Flag used with losing focus verification
                                  * to indicate a traversal key pressed event*)
    in_redisplay   : Xt.Boolean; (* Whether currently in the redisplay proc. *)
    needs_redisplay: Xt.Boolean; (* Whether we need to repaint or refigure. *)
    in_refigure_lines:Xt.Boolean;(* Whether currently in refigurelines proc. *)
    needs_refigure_lines: Xt.Boolean;(* Whether we need to refigure. *)
    in_setvalues   : Xt.Boolean; (* Use to reduce unnecessary redisplays and
                                  * geometry requsets *)
    in_resize      : Xt.Boolean; (* Make sure there are no geometry requests
                                  * while we are in resize procedure. *)
    in_expose      : Xt.Boolean; (* Make sure there are no geometry requests
                                  * while we are in expose procedure. *)
    highlight_changed:Xt.Boolean;(* Whether highlighting recently changed. *)
    pendingoff     : Xt.Boolean; (* TRUE if we shouldn't do pending delete on
                                  * the current selection. *)
    char_size      : CHAR;       (* number of bytes for storing a character *)
    on_or_off      : OnOrOff;    (* used to halt unecessary motion verify
                                  * callback calls during primary moves. *)
    output         : Output;     (* The output portion. *)
    input          : Input;      (* The input portion. *)
    first_position : XmTextPosition; (*  First legal position in the source. *)
    last_position  : XmTextPosition; (* Last legal position in the source. *)
    forget_past    : XmTextPosition; (* Forget all about positions past this.*)
    force_display  : XmTextPosition; (* Force this position to be displayed. *)
    new_top        : XmTextPosition; (* Desired new top position. *)
    last_top_char  : XmTextPosition; (* unused - available. *)
    dest_position  : XmTextPosition; (* Location of the destination point. *)
    disable_depth  : SYSTEM.int; (* How many levels of disable we've done. *)
    pending_scroll : SYSTEM.int; (* Number of lines we want to scroll. *)
    total_lines    : SYSTEM.int; (* Total number of lines in the text widget *)
    top_line       : SYSTEM.int; (* Line number of the top visible line *)
    vsbar_scrolling: SYSTEM.int; (* scrolling using the vertical scrollbar *)
    number_lines   : Xt.Cardinal;(* Number of line table entries. *)
    maximum_lines  : Xt.Cardinal;(* Maximum number of line table entries. *)
    line           : Line;       (* Pointer to array of line table entries. *)
    repaint        : Ranges;     (* Info on the repaint ranges. *)
    highlight      : _XmHighlightData;(* Info on the highlighting regions. *)
    old_highlight  : _XmHighlightData;(* Old value of above. *)
    inner_widget   : Xt.Widget;  (* Pointer to widget which actually contains
                                  * text (may be same or different from
                                  * this record). *)
    line_table     : XmTextLineTable;
    table_size     : CARDINAL;
    table_index    : CARDINAL;
  END;

  XmTextPart = _XmTextPart;

  _XmTextRec = RECORD
    core     : Xt.CorePart;
    primitive: XmPrimitivePart;
    text     : XmTextPart;
  END;

  XmTextRec = _XmTextRec;

VAR
  xmTextClassRec: XmTextClassRec;

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE GetSrc ( widget: Xt.Widget ): XmTextSource;
PROCEDURE ShouldWordWrap ( data: OutputData; widget: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE / ShouldWordWrap ( data: OutputData; widget: Xt.Widget ): Xt.Boolean;
PROCEDURE / GetSrc ( widget: Xt.Widget ): XmTextSource;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmTextFindScroll ( widget: XmTextWidget;
                              start: XmTextPosition;
                              delta: SYSTEM.int ): XmTextPosition;

PROCEDURE _XmTextGetTotalLines ( widget: Xt.Widget ): SYSTEM.int;

PROCEDURE _XmTextGetLineTable ( widget: Xt.Widget;
                                VAR total_lines: SYSTEM.int ): XmTextLineTable;

PROCEDURE _XmTextRealignLineTable ( widget: XmTextWidget;
                                    VAR temp_table: XmTextLineTable;
                                    VAR temp_table_size: SYSTEM.int;
                                    cur_index: CARDINAL;
                                    cur_start: XmTextPosition;
                                    cur_end: XmTextPosition );

PROCEDURE _XmTextGetTableIndex ( widget: XmTextWidget;
                                 pos: XmTextPosition ): CARDINAL;

PROCEDURE _XmTextUpdateLineTable ( widget: Xt.Widget;
                                   start: XmTextPosition;
                                   end: XmTextPosition;
                                   block: XmTextBlock;
                                   update: Xt.Boolean );

PROCEDURE _XmTextMarkRedraw ( widget: XmTextWidget;
                              left: XmTextPosition;
                              right: XmTextPosition );

PROCEDURE _XmTextNumLines ( widget: XmTextWidget ): LineNum;

PROCEDURE _XmTextLineInfo ( widget: XmTextWidget;
                            line: LineNum;
                            VAR startpos: XmTextPosition;
                            VAR extra: LineTableExtra );

PROCEDURE _XmTextPosToLine ( widget: XmTextWidget;
                             position: XmTextPosition ): LineNum;

PROCEDURE _XmTextInvalidate ( widget: XmTextWidget;
                              position: XmTextPosition;
                              topos: XmTextPosition;
                              delta: LONGINT );

PROCEDURE _XmTextSetTopCharacter ( widget: Xt.Widget;
                                   top_character: XmTextPosition );

PROCEDURE _XmTextCountCharacters ( str: Xt.String;
                                   num_count_bytes: SYSTEM.int ): SYSTEM.int;

PROCEDURE _XmTextSetCursorPosition ( widget: Xt.Widget;
                                     position: XmTextPosition );

PROCEDURE _XmTextDisableRedisplay ( widget: XmTextWidget;
                                    losesbackingstore: Xt.Boolean );

PROCEDURE _XmTextEnableRedisplay ( widget: XmTextWidget );

(********    End Private Function Declarations    ********)

(* -------------------------------------------------- *)
(*                     Xm/TextF.h                     *)
(* -------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(******************
 * type defines   *
 ******************)

TYPE
  XmTextFieldWidgetClass = POINTER TO _XmTextFieldClassRec;

  XmTextFieldWidget = POINTER TO _XmTextFieldRec;

(******************
 * extern class   *
 ******************)

VAR
  xmTextFieldWidgetClass: Xt.WidgetClass;

(********************
 * public functions *
 ********************)

(********    Public Function Declarations    ********)

PROCEDURE ToggleCursorGC ( widget: Xt.Widget;
                           state: Xt.Boolean );

PROCEDURE XmTextFieldGetString ( w: Xt.Widget ): Xt.String;

PROCEDURE XmTextFieldGetSubstring ( widget: Xt.Widget;
                                    start: XmTextPosition;
                                    num_chars: SYSTEM.int;
                                    buf_size: SYSTEM.int;
                                    buffer: Xt.String ): SYSTEM.int;

PROCEDURE XmTextFieldGetStringWcs ( w: Xt.Widget ): Xlib.Ptrwchar_t;

PROCEDURE XmTextFieldGetSubstringWcs ( widget: Xt.Widget;
                                       start: XmTextPosition;
                                       num_chars: SYSTEM.int;
                                       buf_size: SYSTEM.int;
                                       buffer: Xlib.Ptrwchar_t ): SYSTEM.int;

PROCEDURE XmTextFieldGetLastPosition ( w: Xt.Widget ): XmTextPosition;

PROCEDURE XmTextFieldSetString ( w: Xt.Widget;
                                 value: ARRAY OF CHAR );

PROCEDURE XmTextFieldSetStringWcs ( w: Xt.Widget;
                                    wc_value: Xlib.Ptrwchar_t );

PROCEDURE XmTextFieldReplace ( w: Xt.Widget;
                               from_pos: XmTextPosition;
                               to_pos: XmTextPosition;
                               value: ARRAY OF CHAR );

PROCEDURE XmTextFieldReplaceWcs ( w: Xt.Widget;
                                  from_pos: XmTextPosition;
                                  to_pos: XmTextPosition;
                                  wc_value: Xlib.Ptrwchar_t );

PROCEDURE XmTextFieldInsert ( w: Xt.Widget;
                              position: XmTextPosition;
                              value: ARRAY OF CHAR );

PROCEDURE XmTextFieldInsertWcs ( w: Xt.Widget;
                                 position: XmTextPosition;
                                 wcstring: Xlib.Ptrwchar_t );

PROCEDURE XmTextFieldSetAddMode ( w: Xt.Widget;
                                  state: Xt.Boolean );

PROCEDURE XmTextFieldGetAddMode ( w: Xt.Widget ): Xt.Boolean;

PROCEDURE XmTextFieldGetEditable ( w: Xt.Widget ): Xt.Boolean;

PROCEDURE XmTextFieldSetEditable ( w: Xt.Widget;
                                   editable: Xt.Boolean );

PROCEDURE XmTextFieldGetMaxLength ( w: Xt.Widget ): SYSTEM.int;

PROCEDURE XmTextFieldSetMaxLength ( w: Xt.Widget;
                                    max_length: SYSTEM.int );

PROCEDURE XmTextFieldGetCursorPosition ( w: Xt.Widget ): XmTextPosition;

PROCEDURE XmTextFieldGetInsertionPosition ( w: Xt.Widget ): XmTextPosition;

PROCEDURE XmTextFieldSetCursorPosition ( w: Xt.Widget;
                                         position: XmTextPosition );

PROCEDURE XmTextFieldSetInsertionPosition ( w: Xt.Widget;
                                            position: XmTextPosition );

PROCEDURE XmTextFieldGetSelectionPosition ( w: Xt.Widget;
                                            VAR left: XmTextPosition;
                                            VAR right: XmTextPosition ): Xt.Boolean;

PROCEDURE XmTextFieldGetSelection ( w: Xt.Widget ): Xt.String;

PROCEDURE XmTextFieldGetSelectionWcs ( w: Xt.Widget ): Xlib.Ptrwchar_t;

PROCEDURE XmTextFieldRemove ( w: Xt.Widget ): Xt.Boolean;

PROCEDURE XmTextFieldCopy ( w: Xt.Widget;
                            clip_time: X.Time ): Xt.Boolean;

PROCEDURE XmTextFieldCut ( w: Xt.Widget;
                           clip_time: X.Time ): Xt.Boolean;

PROCEDURE XmTextFieldPaste ( w: Xt.Widget ): Xt.Boolean;

PROCEDURE XmTextFieldClearSelection ( w: Xt.Widget;
                                      sel_time: X.Time );

PROCEDURE XmTextFieldSetSelection ( w: Xt.Widget;
                                    first: XmTextPosition;
                                    last: XmTextPosition;
                                    sel_time: X.Time );

PROCEDURE XmTextFieldXYToPos ( w: Xt.Widget;
                               x: Xt.Position;
                               y: Xt.Position ): XmTextPosition;

PROCEDURE XmTextFieldPosToXY ( w: Xt.Widget;
                               position: XmTextPosition;
                               VAR x: SYSTEM.INT16;
                               VAR y: SYSTEM.INT16 ): Xt.Boolean;

PROCEDURE XmTextFieldShowPosition ( w: Xt.Widget;
                                    position: XmTextPosition );

PROCEDURE XmTextFieldSetHighlight ( w: Xt.Widget;
                                    left: XmTextPosition;
                                    right: XmTextPosition;
                                    mode: XmHighlightMode );

PROCEDURE XmTextFieldGetBaseline ( w: Xt.Widget ): SYSTEM.int;

PROCEDURE XmCreateTextField ( parent: Xt.Widget;
                              name: ARRAY OF CHAR;
                              arglist: Xt.ArgList;
                              argcount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/TextFSelP.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2
 *)

(********    Private Function Declarations    ********)

PROCEDURE _XmTextFieldConvert ( w: Xt.Widget;
                                VAR selection: X.Atom;
                                VAR target: X.Atom;
                                VAR type: X.Atom;
                                VAR value: Xt.XtPointer;
                                VAR length: CARDINAL;
                                VAR format: SYSTEM.int ): Xt.Boolean;

PROCEDURE _XmTextFieldLoseSelection ( w: Xt.Widget;
                                      VAR selection: X.Atom );

(********    End Private Function Declarations    ********)

(* --------------------------------------------------- *)
(*                     Xm/TextFP.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(*
 * Defines for different cursors
 *)

CONST
  IBEAM_WIDTH = 3;
  CARET_WIDTH = 9;
  CARET_HEIGHT = 5;

(*
 * Here is the Text Field Widget class structure.
 *)

TYPE
  _XmTextFieldClassPart = RECORD
    extension: Xt.XtPointer;   (* Pointer to extension record *)
  END;

  XmTextFieldClassPart = _XmTextFieldClassPart;

  _XmTextFieldClassRec = RECORD
    core_class : Xt.CoreClassPart; (* Not RectObjClassPart so I can reference
                                    * core_class s *)
    primitive_class: XmPrimitiveClassPart;
    text_class     : XmTextFieldClassPart;
  END;

  XmTextFieldClassRec = _XmTextFieldClassRec;

(*
 * Here is the Text Field Widget instance structures.
 *)

  _XmTextFieldPart = RECORD
    activate_callback    : Xt.XtCallbackList;(* Command activate callback  *)
    focus_callback       : Xt.XtCallbackList;(* Verify losing focus callback *)
    losing_focus_callback: Xt.XtCallbackList;(* Verify losing focus callback *)
    modify_verify_callback:Xt.XtCallbackList;(* Verify value to change callback  *)
    wcs_modify_verify_callback:Xt.XtCallbackList;(* Verify value to change
                                                  * callback *)
    motion_verify_callback:Xt.XtCallbackList;(*Verify insert cursor position to
                                              * change callback *)
    gain_primary_callback: Xt.XtCallbackList;(* Gained ownership of Primary
                                              * Selection *)
    lose_primary_callback: Xt.XtCallbackList;(* Lost ownership of Primary
                                              * Selection *)
    value_changed_callback:Xt.XtCallbackList;(* Notify that value has change
      	      	      	      	      	      * callback *)
    value   : Xt.String;       (* pointer to widget value stored as char* *)
    wc_value: Xlib.Ptrwchar_t; (* pointer to widget value stored as wchar_t* *)
    font_list:XmFontList;      (* Uses only the font portion of fontlist *)
    font    : Xlib.PtrXFontStruct;(* font retrieved from the fontlist *)
    selection_array: XmTextScanTypeList; (* Description of what to cycle
                                          * through on selections *)
    highlight     : _XmHighlightData; (* Info on the highlighting regions. *)
    gc            : Xlib.GC;  (* Normal GC for drawing text and cursor *)
    image_gc      : Xlib.GC;  (* Image GC for drawing text cursor *)
    save_gc       : Xlib.GC;  (* GC for saving/restoring under IBeam *)
    ibeam_off     : X.Pixmap; (* pixmap for area under the IBeam *)
    add_mode_cursor:X.Pixmap; (* The add mode cursor pixmap *)
    cursor        : X.Pixmap; (* The ibeam cursor stencil *)
    putback       : X.Pixmap; (* AVAILABLE: was in 1.1 but not really used *)
    stipple_tile  : X.Pixmap; (* The tile pattern for the stippled I-beam *)
    image_clip    : X.Pixmap; (* The clip rect needed for image gc *)
    cursor_position:XmTextPosition;(* Character location of the insert cursor*)
    new_h_offset  : XmTextPosition;(* Used in setvaluesalmost proc *)
    h_offset      : XmTextPosition;(* The x position of the first character
                                    * (relative to left edge of the widget) *)
    orig_left     : XmTextPosition;(* Left primary selection prior to extend *)
    orig_right    : XmTextPosition;(* Right primary selection prior to extend*)
    prim_pos_left : XmTextPosition;(* Left primary selection position *)
    prim_pos_right: XmTextPosition;(* Right primary selection position *)
    prim_anchor   : XmTextPosition;(* Primary selection pivot point *)
    sec_pos_left  : XmTextPosition;(* Left secondary selection position *)
    sec_pos_right : XmTextPosition;(* Right secondary selection position *)
    sec_anchor    : XmTextPosition;(* Secondary selection pivot point *)
    stuff_pos     : XmTextPosition;(* Position to stuff the primary selection*)
    select_pos_x  : Xt.Position;   (* x position for timer-based scrolling *)
    prim_time     : X.Time;        (* Timestamp of primary selection  *)
    dest_time     : X.Time;        (* Timestamp of destination selection  *)
    sec_time      : X.Time;        (* Timestamp of secondary selection  *)
    last_time     : X.Time;        (* Time of last selection event  *)
    timer_id      :Xt.XtIntervalId;(* Blinking cursor timer  *)
    select_id     :Xt.XtIntervalId;(* Timer based scrolling identifier  *)
    blink_rate    : SYSTEM.int;    (* Rate of blinking text cursor in msec  *)
    selection_array_count:SYSTEM.int;(* Selection array count *)
    threshold     : SYSTEM.int;    (* Selection threshold *)
    size_allocd   : SYSTEM.int;    (* Size allocated for value string *)
    string_length : SYSTEM.int;    (* The number of characters in the string
                                    * (including the trailing NULL) *)
    cursor_height : SYSTEM.int;    (* Save cursor dimensions  *)
    cursor_width  : SYSTEM.int;    (* Save cursor dimensions  *)
    sarray_index  : SYSTEM.int;    (* Index into selection array  *)
    max_length    : SYSTEM.int;    (* Maximum number of character that can be
                                    * inserted into the text field widget *)
    max_char_size : SYSTEM.int;    (* Max bytes per character in cur locale *)
    columns       : SYSTEM.INT16;  (* The number of characters in the width *)
    margin_width  : Xt.Dimension;  (* Height between text borders and text *)
    margin_height : Xt.Dimension;  (* Width between text borders and text *)
    average_char_width:Xt.Dimension;(* Average character width based on font *)
    margin_top    : Xt.Dimension;(* Height between text borders and top
      	      	      	      	  * of text *)
    margin_bottom : Xt.Dimension;(* Height between text borders and bottom
      	      	      	      	  * of text *)
    font_ascent   : Xt.Dimension;(* Ascent of font or fontset used by widget *)
    font_descent  : Xt.Dimension;(* Descent of font or fontset used by widget*)
    resize_width  : Xt.Boolean;  (* Allows the widget to grow horizontally
                                  * when borders are reached *)
    pending_delete: Xt.Boolean;  (* Delete primary selection on insert when
                                  * set to True *)
    editable      : Xt.Boolean;  (* Sets editablility of text  *)
    verify_bell   : Xt.Boolean;  (* Determines if bell is sounded when verify
                                  * callback returns doit - False *)
    cursor_position_visible:Xt.Boolean;(* Sets visibility of insert cursor *)
    traversed     : Xt.Boolean;  (* Flag used with losing focus verification to
                                  * indicate a traversal key pressed event *)
    add_mode      : Xt.Boolean;  (* Add mode for cursor movement *)
    has_focus     : Xt.Boolean;  (* Flag that indicates whether the widget
                                  * has input focus *)
    blink_on      : Xt.Boolean;  (* State of Blinking insert cursor *)
    cursor_on     : SYSTEM.INT16;(* Indicates whether the cursor is visible *)
    refresh_ibeam_off:Xt.Boolean;(*Indicates whether the area under IBeam needs
                                  * to be re-captured *)
    have_inverted_image_gc:Xt.Boolean;(* fg/bg of image gc have been swapped *)
    has_primary   : Xt.Boolean;  (* Indicates that is has the
                                  * primary selection *)
    has_secondary : Xt.Boolean;  (* Indicates that is has the
                                  * secondary selection *)
    has_destination:Xt.Boolean;  (* Indicates that is has the
                                  * destination selection *)
    sec_drag      : Xt.Boolean;  (* Indicates a secondary drag was made *)
    selection_move: Xt.Boolean;  (* Indicates that the action requires a
                                  * secondary move (i.e. copy & cut) *)
    pending_off   : Xt.Boolean;  (* indicates pending delete state *)
    fontlist_created:Xt.Boolean; (*Indicates that the text field widget created
                                  * it's own fontlist *)
    has_rect      : Xt.Boolean;  (* currently has clipping rectangle *)
    do_drop       : Xt.Boolean;  (* Indicates that the widget the recieved the
                                  * button release, did not have a previous
                                  * button press, so it is o.k. to request
                                  * the MOTIF_DROP selection. *)
    cancel        : Xt.Boolean;  (* Cancels selection actions when true *)
    extending     : Xt.Boolean;  (* Indicates extending primary selection *)
    sec_extending : Xt.Boolean;  (* Indicates extending secondary selection *)
    changed_visible:Xt.Boolean;  (* Indicates whether the dest_visible flag
                                  * is in a temporary changed state *)
    have_fontset  : Xt.Boolean;  (* The widgets font is a fontset, not a
                                  * fontstruct... use R5 draw routines *)
    in_setvalues  : Xt.Boolean;  (* used to disable unnecessary redisplays *)
    do_resize     : Xt.Boolean;  (* used to prevent inappropriate resizes *)
    redisplay     : Xt.Boolean;  (* used to set redisplay flag in setvalues *)
    overstrike    : Xt.Boolean;  (* overstrike mode for character input *)
    sel_start     : Xt.Boolean;  (* overstrike mode for character input *)
    extension     : Xt.XtPointer;(* Pointer to extension record. *)
  END;

 XmTextFieldPart = _XmTextFieldPart;

  _XmTextFieldRec = RECORD
    core     : Xt.CorePart;
    primitive: XmPrimitivePart;
    text     : XmTextFieldPart;
  END;

  XmTextFieldRec = _XmTextFieldRec;

VAR
  xmTextFieldClassRec: XmTextFieldClassRec;

(****************
 *
 * Macros for the uncached data
 *
 ****************)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE TextF_ActivateCallback ( tfg: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE TextF_LosingFocusCallback ( tfg: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE TextF_FocusCallback ( tfg: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE TextF_ModifyVerifyCallback ( tfg: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE TextF_ModifyVerifyCallbackWcs ( tfg: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE TextF_MotionVerifyCallback ( tfg: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE TextF_ValueChangedCallback ( tfg: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE TextF_Value ( tfg: Xt.Widget ): Xt.String;
PROCEDURE TextF_WcValue ( tfg: Xt.Widget ): Xlib.Ptrwchar_t;
PROCEDURE TextF_MarginHeight ( tfg: Xt.Widget ): Xt.Dimension;
PROCEDURE TextF_MarginWidth ( tfg: Xt.Widget ): Xt.Dimension;
PROCEDURE TextF_CursorPosition ( tfg: Xt.Widget ): XmTextPosition;
PROCEDURE TextF_Columns ( tfg: Xt.Widget ): SYSTEM.INT16;
PROCEDURE TextF_MaxLength ( tfg: Xt.Widget ): SYSTEM.int;
PROCEDURE TextF_BlinkRate ( tfg: Xt.Widget ): SYSTEM.int;
PROCEDURE TextF_FontList ( tfg: Xt.Widget ): XmFontList;
PROCEDURE TextF_Font ( tfg: Xt.Widget ): Xlib.PtrXFontStruct;
PROCEDURE TextF_FontAscent ( tfg: Xt.Widget ): Xt.Dimension;
PROCEDURE TextF_FontDescent ( tfg: Xt.Widget ): Xt.Dimension;
PROCEDURE TextF_SelectionArray ( tfg: Xt.Widget ): XmTextScanTypeList;
PROCEDURE TextF_SelectionArrayCount ( tfg: Xt.Widget ): SYSTEM.int;
PROCEDURE TextF_ResizeWidth ( tfg: Xt.Widget ): Xt.Boolean;
PROCEDURE TextF_PendingDelete ( tfg: Xt.Widget ): Xt.Boolean;
PROCEDURE TextF_Editable ( tfg: Xt.Widget ): Xt.Boolean;
PROCEDURE TextF_CursorPositionVisible ( tfg: Xt.Widget ): Xt.Boolean;
PROCEDURE TextF_Threshold ( tfg: Xt.Widget ): SYSTEM.int;
PROCEDURE TextF_UseFontSet ( tfg: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / TextF_ActivateCallback ( tfg: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / TextF_LosingFocusCallback ( tfg: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / TextF_FocusCallback ( tfg: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / TextF_ModifyVerifyCallback ( tfg: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / TextF_ModifyVerifyCallbackWcs ( tfg: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / TextF_MotionVerifyCallback ( tfg: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / TextF_ValueChangedCallback ( tfg: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / TextF_Value ( tfg: Xt.Widget ): Xt.String;
PROCEDURE  / TextF_WcValue ( tfg: Xt.Widget ): Xlib.Ptrwchar_t;
PROCEDURE  / TextF_MarginHeight ( tfg: Xt.Widget ): Xt.Dimension;
PROCEDURE  / TextF_MarginWidth ( tfg: Xt.Widget ): Xt.Dimension;
PROCEDURE  / TextF_CursorPosition ( tfg: Xt.Widget ): XmTextPosition;
PROCEDURE  / TextF_Columns ( tfg: Xt.Widget ): SYSTEM.INT16;
PROCEDURE  / TextF_MaxLength ( tfg: Xt.Widget ): SYSTEM.int;
PROCEDURE  / TextF_BlinkRate ( tfg: Xt.Widget ): SYSTEM.int;
PROCEDURE  / TextF_FontList ( tfg: Xt.Widget ): XmFontList;
PROCEDURE  / TextF_Font ( tfg: Xt.Widget ): Xlib.PtrXFontStruct;
PROCEDURE  / TextF_FontAscent ( tfg: Xt.Widget ): Xt.Dimension;
PROCEDURE  / TextF_FontDescent ( tfg: Xt.Widget ): Xt.Dimension;
PROCEDURE  / TextF_SelectionArray ( tfg: Xt.Widget ): XmTextScanTypeList;
PROCEDURE  / TextF_SelectionArrayCount ( tfg: Xt.Widget ): SYSTEM.int;
PROCEDURE  / TextF_ResizeWidth ( tfg: Xt.Widget ): Xt.Boolean;
PROCEDURE  / TextF_PendingDelete ( tfg: Xt.Widget ): Xt.Boolean;
PROCEDURE  / TextF_Editable ( tfg: Xt.Widget ): Xt.Boolean;
PROCEDURE  / TextF_CursorPositionVisible ( tfg: Xt.Widget ): Xt.Boolean;
PROCEDURE  / TextF_Threshold ( tfg: Xt.Widget ): SYSTEM.int;
PROCEDURE  / TextF_UseFontSet ( tfg: Xt.Widget ): Xt.Boolean;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmTextFieldCountBytes ( tf: XmTextFieldWidget;
                                   wc_value: Xlib.Ptrwchar_t;
                                   num_chars: SYSTEM.int ): SYSTEM.int;

PROCEDURE _XmTextFieldGetDropReciever ( w: Xt.Widget ): Xt.Widget;

PROCEDURE _XmTextFToggleCursorGC ( widget: Xt.Widget );

PROCEDURE _XmTextFieldDrawInsertionPoint ( tf: XmTextFieldWidget;
                                           turn_on: Xt.Boolean );

PROCEDURE _XmTextFieldSetClipRect ( tf: XmTextFieldWidget );

PROCEDURE _XmTextFieldSetCursorPosition ( tf: XmTextFieldWidget;
                                          VAR event: Xlib.XEvent;
                                          position: XmTextPosition;
                                          adjust_flag: Xt.Boolean;
                                          call_cb: Xt.Boolean );

PROCEDURE _XmTextFieldReplaceText ( tf: XmTextFieldWidget;
                                    VAR event: Xlib.XEvent;
                                    replace_prev: XmTextPosition;
                                    replace_next: XmTextPosition;
                                    insert: ARRAY OF CHAR;
                                    insert_length: SYSTEM.int;
                                    move_cursor: Xt.Boolean ): Xt.Boolean;

PROCEDURE _XmTextFieldDeselectSelection ( w: Xt.Widget;
                                          disown: Xt.Boolean;
                                          sel_time: X.Time );

PROCEDURE _XmTextFieldSetDestination ( w: Xt.Widget;
                                       position: XmTextPosition;
                                       set_time: X.Time ): Xt.Boolean;

PROCEDURE _XmTextFieldStartSelection ( tf: XmTextFieldWidget;
                                       left: XmTextPosition;
                                       right: XmTextPosition;
                                       sel_time: X.Time );

PROCEDURE _XmTextFieldSetSel2 ( w: Xt.Widget;
                                left: XmTextPosition;
                                right: XmTextPosition;
                                disown: Xt.Boolean;
                                sel_time: X.Time );

(********    End Private Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/TearOffP.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

TYPE
  _XmExcludedParentPaneRec = RECORD
    pane_list_size: SYSTEM.INT16;
    pane          : Xt.WidgetList;
    num_panes     : SYSTEM.INT16;
  END;

  XmExcludedParentPaneRec = _XmExcludedParentPaneRec;

VAR
  _XmExcludedParentPane: XmExcludedParentPaneRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmTearOffBtnDownEventHandler ( reportingWidget: Xt.Widget;
                                          data: Xt.XtPointer;
                                          VAR event: Xlib.XEvent;
                                          VAR cont: Xt.Boolean );

PROCEDURE _XmTearOffBtnUpEventHandler ( reportingWidget: Xt.Widget;
                                        data: Xt.XtPointer;
                                        VAR event: Xlib.XEvent;
                                        VAR cont: Xt.Boolean );

PROCEDURE _XmDestroyTearOffShell ( wid: Xt.Widget );

PROCEDURE _XmDismissTearOff ( shell: Xt.Widget;
                              closure: Xt.XtPointer;
                              call_data: Xt.XtPointer );

PROCEDURE _XmTearOffInitiate ( wid: Xt.Widget;
                               VAR event: Xlib.XEvent );

PROCEDURE _XmAddTearOffEventHandlers ( wid: Xt.Widget );

PROCEDURE _XmIsTearOffShellDescendant ( wid: Xt.Widget ): Xt.Boolean;

PROCEDURE _XmLowerTearOffObscuringPoppingDownPanes ( ancestor: Xt.Widget;
                                                     tearOff: Xt.Widget );

PROCEDURE _XmRestoreExcludedTearOffToToplevelShell ( wid: Xt.Widget;
                                                     VAR event: Xlib.XEvent );

PROCEDURE _XmRestoreTearOffToToplevelShell ( wid: Xt.Widget;
                                             VAR event: Xlib.XEvent );

PROCEDURE _XmRestoreTearOffToMenuShell ( wid: Xt.Widget;
                                         VAR event: Xlib.XEvent );

(********    End Private Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/TearOffBP.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2.3
 *)

(*
 *  TearOffBP.h - Private definitions for TearOffButton widget
 *  (Used by RowColumn Tear Off Menupanes)
 *)

(*****************************************************************************
 *
 * TearOffButton Widget Private Data
 *
 *****************************************************************************)

(*  New fields for the TearOffButton widget class record  *)

TYPE
  _XmTearOffButtonClassPart = RECORD
    translations: Xt.String;
  END;

  XmTearOffButtonClassPart = _XmTearOffButtonClassPart;

(*  Full Class record declaration  *)

  _XmTearOffButtonClassRec = RECORD
    core_class         : Xt.CoreClassPart;
    primitive_class    : XmPrimitiveClassPart;
    label_class        : XmLabelClassPart;
    pushbutton_class   : XmPushButtonClassPart;
    tearoffbutton_class: XmTearOffButtonClassPart;
  END;

  XmTearOffButtonClassRec = _XmTearOffButtonClassRec;

  XmTearOffButtonWidgetClass = POINTER TO _XmTearOffButtonClassRec;

(*  New fields for the TearOffButton widget record  *)

  XmTearOffButtonPart = RECORD
    margin        : Xt.Dimension;
    orientation   : SHORTCARD;
    separator_type: SHORTCARD;
    separator_GC  : Xlib.GC;
  END;

(*****************************************************************************
 *
 * Full instance record declaration
 *
 ****************************************************************************)

  _XmTearOffButtonRec = RECORD
    core           : Xt.CorePart;
    primitive      : XmPrimitivePart;
    label          : XmLabelPart;
    pushbutton     : XmPushButtonPart;
    tear_off_button: XmTearOffButtonPart;
  END;

  XmTearOffButtonRec = _XmTearOffButtonRec;

  XmTearOffButtonWidget = POINTER TO _XmTearOffButtonRec;

(*  Class Record Constant  *)

VAR
  xmTearOffButtonClassRec: XmTearOffButtonClassRec;
  xmTearOffButtonWidgetClass: Xt.WidgetClass;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* ---------------------------------------------------- *)
(*                     Xm/ToggleB.h                     *)
(* ---------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(***********************************************************************
 *
 * Toggle Widget
 *
 ***********************************************************************)

VAR
  xmToggleButtonWidgetClass: Xt.WidgetClass;

TYPE
  XmToggleButtonWidgetClass = POINTER TO _XmToggleButtonClassRec;

  XmToggleButtonWidget = POINTER TO _XmToggleButtonRec;

(********    Public Function Declarations    ********)

PROCEDURE XmToggleButtonGetState ( w: Xt.Widget ): Xt.Boolean;

PROCEDURE XmToggleButtonSetState ( w: Xt.Widget;
                                   newstate: Xt.Boolean;
                                   notify: Xt.Boolean );

PROCEDURE XmCreateToggleButton ( parent: Xt.Widget;
                                 name: ARRAY OF CHAR;
                                 arglist: Xt.ArgList;
                                 argCount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/ToggleBP.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

(********************************************
 *
 *   No new fields need to be defined
 *   for the Toggle widget class record
 *
 ********************************************)

TYPE
  _XmToggleButtonClassPart = RECORD
    extension: Xt.XtPointer;   (* Pointer to extension record *)
  END;

  XmToggleButtonClassPart = _XmToggleButtonClassPart;

(****************************************************
 *
 * Full class record declaration for Toggle class
 *
 ****************************************************)

  _XmToggleButtonClassRec = RECORD
    core_class      : Xt.CoreClassPart;
    primitive_class : XmPrimitiveClassPart;
    label_class     : XmLabelClassPart;
    toggle_class    : XmToggleButtonClassPart;
  END;

  XmToggleButtonClassRec = _XmToggleButtonClassRec;

(********************************************
 *
 * No new fields needed for instance record
 *
 ********************************************)

   _XmToggleButtonPart = RECORD
    ind_type        : SHORTCARD;
    visible         : Xt.Boolean;
    spacing         : Xt.Dimension;
    indicator_dim   : Xt.Dimension;
    indicator_set   : Xt.Boolean;
    on_pixmap       : X.Pixmap;
    insen_pixmap    : X.Pixmap;
    set             : Xt.Boolean;
    visual_set      : Xt.Boolean; (* used for visuals and does not reflect
                                   * the true state of the button  *)
    ind_on          : Xt.Boolean;
    fill_on_select  : Xt.Boolean;
    select_color    : Xt.Pixel;
    select_GC       : Xlib.GC;
    background_gc   : Xlib.GC;
    value_changed_CB: Xt.XtCallbackList;
    arm_CB          : Xt.XtCallbackList;
    disarm_CB       : Xt.XtCallbackList;
    Armed           : Xt.Boolean;
  END;

  XmToggleButtonPart = _XmToggleButtonPart;

(****************************************************************
 *
 * Full instance record declaration
 *
 ****************************************************************)

  _XmToggleButtonRec = RECORD
    core     : Xt.CorePart;
    primitive: XmPrimitivePart;
    label    : XmLabelPart;
    toggle   : XmToggleButtonPart;
  END;

  XmToggleButtonRec = _XmToggleButtonRec;

VAR
  xmToggleButtonClassRec: XmToggleButtonClassRec;

(********    Private Function Declarations    ********)
(********    End Private Function Declarations    ********)

(* ----------------------------------------------------- *)
(*                     Xm/ToggleBG.h                     *)
(* ----------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

(***********************************************************************
 *
 * Toggle Gadget
 *
 ***********************************************************************)

VAR
  xmToggleButtonGadgetClass: Xt.WidgetClass;

TYPE
  XmToggleButtonGadgetClass = POINTER TO _XmToggleButtonGadgetClassRec;

  XmToggleButtonGadget = POINTER TO _XmToggleButtonGadgetRec;

  XmToggleButtonGCacheObject = POINTER TO _XmToggleButtonGCacheObjRec;

(********    Public Function Declarations    ********)

PROCEDURE XmToggleButtonGadgetGetState ( w: Xt.Widget ): Xt.Boolean;

PROCEDURE XmToggleButtonGadgetSetState ( w: Xt.Widget;
                                         newstate: Xt.Boolean;
                                         notify: Xt.Boolean );

PROCEDURE XmCreateToggleButtonGadget ( parent: Xt.Widget;
                                       name: ARRAY OF CHAR;
                                       arglist: Xt.ArgList;
                                       argCount: Xt.Cardinal ): Xt.Widget;

(********    End Public Function Declarations    ********)

(* ------------------------------------------------------ *)
(*                     Xm/ToggleBGP.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2.1
 *)

(********************************************
 *
 *   No new fields need to be defined
 *   for the Toggle widget class record
 *
 ********************************************)

(***********************************************************************
 *  The  ToggleButton Gadget Cache Object's class and instance records *
 ***********************************************************************)

TYPE
  _XmToggleButtonGCacheObjClassPart = RECORD
    foo: SYSTEM.int;
  END;

  XmToggleButtonGCacheObjClassPart = _XmToggleButtonGCacheObjClassPart;

  _XmToggleButtonGCacheObjClassRec = RECORD
    object_class      : Xt.ObjectClassPart;
    ext_class         : XmExtClassPart;
    label_class_cache : XmLabelGCacheObjClassPart;
    toggle_class_cache: XmToggleButtonGCacheObjClassPart;
  END;

  XmToggleButtonGCacheObjClassRec = _XmToggleButtonGCacheObjClassRec;

  _XmToggleButtonGCacheObjPart = RECORD
    ind_type      : SHORTCARD;
    visible       : Xt.Boolean;
    spacing       : Xt.Dimension;
    indicator_dim : Xt.Dimension;
    on_pixmap     : X.Pixmap;
    insen_pixmap  : X.Pixmap;
    ind_on        : Xt.Boolean;
    fill_on_select: Xt.Boolean;
    select_color  : Xt.Pixel;
    select_GC     : Xlib.GC;
    background_gc : Xlib.GC;
  END;

  XmToggleButtonGCacheObjPart = _XmToggleButtonGCacheObjPart;

  XmToggleButtonGCache = POINTER TO _XmToggleButtonGCacheObjPart;

  _XmToggleButtonGCacheObjRec = RECORD
    object      : Xt.ObjectPart;
    ext         : XmExtPart;
    label_cache : XmLabelGCacheObjPart;
    toggle_cache: XmToggleButtonGCacheObjPart;
  END;

  XmToggleButtonGCacheObjRec = _XmToggleButtonGCacheObjRec;

(****************************************************
 *
 * Full class record declaration for Toggle class
 *
 ****************************************************)

  _XmToggleButtonGadgetClassPart = RECORD
    extension: Xt.XtPointer;
  END;

  XmToggleButtonGadgetClassPart = _XmToggleButtonGadgetClassPart;

  _XmToggleButtonGadgetClassRec = RECORD
    rect_class  : Xt.RectObjClassPart;
    gadget_class: XmGadgetClassPart;
    label_class : XmLabelGadgetClassPart;
    toggle_class: XmToggleButtonGadgetClassPart;
  END;

  XmToggleButtonGadgetClassRec = _XmToggleButtonGadgetClassRec;

  _XmToggleButtonGadgetPart = RECORD
    indicator_set   : Xt.Boolean;
    set             : Xt.Boolean;
    visual_set      : Xt.Boolean;     (* used for visuals and does not reflect
                                       * the true state of the button *)
    Armed           : Xt.Boolean;
    value_changed_CB: Xt.XtCallbackList;
    arm_CB          : Xt.XtCallbackList;
    disarm_CB       : Xt.XtCallbackList;
    cache: XmToggleButtonGCache; (* Replace cache instance fields
      	      	      	      	            * with a pointer  *)
  END;

  XmToggleButtonGadgetPart = _XmToggleButtonGadgetPart;

(****************************************************************
 *
 * Full instance record declaration
 *
 ****************************************************************)

  _XmToggleButtonGadgetRec = RECORD
    object   : Xt.ObjectPart;
    rectangle: Xt.RectObjPart;
    gadget   : XmGadgetPart;
    label    : XmLabelGadgetPart;
    toggle   : XmToggleButtonGadgetPart;
  END;

  XmToggleButtonGadgetRec = _XmToggleButtonGadgetRec;

VAR
  xmToggleButtonGCacheObjClassRec: XmToggleButtonGCacheObjClassRec;
  xmToggleButtonGadgetClassRec: XmToggleButtonGadgetClassRec;

(* MACROS *)
(**********)

(*  Macros for cached instance fields  *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE TBG_IndType ( w: Xt.Widget ): SHORTCARD;
PROCEDURE TBG_Visible ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE TBG_Spacing ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE TBG_IndicatorDim ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE TBG_OnPixmap ( w: Xt.Widget ): X.Pixmap;
PROCEDURE TBG_InsenPixmap ( w: Xt.Widget ): X.Pixmap;
PROCEDURE TBG_IndOn ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE TBG_FillOnSelect ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE TBG_SelectColor ( w: Xt.Widget ): Xt.Pixel;
PROCEDURE TBG_SelectGC ( w: Xt.Widget ): Xlib.GC;
PROCEDURE TBG_BackgroundGC ( w: Xt.Widget ): Xlib.GC;

<* ELSE *>

PROCEDURE  / TBG_IndType ( w: Xt.Widget ): SHORTCARD;
PROCEDURE  / TBG_Visible ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / TBG_Spacing ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / TBG_IndicatorDim ( w: Xt.Widget ): Xt.Dimension;
PROCEDURE  / TBG_OnPixmap ( w: Xt.Widget ): X.Pixmap;
PROCEDURE  / TBG_InsenPixmap ( w: Xt.Widget ): X.Pixmap;
PROCEDURE  / TBG_IndOn ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / TBG_FillOnSelect ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / TBG_SelectColor ( w: Xt.Widget ): Xt.Pixel;
PROCEDURE  / TBG_SelectGC ( w: Xt.Widget ): Xlib.GC;
PROCEDURE  / TBG_BackgroundGC ( w: Xt.Widget ): Xlib.GC;

<* END *>

(***************************************)
(*  Macros for uncached instance fields  *)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE TBG_IndicatorSet ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE TBG_Set ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE TBG_VisualSet ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE TBG_ValueChangedCB ( w: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE TBG_ArmCB ( w: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE TBG_DisarmCB ( w: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE TBG_Armed ( w: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / TBG_IndicatorSet ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / TBG_Set ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / TBG_VisualSet ( w: Xt.Widget ): Xt.Boolean;
PROCEDURE  / TBG_ValueChangedCB ( w: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / TBG_ArmCB ( w: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / TBG_DisarmCB ( w: Xt.Widget ): Xt.XtCallbackList;
PROCEDURE  / TBG_Armed ( w: Xt.Widget ): Xt.Boolean;

<* END *>

(******************************)
(*  Convenience Macros        *)
(******************************)

<* IF __GEN_C__ THEN *>

(* H2D: these procedures corresponds to macros. *)
PROCEDURE TBG_Cache ( w: Xt.Widget ): XmToggleButtonGCache;
PROCEDURE TBG_ClassCachePart ( w: Xt.WidgetClass ): XmCacheClassPartPtr;

<* ELSE *>

PROCEDURE  / TBG_Cache ( w: Xt.Widget ): XmToggleButtonGCache;
PROCEDURE  / TBG_ClassCachePart ( w: Xt.WidgetClass ): XmCacheClassPartPtr;

<* END *>

(********    Private Function Declarations    ********)

PROCEDURE _XmToggleBCacheCompare ( A: Xt.XtPointer;
                                   B: Xt.XtPointer ): SYSTEM.int;

(********    End Private Function Declarations    ********)

(* ------------------------------------------------------- *)
(*                     Xm/TransltnsP.h                     *)
(* ------------------------------------------------------- *)

(*
 * Motif Release 1.2.3
 *)

VAR
  _XmArrowB_defaultTranslations: Xt.String;
  _XmBulletinB_defaultTranslations: Xt.String;
  _XmCascadeB_menubar_events: Xt.String;
  _XmCascadeB_p_events: Xt.String;
  _XmDrawingA_defaultTranslations: Xt.String;
  _XmDrawingA_traversalTranslations: Xt.String;
  _XmDrawnB_defaultTranslations: Xt.String;
  _XmFrame_defaultTranslations: Xt.String;
  _XmLabel_defaultTranslations: Xt.String;
  _XmLabel_menuTranslations: Xt.String;
  _XmLabel_menu_traversal_events: Xt.String;
  _XmList_ListXlations1: Xt.String;
  _XmList_ListXlations2: Xt.String;
  _XmManager_managerTraversalTranslations: Xt.String;
  _XmManager_defaultTranslations: Xt.String;
  _XmMenuShell_translations: Xt.String;
  _XmPrimitive_defaultTranslations: Xt.String;
  _XmPushB_defaultTranslations: Xt.String;
  _XmPushB_menuTranslations: Xt.String;
  _XmRowColumn_menu_traversal_table: Xt.String;
  _XmRowColumn_bar_table: Xt.String;
  _XmRowColumn_option_table: Xt.String;
  _XmRowColumn_menu_table: Xt.String;
  _XmSash_defTranslations: Xt.String;
  _XmScrollBar_defaultTranslations: Xt.String;
  _XmScrolledW_ScrolledWindowXlations: Xt.String;
  _XmScrolledW_ClipWindowTranslationTable: Xt.String;
  _XmScrolledW_WorkWindowTranslationTable: Xt.String;
  _XmSelectioB_defaultTextAccelerators: Xt.String;
  _XmTearOffB_overrideTranslations: Xt.String;
  _XmTextF_EventBindings1: Xt.String;
  _XmTextF_EventBindings2: Xt.String;
  _XmTextF_EventBindings3: Xt.String;
  _XmTextIn_XmTextEventBindings1: Xt.String;
  _XmTextIn_XmTextEventBindings2: Xt.String;
  _XmTextIn_XmTextEventBindings3: Xt.String;
  _XmToggleB_defaultTranslations: Xt.String;
  _XmToggleB_menuTranslations: Xt.String;
  _XmVirtKeys_fallbackBindingString: Xt.String;

(*  The following keybindings have been "grandfathered"
 *  for backward compatablility.
 *)
  _XmVirtKeys_acornFallbackBindingString: Xt.String;
  _XmVirtKeys_apolloFallbackBindingString: Xt.String;
  _XmVirtKeys_dgFallbackBindingString: Xt.String;
  _XmVirtKeys_decFallbackBindingString: Xt.String;
  _XmVirtKeys_dblclkFallbackBindingString: Xt.String;
  _XmVirtKeys_hpFallbackBindingString: Xt.String;
  _XmVirtKeys_ibmFallbackBindingString: Xt.String;
  _XmVirtKeys_ingrFallbackBindingString: Xt.String;
  _XmVirtKeys_megatekFallbackBindingString: Xt.String;
  _XmVirtKeys_motorolaFallbackBindingString: Xt.String;
  _XmVirtKeys_sgiFallbackBindingString: Xt.String;
  _XmVirtKeys_siemensWx200FallbackBindingString: Xt.String;
  _XmVirtKeys_siemens9733FallbackBindingString: Xt.String;
  _XmVirtKeys_sunFallbackBindingString: Xt.String;
  _XmVirtKeys_tekFallbackBindingString: Xt.String;

(* ------------------------------------------------------ *)
(*                     Xm/VaSimpleP.h                     *)
(* ------------------------------------------------------ *)

(*
 * Motif Release 1.2.4
 *)

TYPE
  va_list = SYSTEM.ADDRESS;

(* In R6, Xt.h also defines this type, so
 * we need to control its declaration in order to compile *)

CONST
  StringToName = Xrm.XrmStringToName;

(********  Private Function Declarations  ********)

PROCEDURE _XmCountVaList ( var: va_list;
                           VAR button_count: SYSTEM.int;
                           VAR args_count: SYSTEM.int;
                           VAR typed_count: SYSTEM.int;
                           VAR total_count: SYSTEM.int );

PROCEDURE _XmVaToTypedArgList ( var: va_list;
                                max_count: SYSTEM.int;
                                VAR args_return: Xt.XtTypedArgList;
                                VAR num_args_return: Xt.Cardinal );

(********  End Private Function Declarations  ********)

(* --------------------------------------------------- *)
(*                     Xm/WorldP.h                     *)
(* --------------------------------------------------- *)

(*
 * Motif Release 1.2
 *)

<* IF __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE XmIsWorldObject ( w: Xt.Widget ): Xt.Boolean;

<* ELSE *>

PROCEDURE  / XmIsWorldObject ( w: Xt.Widget ): Xt.Boolean;

<* END *>

TYPE
  XmWorldObject = POINTER TO _XmWorldRec;

  XmWorldObjectClass = POINTER TO _XmWorldClassRec;

  _XmWorldClassPart = RECORD
    extension: Xt.XtPointer;
  END;

  XmWorldClassPart = _XmWorldClassPart;

  XmWorldClassPartPtr = POINTER TO _XmWorldClassPart;

  _XmWorldClassRec = RECORD
    object_class : Xt.ObjectClassPart;
    ext_class    : XmExtClassPart;
    desktop_class: XmDesktopClassPart;
    world_class  : XmWorldClassPart;
  END;

  XmWorldClassRec = _XmWorldClassRec;

  _XmWorldPart = RECORD
    foo: SYSTEM.int;
  END;

  XmWorldPart = _XmWorldPart;

  XmWorldPartPtr = POINTER TO _XmWorldPart;

  _XmWorldRec = RECORD
    object : Xt.ObjectPart;
    ext    : XmExtPart;
    desktop: XmDesktopPart;
    world  : XmWorldPart;
  END;

  XmWorldRec = _XmWorldRec;

VAR
  xmWorldClass: Xt.WidgetClass;
  xmWorldClassRec: XmWorldClassRec;

(********    Private Function Declarations    ********)

PROCEDURE _XmGetWorldObject ( shell: Xt.Widget;
                              args: Xt.ArgList;
                              VAR num_args: Xt.Cardinal ): XmWorldObject;

(********    End Private Function Declarations    ********)

END XmAllP.
